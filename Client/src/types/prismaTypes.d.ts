
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Conference
 * 
 */
export type Conference = $Result.DefaultSelection<Prisma.$ConferencePayload>
/**
 * Model ConferenceMember
 * 
 */
export type ConferenceMember = $Result.DefaultSelection<Prisma.$ConferenceMemberPayload>
/**
 * Model Day
 * 
 */
export type Day = $Result.DefaultSelection<Prisma.$DayPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model TimeSlot
 * 
 */
export type TimeSlot = $Result.DefaultSelection<Prisma.$TimeSlotPayload>
/**
 * Model AbstractSubmission
 * 
 */
export type AbstractSubmission = $Result.DefaultSelection<Prisma.$AbstractSubmissionPayload>
/**
 * Model AbstractReview
 * 
 */
export type AbstractReview = $Result.DefaultSelection<Prisma.$AbstractReviewPayload>
/**
 * Model Presentation
 * 
 */
export type Presentation = $Result.DefaultSelection<Prisma.$PresentationPayload>
/**
 * Model PresentationAuthor
 * 
 */
export type PresentationAuthor = $Result.DefaultSelection<Prisma.$PresentationAuthorPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model PresentationType
 * 
 */
export type PresentationType = $Result.DefaultSelection<Prisma.$PresentationTypePayload>
/**
 * Model SubmissionSettings
 * 
 */
export type SubmissionSettings = $Result.DefaultSelection<Prisma.$SubmissionSettingsPayload>
/**
 * Model ConferenceFeedback
 * 
 */
export type ConferenceFeedback = $Result.DefaultSelection<Prisma.$ConferenceFeedbackPayload>
/**
 * Model PresentationFeedback
 * 
 */
export type PresentationFeedback = $Result.DefaultSelection<Prisma.$PresentationFeedbackPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  attendee: 'attendee',
  presenter: 'presenter',
  organizer: 'organizer',
  admin: 'admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ConferenceStatus: {
  draft: 'draft',
  call_for_papers: 'call_for_papers',
  published: 'published',
  canceled: 'canceled',
  completed: 'completed'
};

export type ConferenceStatus = (typeof ConferenceStatus)[keyof typeof ConferenceStatus]


export const AbstractSubmissionStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  REVISION_REQUESTED: 'REVISION_REQUESTED',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type AbstractSubmissionStatus = (typeof AbstractSubmissionStatus)[keyof typeof AbstractSubmissionStatus]


export const ReviewStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  REVISION_REQUESTED: 'REVISION_REQUESTED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const SectionType: {
  presentation: 'presentation',
  keynote: 'keynote',
  workshop: 'workshop',
  panel: 'panel',
  networking: 'networking',
  break: 'break'
};

export type SectionType = (typeof SectionType)[keyof typeof SectionType]


export const SlotType: {
  PRESENTATION: 'PRESENTATION',
  BREAK: 'BREAK',
  LUNCH: 'LUNCH',
  NETWORKING: 'NETWORKING',
  OPENING: 'OPENING',
  CLOSING: 'CLOSING'
};

export type SlotType = (typeof SlotType)[keyof typeof SlotType]


export const BreakType: {
  COFFEE_BREAK: 'COFFEE_BREAK',
  LUNCH_BREAK: 'LUNCH_BREAK',
  NETWORKING_BREAK: 'NETWORKING_BREAK',
  REST_BREAK: 'REST_BREAK',
  GENERAL_BREAK: 'GENERAL_BREAK'
};

export type BreakType = (typeof BreakType)[keyof typeof BreakType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ConferenceStatus = $Enums.ConferenceStatus

export const ConferenceStatus: typeof $Enums.ConferenceStatus

export type AbstractSubmissionStatus = $Enums.AbstractSubmissionStatus

export const AbstractSubmissionStatus: typeof $Enums.AbstractSubmissionStatus

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type SectionType = $Enums.SectionType

export const SectionType: typeof $Enums.SectionType

export type SlotType = $Enums.SlotType

export const SlotType: typeof $Enums.SlotType

export type BreakType = $Enums.BreakType

export const BreakType: typeof $Enums.BreakType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conference`: Exposes CRUD operations for the **Conference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conferences
    * const conferences = await prisma.conference.findMany()
    * ```
    */
  get conference(): Prisma.ConferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceMember`: Exposes CRUD operations for the **ConferenceMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceMembers
    * const conferenceMembers = await prisma.conferenceMember.findMany()
    * ```
    */
  get conferenceMember(): Prisma.ConferenceMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.day`: Exposes CRUD operations for the **Day** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Days
    * const days = await prisma.day.findMany()
    * ```
    */
  get day(): Prisma.DayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSlot`: Exposes CRUD operations for the **TimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlots
    * const timeSlots = await prisma.timeSlot.findMany()
    * ```
    */
  get timeSlot(): Prisma.TimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.abstractSubmission`: Exposes CRUD operations for the **AbstractSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AbstractSubmissions
    * const abstractSubmissions = await prisma.abstractSubmission.findMany()
    * ```
    */
  get abstractSubmission(): Prisma.AbstractSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.abstractReview`: Exposes CRUD operations for the **AbstractReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AbstractReviews
    * const abstractReviews = await prisma.abstractReview.findMany()
    * ```
    */
  get abstractReview(): Prisma.AbstractReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presentation`: Exposes CRUD operations for the **Presentation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presentations
    * const presentations = await prisma.presentation.findMany()
    * ```
    */
  get presentation(): Prisma.PresentationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presentationAuthor`: Exposes CRUD operations for the **PresentationAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PresentationAuthors
    * const presentationAuthors = await prisma.presentationAuthor.findMany()
    * ```
    */
  get presentationAuthor(): Prisma.PresentationAuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presentationType`: Exposes CRUD operations for the **PresentationType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PresentationTypes
    * const presentationTypes = await prisma.presentationType.findMany()
    * ```
    */
  get presentationType(): Prisma.PresentationTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submissionSettings`: Exposes CRUD operations for the **SubmissionSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubmissionSettings
    * const submissionSettings = await prisma.submissionSettings.findMany()
    * ```
    */
  get submissionSettings(): Prisma.SubmissionSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceFeedback`: Exposes CRUD operations for the **ConferenceFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceFeedbacks
    * const conferenceFeedbacks = await prisma.conferenceFeedback.findMany()
    * ```
    */
  get conferenceFeedback(): Prisma.ConferenceFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presentationFeedback`: Exposes CRUD operations for the **PresentationFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PresentationFeedbacks
    * const presentationFeedbacks = await prisma.presentationFeedback.findMany()
    * ```
    */
  get presentationFeedback(): Prisma.PresentationFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Conference: 'Conference',
    ConferenceMember: 'ConferenceMember',
    Day: 'Day',
    Section: 'Section',
    TimeSlot: 'TimeSlot',
    AbstractSubmission: 'AbstractSubmission',
    AbstractReview: 'AbstractReview',
    Presentation: 'Presentation',
    PresentationAuthor: 'PresentationAuthor',
    Category: 'Category',
    PresentationType: 'PresentationType',
    SubmissionSettings: 'SubmissionSettings',
    ConferenceFeedback: 'ConferenceFeedback',
    PresentationFeedback: 'PresentationFeedback',
    Notification: 'Notification',
    RefreshToken: 'RefreshToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "conference" | "conferenceMember" | "day" | "section" | "timeSlot" | "abstractSubmission" | "abstractReview" | "presentation" | "presentationAuthor" | "category" | "presentationType" | "submissionSettings" | "conferenceFeedback" | "presentationFeedback" | "notification" | "refreshToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Conference: {
        payload: Prisma.$ConferencePayload<ExtArgs>
        fields: Prisma.ConferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>
          }
          findFirst: {
            args: Prisma.ConferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>
          }
          findMany: {
            args: Prisma.ConferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>[]
          }
          create: {
            args: Prisma.ConferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>
          }
          createMany: {
            args: Prisma.ConferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>[]
          }
          delete: {
            args: Prisma.ConferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>
          }
          update: {
            args: Prisma.ConferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>
          }
          deleteMany: {
            args: Prisma.ConferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>[]
          }
          upsert: {
            args: Prisma.ConferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencePayload>
          }
          aggregate: {
            args: Prisma.ConferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConference>
          }
          groupBy: {
            args: Prisma.ConferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCountAggregateOutputType> | number
          }
        }
      }
      ConferenceMember: {
        payload: Prisma.$ConferenceMemberPayload<ExtArgs>
        fields: Prisma.ConferenceMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>
          }
          findFirst: {
            args: Prisma.ConferenceMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>
          }
          findMany: {
            args: Prisma.ConferenceMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>[]
          }
          create: {
            args: Prisma.ConferenceMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>
          }
          createMany: {
            args: Prisma.ConferenceMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>[]
          }
          delete: {
            args: Prisma.ConferenceMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>
          }
          update: {
            args: Prisma.ConferenceMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceMemberPayload>
          }
          aggregate: {
            args: Prisma.ConferenceMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceMember>
          }
          groupBy: {
            args: Prisma.ConferenceMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceMemberCountAggregateOutputType> | number
          }
        }
      }
      Day: {
        payload: Prisma.$DayPayload<ExtArgs>
        fields: Prisma.DayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>
          }
          findFirst: {
            args: Prisma.DayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>
          }
          findMany: {
            args: Prisma.DayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>[]
          }
          create: {
            args: Prisma.DayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>
          }
          createMany: {
            args: Prisma.DayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>[]
          }
          delete: {
            args: Prisma.DayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>
          }
          update: {
            args: Prisma.DayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>
          }
          deleteMany: {
            args: Prisma.DayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>[]
          }
          upsert: {
            args: Prisma.DayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPayload>
          }
          aggregate: {
            args: Prisma.DayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDay>
          }
          groupBy: {
            args: Prisma.DayGroupByArgs<ExtArgs>
            result: $Utils.Optional<DayGroupByOutputType>[]
          }
          count: {
            args: Prisma.DayCountArgs<ExtArgs>
            result: $Utils.Optional<DayCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      TimeSlot: {
        payload: Prisma.$TimeSlotPayload<ExtArgs>
        fields: Prisma.TimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findFirst: {
            args: Prisma.TimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findMany: {
            args: Prisma.TimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          create: {
            args: Prisma.TimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          createMany: {
            args: Prisma.TimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          delete: {
            args: Prisma.TimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          update: {
            args: Prisma.TimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.TimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.TimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          aggregate: {
            args: Prisma.TimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSlot>
          }
          groupBy: {
            args: Prisma.TimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotCountAggregateOutputType> | number
          }
        }
      }
      AbstractSubmission: {
        payload: Prisma.$AbstractSubmissionPayload<ExtArgs>
        fields: Prisma.AbstractSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbstractSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbstractSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>
          }
          findFirst: {
            args: Prisma.AbstractSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbstractSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>
          }
          findMany: {
            args: Prisma.AbstractSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>[]
          }
          create: {
            args: Prisma.AbstractSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>
          }
          createMany: {
            args: Prisma.AbstractSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AbstractSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>[]
          }
          delete: {
            args: Prisma.AbstractSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>
          }
          update: {
            args: Prisma.AbstractSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.AbstractSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbstractSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AbstractSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.AbstractSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractSubmissionPayload>
          }
          aggregate: {
            args: Prisma.AbstractSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbstractSubmission>
          }
          groupBy: {
            args: Prisma.AbstractSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbstractSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbstractSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AbstractSubmissionCountAggregateOutputType> | number
          }
        }
      }
      AbstractReview: {
        payload: Prisma.$AbstractReviewPayload<ExtArgs>
        fields: Prisma.AbstractReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbstractReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbstractReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>
          }
          findFirst: {
            args: Prisma.AbstractReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbstractReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>
          }
          findMany: {
            args: Prisma.AbstractReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>[]
          }
          create: {
            args: Prisma.AbstractReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>
          }
          createMany: {
            args: Prisma.AbstractReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AbstractReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>[]
          }
          delete: {
            args: Prisma.AbstractReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>
          }
          update: {
            args: Prisma.AbstractReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>
          }
          deleteMany: {
            args: Prisma.AbstractReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbstractReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AbstractReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>[]
          }
          upsert: {
            args: Prisma.AbstractReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbstractReviewPayload>
          }
          aggregate: {
            args: Prisma.AbstractReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbstractReview>
          }
          groupBy: {
            args: Prisma.AbstractReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbstractReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbstractReviewCountArgs<ExtArgs>
            result: $Utils.Optional<AbstractReviewCountAggregateOutputType> | number
          }
        }
      }
      Presentation: {
        payload: Prisma.$PresentationPayload<ExtArgs>
        fields: Prisma.PresentationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresentationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresentationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>
          }
          findFirst: {
            args: Prisma.PresentationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresentationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>
          }
          findMany: {
            args: Prisma.PresentationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>[]
          }
          create: {
            args: Prisma.PresentationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>
          }
          createMany: {
            args: Prisma.PresentationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresentationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>[]
          }
          delete: {
            args: Prisma.PresentationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>
          }
          update: {
            args: Prisma.PresentationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>
          }
          deleteMany: {
            args: Prisma.PresentationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresentationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresentationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>[]
          }
          upsert: {
            args: Prisma.PresentationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationPayload>
          }
          aggregate: {
            args: Prisma.PresentationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresentation>
          }
          groupBy: {
            args: Prisma.PresentationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresentationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresentationCountArgs<ExtArgs>
            result: $Utils.Optional<PresentationCountAggregateOutputType> | number
          }
        }
      }
      PresentationAuthor: {
        payload: Prisma.$PresentationAuthorPayload<ExtArgs>
        fields: Prisma.PresentationAuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresentationAuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresentationAuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>
          }
          findFirst: {
            args: Prisma.PresentationAuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresentationAuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>
          }
          findMany: {
            args: Prisma.PresentationAuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>[]
          }
          create: {
            args: Prisma.PresentationAuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>
          }
          createMany: {
            args: Prisma.PresentationAuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresentationAuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>[]
          }
          delete: {
            args: Prisma.PresentationAuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>
          }
          update: {
            args: Prisma.PresentationAuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>
          }
          deleteMany: {
            args: Prisma.PresentationAuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresentationAuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresentationAuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>[]
          }
          upsert: {
            args: Prisma.PresentationAuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationAuthorPayload>
          }
          aggregate: {
            args: Prisma.PresentationAuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresentationAuthor>
          }
          groupBy: {
            args: Prisma.PresentationAuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresentationAuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresentationAuthorCountArgs<ExtArgs>
            result: $Utils.Optional<PresentationAuthorCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      PresentationType: {
        payload: Prisma.$PresentationTypePayload<ExtArgs>
        fields: Prisma.PresentationTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresentationTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresentationTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>
          }
          findFirst: {
            args: Prisma.PresentationTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresentationTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>
          }
          findMany: {
            args: Prisma.PresentationTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>[]
          }
          create: {
            args: Prisma.PresentationTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>
          }
          createMany: {
            args: Prisma.PresentationTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresentationTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>[]
          }
          delete: {
            args: Prisma.PresentationTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>
          }
          update: {
            args: Prisma.PresentationTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>
          }
          deleteMany: {
            args: Prisma.PresentationTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresentationTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresentationTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>[]
          }
          upsert: {
            args: Prisma.PresentationTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationTypePayload>
          }
          aggregate: {
            args: Prisma.PresentationTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresentationType>
          }
          groupBy: {
            args: Prisma.PresentationTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresentationTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresentationTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PresentationTypeCountAggregateOutputType> | number
          }
        }
      }
      SubmissionSettings: {
        payload: Prisma.$SubmissionSettingsPayload<ExtArgs>
        fields: Prisma.SubmissionSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>
          }
          findFirst: {
            args: Prisma.SubmissionSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>
          }
          findMany: {
            args: Prisma.SubmissionSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>[]
          }
          create: {
            args: Prisma.SubmissionSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>
          }
          createMany: {
            args: Prisma.SubmissionSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>[]
          }
          delete: {
            args: Prisma.SubmissionSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>
          }
          update: {
            args: Prisma.SubmissionSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubmissionSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SubmissionSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionSettingsPayload>
          }
          aggregate: {
            args: Prisma.SubmissionSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmissionSettings>
          }
          groupBy: {
            args: Prisma.SubmissionSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionSettingsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceFeedback: {
        payload: Prisma.$ConferenceFeedbackPayload<ExtArgs>
        fields: Prisma.ConferenceFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>
          }
          findFirst: {
            args: Prisma.ConferenceFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>
          }
          findMany: {
            args: Prisma.ConferenceFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>[]
          }
          create: {
            args: Prisma.ConferenceFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>
          }
          createMany: {
            args: Prisma.ConferenceFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>[]
          }
          delete: {
            args: Prisma.ConferenceFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>
          }
          update: {
            args: Prisma.ConferenceFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbackPayload>
          }
          aggregate: {
            args: Prisma.ConferenceFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceFeedback>
          }
          groupBy: {
            args: Prisma.ConferenceFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFeedbackCountAggregateOutputType> | number
          }
        }
      }
      PresentationFeedback: {
        payload: Prisma.$PresentationFeedbackPayload<ExtArgs>
        fields: Prisma.PresentationFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresentationFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresentationFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>
          }
          findFirst: {
            args: Prisma.PresentationFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresentationFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>
          }
          findMany: {
            args: Prisma.PresentationFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>[]
          }
          create: {
            args: Prisma.PresentationFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>
          }
          createMany: {
            args: Prisma.PresentationFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresentationFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>[]
          }
          delete: {
            args: Prisma.PresentationFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>
          }
          update: {
            args: Prisma.PresentationFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.PresentationFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresentationFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresentationFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.PresentationFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresentationFeedbackPayload>
          }
          aggregate: {
            args: Prisma.PresentationFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresentationFeedback>
          }
          groupBy: {
            args: Prisma.PresentationFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresentationFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresentationFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<PresentationFeedbackCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    conference?: ConferenceOmit
    conferenceMember?: ConferenceMemberOmit
    day?: DayOmit
    section?: SectionOmit
    timeSlot?: TimeSlotOmit
    abstractSubmission?: AbstractSubmissionOmit
    abstractReview?: AbstractReviewOmit
    presentation?: PresentationOmit
    presentationAuthor?: PresentationAuthorOmit
    category?: CategoryOmit
    presentationType?: PresentationTypeOmit
    submissionSettings?: SubmissionSettingsOmit
    conferenceFeedback?: ConferenceFeedbackOmit
    presentationFeedback?: PresentationFeedbackOmit
    notification?: NotificationOmit
    refreshToken?: RefreshTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    conferences: number
    conferenceMembership: number
    abstractSubmissions: number
    abstractReviews: number
    presentations: number
    notifications: number
    conferenceFeedback: number
    presentationFeedback: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conferences?: boolean | UserCountOutputTypeCountConferencesArgs
    conferenceMembership?: boolean | UserCountOutputTypeCountConferenceMembershipArgs
    abstractSubmissions?: boolean | UserCountOutputTypeCountAbstractSubmissionsArgs
    abstractReviews?: boolean | UserCountOutputTypeCountAbstractReviewsArgs
    presentations?: boolean | UserCountOutputTypeCountPresentationsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    conferenceFeedback?: boolean | UserCountOutputTypeCountConferenceFeedbackArgs
    presentationFeedback?: boolean | UserCountOutputTypeCountPresentationFeedbackArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConferenceMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbstractSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbstractReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPresentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationAuthorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConferenceFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPresentationFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }


  /**
   * Count Type ConferenceCountOutputType
   */

  export type ConferenceCountOutputType = {
    members: number
    days: number
    sections: number
    categories: number
    presentationTypes: number
    abstractSubmissions: number
    presentations: number
    feedback: number
  }

  export type ConferenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ConferenceCountOutputTypeCountMembersArgs
    days?: boolean | ConferenceCountOutputTypeCountDaysArgs
    sections?: boolean | ConferenceCountOutputTypeCountSectionsArgs
    categories?: boolean | ConferenceCountOutputTypeCountCategoriesArgs
    presentationTypes?: boolean | ConferenceCountOutputTypeCountPresentationTypesArgs
    abstractSubmissions?: boolean | ConferenceCountOutputTypeCountAbstractSubmissionsArgs
    presentations?: boolean | ConferenceCountOutputTypeCountPresentationsArgs
    feedback?: boolean | ConferenceCountOutputTypeCountFeedbackArgs
  }

  // Custom InputTypes
  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCountOutputType
     */
    select?: ConferenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceMemberWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountPresentationTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationTypeWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountAbstractSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractSubmissionWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountPresentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationWhereInput
  }

  /**
   * ConferenceCountOutputType without action
   */
  export type ConferenceCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbackWhereInput
  }


  /**
   * Count Type DayCountOutputType
   */

  export type DayCountOutputType = {
    sections: number
  }

  export type DayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | DayCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * DayCountOutputType without action
   */
  export type DayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayCountOutputType
     */
    select?: DayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DayCountOutputType without action
   */
  export type DayCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    timeSlots: number
    presentations: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeSlots?: boolean | SectionCountOutputTypeCountTimeSlotsArgs
    presentations?: boolean | SectionCountOutputTypeCountPresentationsArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountPresentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationWhereInput
  }


  /**
   * Count Type AbstractSubmissionCountOutputType
   */

  export type AbstractSubmissionCountOutputType = {
    reviews: number
  }

  export type AbstractSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | AbstractSubmissionCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * AbstractSubmissionCountOutputType without action
   */
  export type AbstractSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmissionCountOutputType
     */
    select?: AbstractSubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbstractSubmissionCountOutputType without action
   */
  export type AbstractSubmissionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractReviewWhereInput
  }


  /**
   * Count Type PresentationCountOutputType
   */

  export type PresentationCountOutputType = {
    authors: number
    feedback: number
  }

  export type PresentationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authors?: boolean | PresentationCountOutputTypeCountAuthorsArgs
    feedback?: boolean | PresentationCountOutputTypeCountFeedbackArgs
  }

  // Custom InputTypes
  /**
   * PresentationCountOutputType without action
   */
  export type PresentationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationCountOutputType
     */
    select?: PresentationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PresentationCountOutputType without action
   */
  export type PresentationCountOutputTypeCountAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationAuthorWhereInput
  }

  /**
   * PresentationCountOutputType without action
   */
  export type PresentationCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationFeedbackWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    presentations: number
    sections: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentations?: boolean | CategoryCountOutputTypeCountPresentationsArgs
    sections?: boolean | CategoryCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPresentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }


  /**
   * Count Type PresentationTypeCountOutputType
   */

  export type PresentationTypeCountOutputType = {
    presentations: number
    abstractSubmissions: number
  }

  export type PresentationTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentations?: boolean | PresentationTypeCountOutputTypeCountPresentationsArgs
    abstractSubmissions?: boolean | PresentationTypeCountOutputTypeCountAbstractSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * PresentationTypeCountOutputType without action
   */
  export type PresentationTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationTypeCountOutputType
     */
    select?: PresentationTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PresentationTypeCountOutputType without action
   */
  export type PresentationTypeCountOutputTypeCountPresentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationWhereInput
  }

  /**
   * PresentationTypeCountOutputType without action
   */
  export type PresentationTypeCountOutputTypeCountAbstractSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractSubmissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    cognitoId: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    cognitoId: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    cognitoId: number
    name: number
    email: number
    password: number
    roles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    cognitoId?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    cognitoId?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    cognitoId?: true
    name?: true
    email?: true
    password?: true
    roles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    cognitoId: string | null
    name: string
    email: string
    password: string | null
    roles: $Enums.Role[]
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cognitoId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conferences?: boolean | User$conferencesArgs<ExtArgs>
    conferenceMembership?: boolean | User$conferenceMembershipArgs<ExtArgs>
    abstractSubmissions?: boolean | User$abstractSubmissionsArgs<ExtArgs>
    abstractReviews?: boolean | User$abstractReviewsArgs<ExtArgs>
    presentations?: boolean | User$presentationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    conferenceFeedback?: boolean | User$conferenceFeedbackArgs<ExtArgs>
    presentationFeedback?: boolean | User$presentationFeedbackArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cognitoId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cognitoId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    cognitoId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cognitoId" | "name" | "email" | "password" | "roles" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conferences?: boolean | User$conferencesArgs<ExtArgs>
    conferenceMembership?: boolean | User$conferenceMembershipArgs<ExtArgs>
    abstractSubmissions?: boolean | User$abstractSubmissionsArgs<ExtArgs>
    abstractReviews?: boolean | User$abstractReviewsArgs<ExtArgs>
    presentations?: boolean | User$presentationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    conferenceFeedback?: boolean | User$conferenceFeedbackArgs<ExtArgs>
    presentationFeedback?: boolean | User$presentationFeedbackArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      conferences: Prisma.$ConferencePayload<ExtArgs>[]
      conferenceMembership: Prisma.$ConferenceMemberPayload<ExtArgs>[]
      abstractSubmissions: Prisma.$AbstractSubmissionPayload<ExtArgs>[]
      abstractReviews: Prisma.$AbstractReviewPayload<ExtArgs>[]
      presentations: Prisma.$PresentationAuthorPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      conferenceFeedback: Prisma.$ConferenceFeedbackPayload<ExtArgs>[]
      presentationFeedback: Prisma.$PresentationFeedbackPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cognitoId: string | null
      name: string
      email: string
      password: string | null
      roles: $Enums.Role[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conferences<T extends User$conferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$conferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conferenceMembership<T extends User$conferenceMembershipArgs<ExtArgs> = {}>(args?: Subset<T, User$conferenceMembershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abstractSubmissions<T extends User$abstractSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$abstractSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abstractReviews<T extends User$abstractReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$abstractReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presentations<T extends User$presentationsArgs<ExtArgs> = {}>(args?: Subset<T, User$presentationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conferenceFeedback<T extends User$conferenceFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$conferenceFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presentationFeedback<T extends User$presentationFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$presentationFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly cognitoId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly roles: FieldRef<"User", 'Role[]'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.conferences
   */
  export type User$conferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    where?: ConferenceWhereInput
    orderBy?: ConferenceOrderByWithRelationInput | ConferenceOrderByWithRelationInput[]
    cursor?: ConferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceScalarFieldEnum | ConferenceScalarFieldEnum[]
  }

  /**
   * User.conferenceMembership
   */
  export type User$conferenceMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    where?: ConferenceMemberWhereInput
    orderBy?: ConferenceMemberOrderByWithRelationInput | ConferenceMemberOrderByWithRelationInput[]
    cursor?: ConferenceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceMemberScalarFieldEnum | ConferenceMemberScalarFieldEnum[]
  }

  /**
   * User.abstractSubmissions
   */
  export type User$abstractSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    where?: AbstractSubmissionWhereInput
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    cursor?: AbstractSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbstractSubmissionScalarFieldEnum | AbstractSubmissionScalarFieldEnum[]
  }

  /**
   * User.abstractReviews
   */
  export type User$abstractReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    where?: AbstractReviewWhereInput
    orderBy?: AbstractReviewOrderByWithRelationInput | AbstractReviewOrderByWithRelationInput[]
    cursor?: AbstractReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbstractReviewScalarFieldEnum | AbstractReviewScalarFieldEnum[]
  }

  /**
   * User.presentations
   */
  export type User$presentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    where?: PresentationAuthorWhereInput
    orderBy?: PresentationAuthorOrderByWithRelationInput | PresentationAuthorOrderByWithRelationInput[]
    cursor?: PresentationAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationAuthorScalarFieldEnum | PresentationAuthorScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.conferenceFeedback
   */
  export type User$conferenceFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    where?: ConferenceFeedbackWhereInput
    orderBy?: ConferenceFeedbackOrderByWithRelationInput | ConferenceFeedbackOrderByWithRelationInput[]
    cursor?: ConferenceFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFeedbackScalarFieldEnum | ConferenceFeedbackScalarFieldEnum[]
  }

  /**
   * User.presentationFeedback
   */
  export type User$presentationFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    where?: PresentationFeedbackWhereInput
    orderBy?: PresentationFeedbackOrderByWithRelationInput | PresentationFeedbackOrderByWithRelationInput[]
    cursor?: PresentationFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationFeedbackScalarFieldEnum | PresentationFeedbackScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Conference
   */

  export type AggregateConference = {
    _count: ConferenceCountAggregateOutputType | null
    _avg: ConferenceAvgAggregateOutputType | null
    _sum: ConferenceSumAggregateOutputType | null
    _min: ConferenceMinAggregateOutputType | null
    _max: ConferenceMaxAggregateOutputType | null
  }

  export type ConferenceAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type ConferenceSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type ConferenceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    status: $Enums.ConferenceStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    status: $Enums.ConferenceStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    location: number
    status: number
    topics: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type ConferenceSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type ConferenceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    status?: true
    topics?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conference to aggregate.
     */
    where?: ConferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferenceOrderByWithRelationInput | ConferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conferences
    **/
    _count?: true | ConferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceMaxAggregateInputType
  }

  export type GetConferenceAggregateType<T extends ConferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateConference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConference[P]>
      : GetScalarType<T[P], AggregateConference[P]>
  }




  export type ConferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceWhereInput
    orderBy?: ConferenceOrderByWithAggregationInput | ConferenceOrderByWithAggregationInput[]
    by: ConferenceScalarFieldEnum[] | ConferenceScalarFieldEnum
    having?: ConferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceCountAggregateInputType | true
    _avg?: ConferenceAvgAggregateInputType
    _sum?: ConferenceSumAggregateInputType
    _min?: ConferenceMinAggregateInputType
    _max?: ConferenceMaxAggregateInputType
  }

  export type ConferenceGroupByOutputType = {
    id: number
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    location: string | null
    status: $Enums.ConferenceStatus
    topics: string[]
    createdById: number
    createdAt: Date
    updatedAt: Date
    _count: ConferenceCountAggregateOutputType | null
    _avg: ConferenceAvgAggregateOutputType | null
    _sum: ConferenceSumAggregateOutputType | null
    _min: ConferenceMinAggregateOutputType | null
    _max: ConferenceMaxAggregateOutputType | null
  }

  type GetConferenceGroupByPayload<T extends ConferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    status?: boolean
    topics?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Conference$membersArgs<ExtArgs>
    days?: boolean | Conference$daysArgs<ExtArgs>
    sections?: boolean | Conference$sectionsArgs<ExtArgs>
    categories?: boolean | Conference$categoriesArgs<ExtArgs>
    presentationTypes?: boolean | Conference$presentationTypesArgs<ExtArgs>
    submissionSettings?: boolean | Conference$submissionSettingsArgs<ExtArgs>
    abstractSubmissions?: boolean | Conference$abstractSubmissionsArgs<ExtArgs>
    presentations?: boolean | Conference$presentationsArgs<ExtArgs>
    feedback?: boolean | Conference$feedbackArgs<ExtArgs>
    _count?: boolean | ConferenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference"]>

  export type ConferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    status?: boolean
    topics?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference"]>

  export type ConferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    status?: boolean
    topics?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference"]>

  export type ConferenceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    status?: boolean
    topics?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "startDate" | "endDate" | "location" | "status" | "topics" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["conference"]>
  export type ConferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Conference$membersArgs<ExtArgs>
    days?: boolean | Conference$daysArgs<ExtArgs>
    sections?: boolean | Conference$sectionsArgs<ExtArgs>
    categories?: boolean | Conference$categoriesArgs<ExtArgs>
    presentationTypes?: boolean | Conference$presentationTypesArgs<ExtArgs>
    submissionSettings?: boolean | Conference$submissionSettingsArgs<ExtArgs>
    abstractSubmissions?: boolean | Conference$abstractSubmissionsArgs<ExtArgs>
    presentations?: boolean | Conference$presentationsArgs<ExtArgs>
    feedback?: boolean | Conference$feedbackArgs<ExtArgs>
    _count?: boolean | ConferenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conference"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ConferenceMemberPayload<ExtArgs>[]
      days: Prisma.$DayPayload<ExtArgs>[]
      sections: Prisma.$SectionPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      presentationTypes: Prisma.$PresentationTypePayload<ExtArgs>[]
      submissionSettings: Prisma.$SubmissionSettingsPayload<ExtArgs> | null
      abstractSubmissions: Prisma.$AbstractSubmissionPayload<ExtArgs>[]
      presentations: Prisma.$PresentationPayload<ExtArgs>[]
      feedback: Prisma.$ConferenceFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      location: string | null
      status: $Enums.ConferenceStatus
      topics: string[]
      createdById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conference"]>
    composites: {}
  }

  type ConferenceGetPayload<S extends boolean | null | undefined | ConferenceDefaultArgs> = $Result.GetResult<Prisma.$ConferencePayload, S>

  type ConferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceCountAggregateInputType | true
    }

  export interface ConferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conference'], meta: { name: 'Conference' } }
    /**
     * Find zero or one Conference that matches the filter.
     * @param {ConferenceFindUniqueArgs} args - Arguments to find a Conference
     * @example
     * // Get one Conference
     * const conference = await prisma.conference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceFindUniqueArgs>(args: SelectSubset<T, ConferenceFindUniqueArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceFindUniqueOrThrowArgs} args - Arguments to find a Conference
     * @example
     * // Get one Conference
     * const conference = await prisma.conference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFindFirstArgs} args - Arguments to find a Conference
     * @example
     * // Get one Conference
     * const conference = await prisma.conference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceFindFirstArgs>(args?: SelectSubset<T, ConferenceFindFirstArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFindFirstOrThrowArgs} args - Arguments to find a Conference
     * @example
     * // Get one Conference
     * const conference = await prisma.conference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conferences
     * const conferences = await prisma.conference.findMany()
     * 
     * // Get first 10 Conferences
     * const conferences = await prisma.conference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceWithIdOnly = await prisma.conference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceFindManyArgs>(args?: SelectSubset<T, ConferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conference.
     * @param {ConferenceCreateArgs} args - Arguments to create a Conference.
     * @example
     * // Create one Conference
     * const Conference = await prisma.conference.create({
     *   data: {
     *     // ... data to create a Conference
     *   }
     * })
     * 
     */
    create<T extends ConferenceCreateArgs>(args: SelectSubset<T, ConferenceCreateArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conferences.
     * @param {ConferenceCreateManyArgs} args - Arguments to create many Conferences.
     * @example
     * // Create many Conferences
     * const conference = await prisma.conference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceCreateManyArgs>(args?: SelectSubset<T, ConferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conferences and returns the data saved in the database.
     * @param {ConferenceCreateManyAndReturnArgs} args - Arguments to create many Conferences.
     * @example
     * // Create many Conferences
     * const conference = await prisma.conference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conferences and only return the `id`
     * const conferenceWithIdOnly = await prisma.conference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conference.
     * @param {ConferenceDeleteArgs} args - Arguments to delete one Conference.
     * @example
     * // Delete one Conference
     * const Conference = await prisma.conference.delete({
     *   where: {
     *     // ... filter to delete one Conference
     *   }
     * })
     * 
     */
    delete<T extends ConferenceDeleteArgs>(args: SelectSubset<T, ConferenceDeleteArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conference.
     * @param {ConferenceUpdateArgs} args - Arguments to update one Conference.
     * @example
     * // Update one Conference
     * const conference = await prisma.conference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceUpdateArgs>(args: SelectSubset<T, ConferenceUpdateArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conferences.
     * @param {ConferenceDeleteManyArgs} args - Arguments to filter Conferences to delete.
     * @example
     * // Delete a few Conferences
     * const { count } = await prisma.conference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceDeleteManyArgs>(args?: SelectSubset<T, ConferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conferences
     * const conference = await prisma.conference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceUpdateManyArgs>(args: SelectSubset<T, ConferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferences and returns the data updated in the database.
     * @param {ConferenceUpdateManyAndReturnArgs} args - Arguments to update many Conferences.
     * @example
     * // Update many Conferences
     * const conference = await prisma.conference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conferences and only return the `id`
     * const conferenceWithIdOnly = await prisma.conference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conference.
     * @param {ConferenceUpsertArgs} args - Arguments to update or create a Conference.
     * @example
     * // Update or create a Conference
     * const conference = await prisma.conference.upsert({
     *   create: {
     *     // ... data to create a Conference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conference we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceUpsertArgs>(args: SelectSubset<T, ConferenceUpsertArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCountArgs} args - Arguments to filter Conferences to count.
     * @example
     * // Count the number of Conferences
     * const count = await prisma.conference.count({
     *   where: {
     *     // ... the filter for the Conferences we want to count
     *   }
     * })
    **/
    count<T extends ConferenceCountArgs>(
      args?: Subset<T, ConferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceAggregateArgs>(args: Subset<T, ConferenceAggregateArgs>): Prisma.PrismaPromise<GetConferenceAggregateType<T>>

    /**
     * Group by Conference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conference model
   */
  readonly fields: ConferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Conference$membersArgs<ExtArgs> = {}>(args?: Subset<T, Conference$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    days<T extends Conference$daysArgs<ExtArgs> = {}>(args?: Subset<T, Conference$daysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends Conference$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Conference$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Conference$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Conference$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presentationTypes<T extends Conference$presentationTypesArgs<ExtArgs> = {}>(args?: Subset<T, Conference$presentationTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissionSettings<T extends Conference$submissionSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Conference$submissionSettingsArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    abstractSubmissions<T extends Conference$abstractSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Conference$abstractSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presentations<T extends Conference$presentationsArgs<ExtArgs> = {}>(args?: Subset<T, Conference$presentationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedback<T extends Conference$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Conference$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conference model
   */
  interface ConferenceFieldRefs {
    readonly id: FieldRef<"Conference", 'Int'>
    readonly name: FieldRef<"Conference", 'String'>
    readonly description: FieldRef<"Conference", 'String'>
    readonly startDate: FieldRef<"Conference", 'DateTime'>
    readonly endDate: FieldRef<"Conference", 'DateTime'>
    readonly location: FieldRef<"Conference", 'String'>
    readonly status: FieldRef<"Conference", 'ConferenceStatus'>
    readonly topics: FieldRef<"Conference", 'String[]'>
    readonly createdById: FieldRef<"Conference", 'Int'>
    readonly createdAt: FieldRef<"Conference", 'DateTime'>
    readonly updatedAt: FieldRef<"Conference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conference findUnique
   */
  export type ConferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * Filter, which Conference to fetch.
     */
    where: ConferenceWhereUniqueInput
  }

  /**
   * Conference findUniqueOrThrow
   */
  export type ConferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * Filter, which Conference to fetch.
     */
    where: ConferenceWhereUniqueInput
  }

  /**
   * Conference findFirst
   */
  export type ConferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * Filter, which Conference to fetch.
     */
    where?: ConferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferenceOrderByWithRelationInput | ConferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferences.
     */
    cursor?: ConferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferences.
     */
    distinct?: ConferenceScalarFieldEnum | ConferenceScalarFieldEnum[]
  }

  /**
   * Conference findFirstOrThrow
   */
  export type ConferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * Filter, which Conference to fetch.
     */
    where?: ConferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferenceOrderByWithRelationInput | ConferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferences.
     */
    cursor?: ConferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferences.
     */
    distinct?: ConferenceScalarFieldEnum | ConferenceScalarFieldEnum[]
  }

  /**
   * Conference findMany
   */
  export type ConferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferenceOrderByWithRelationInput | ConferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conferences.
     */
    cursor?: ConferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    distinct?: ConferenceScalarFieldEnum | ConferenceScalarFieldEnum[]
  }

  /**
   * Conference create
   */
  export type ConferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Conference.
     */
    data: XOR<ConferenceCreateInput, ConferenceUncheckedCreateInput>
  }

  /**
   * Conference createMany
   */
  export type ConferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conferences.
     */
    data: ConferenceCreateManyInput | ConferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conference createManyAndReturn
   */
  export type ConferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * The data used to create many Conferences.
     */
    data: ConferenceCreateManyInput | ConferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conference update
   */
  export type ConferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Conference.
     */
    data: XOR<ConferenceUpdateInput, ConferenceUncheckedUpdateInput>
    /**
     * Choose, which Conference to update.
     */
    where: ConferenceWhereUniqueInput
  }

  /**
   * Conference updateMany
   */
  export type ConferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conferences.
     */
    data: XOR<ConferenceUpdateManyMutationInput, ConferenceUncheckedUpdateManyInput>
    /**
     * Filter which Conferences to update
     */
    where?: ConferenceWhereInput
    /**
     * Limit how many Conferences to update.
     */
    limit?: number
  }

  /**
   * Conference updateManyAndReturn
   */
  export type ConferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * The data used to update Conferences.
     */
    data: XOR<ConferenceUpdateManyMutationInput, ConferenceUncheckedUpdateManyInput>
    /**
     * Filter which Conferences to update
     */
    where?: ConferenceWhereInput
    /**
     * Limit how many Conferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conference upsert
   */
  export type ConferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Conference to update in case it exists.
     */
    where: ConferenceWhereUniqueInput
    /**
     * In case the Conference found by the `where` argument doesn't exist, create a new Conference with this data.
     */
    create: XOR<ConferenceCreateInput, ConferenceUncheckedCreateInput>
    /**
     * In case the Conference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceUpdateInput, ConferenceUncheckedUpdateInput>
  }

  /**
   * Conference delete
   */
  export type ConferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
    /**
     * Filter which Conference to delete.
     */
    where: ConferenceWhereUniqueInput
  }

  /**
   * Conference deleteMany
   */
  export type ConferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferences to delete
     */
    where?: ConferenceWhereInput
    /**
     * Limit how many Conferences to delete.
     */
    limit?: number
  }

  /**
   * Conference.members
   */
  export type Conference$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    where?: ConferenceMemberWhereInput
    orderBy?: ConferenceMemberOrderByWithRelationInput | ConferenceMemberOrderByWithRelationInput[]
    cursor?: ConferenceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceMemberScalarFieldEnum | ConferenceMemberScalarFieldEnum[]
  }

  /**
   * Conference.days
   */
  export type Conference$daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    where?: DayWhereInput
    orderBy?: DayOrderByWithRelationInput | DayOrderByWithRelationInput[]
    cursor?: DayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DayScalarFieldEnum | DayScalarFieldEnum[]
  }

  /**
   * Conference.sections
   */
  export type Conference$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Conference.categories
   */
  export type Conference$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Conference.presentationTypes
   */
  export type Conference$presentationTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    where?: PresentationTypeWhereInput
    orderBy?: PresentationTypeOrderByWithRelationInput | PresentationTypeOrderByWithRelationInput[]
    cursor?: PresentationTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationTypeScalarFieldEnum | PresentationTypeScalarFieldEnum[]
  }

  /**
   * Conference.submissionSettings
   */
  export type Conference$submissionSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    where?: SubmissionSettingsWhereInput
  }

  /**
   * Conference.abstractSubmissions
   */
  export type Conference$abstractSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    where?: AbstractSubmissionWhereInput
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    cursor?: AbstractSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbstractSubmissionScalarFieldEnum | AbstractSubmissionScalarFieldEnum[]
  }

  /**
   * Conference.presentations
   */
  export type Conference$presentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    where?: PresentationWhereInput
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    cursor?: PresentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * Conference.feedback
   */
  export type Conference$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    where?: ConferenceFeedbackWhereInput
    orderBy?: ConferenceFeedbackOrderByWithRelationInput | ConferenceFeedbackOrderByWithRelationInput[]
    cursor?: ConferenceFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFeedbackScalarFieldEnum | ConferenceFeedbackScalarFieldEnum[]
  }

  /**
   * Conference without action
   */
  export type ConferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference
     */
    select?: ConferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conference
     */
    omit?: ConferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceMember
   */

  export type AggregateConferenceMember = {
    _count: ConferenceMemberCountAggregateOutputType | null
    _avg: ConferenceMemberAvgAggregateOutputType | null
    _sum: ConferenceMemberSumAggregateOutputType | null
    _min: ConferenceMemberMinAggregateOutputType | null
    _max: ConferenceMemberMaxAggregateOutputType | null
  }

  export type ConferenceMemberAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
  }

  export type ConferenceMemberSumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
  }

  export type ConferenceMemberMinAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
    isAttendee: boolean | null
    isSpeaker: boolean | null
    registeredAt: Date | null
  }

  export type ConferenceMemberMaxAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
    isAttendee: boolean | null
    isSpeaker: boolean | null
    registeredAt: Date | null
  }

  export type ConferenceMemberCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    isAttendee: number
    isSpeaker: number
    registeredAt: number
    _all: number
  }


  export type ConferenceMemberAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
  }

  export type ConferenceMemberSumAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
  }

  export type ConferenceMemberMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    isAttendee?: true
    isSpeaker?: true
    registeredAt?: true
  }

  export type ConferenceMemberMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    isAttendee?: true
    isSpeaker?: true
    registeredAt?: true
  }

  export type ConferenceMemberCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    isAttendee?: true
    isSpeaker?: true
    registeredAt?: true
    _all?: true
  }

  export type ConferenceMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceMember to aggregate.
     */
    where?: ConferenceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceMembers to fetch.
     */
    orderBy?: ConferenceMemberOrderByWithRelationInput | ConferenceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceMembers
    **/
    _count?: true | ConferenceMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceMemberMaxAggregateInputType
  }

  export type GetConferenceMemberAggregateType<T extends ConferenceMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceMember[P]>
      : GetScalarType<T[P], AggregateConferenceMember[P]>
  }




  export type ConferenceMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceMemberWhereInput
    orderBy?: ConferenceMemberOrderByWithAggregationInput | ConferenceMemberOrderByWithAggregationInput[]
    by: ConferenceMemberScalarFieldEnum[] | ConferenceMemberScalarFieldEnum
    having?: ConferenceMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceMemberCountAggregateInputType | true
    _avg?: ConferenceMemberAvgAggregateInputType
    _sum?: ConferenceMemberSumAggregateInputType
    _min?: ConferenceMemberMinAggregateInputType
    _max?: ConferenceMemberMaxAggregateInputType
  }

  export type ConferenceMemberGroupByOutputType = {
    id: number
    conferenceId: number
    userId: number
    isAttendee: boolean
    isSpeaker: boolean
    registeredAt: Date
    _count: ConferenceMemberCountAggregateOutputType | null
    _avg: ConferenceMemberAvgAggregateOutputType | null
    _sum: ConferenceMemberSumAggregateOutputType | null
    _min: ConferenceMemberMinAggregateOutputType | null
    _max: ConferenceMemberMaxAggregateOutputType | null
  }

  type GetConferenceMemberGroupByPayload<T extends ConferenceMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceMemberGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceMember"]>

  export type ConferenceMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceMember"]>

  export type ConferenceMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceMember"]>

  export type ConferenceMemberSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: boolean
  }

  export type ConferenceMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "isAttendee" | "isSpeaker" | "registeredAt", ExtArgs["result"]["conferenceMember"]>
  export type ConferenceMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConferenceMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConferenceMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConferenceMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceMember"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conferenceId: number
      userId: number
      isAttendee: boolean
      isSpeaker: boolean
      registeredAt: Date
    }, ExtArgs["result"]["conferenceMember"]>
    composites: {}
  }

  type ConferenceMemberGetPayload<S extends boolean | null | undefined | ConferenceMemberDefaultArgs> = $Result.GetResult<Prisma.$ConferenceMemberPayload, S>

  type ConferenceMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceMemberCountAggregateInputType | true
    }

  export interface ConferenceMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceMember'], meta: { name: 'ConferenceMember' } }
    /**
     * Find zero or one ConferenceMember that matches the filter.
     * @param {ConferenceMemberFindUniqueArgs} args - Arguments to find a ConferenceMember
     * @example
     * // Get one ConferenceMember
     * const conferenceMember = await prisma.conferenceMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceMemberFindUniqueArgs>(args: SelectSubset<T, ConferenceMemberFindUniqueArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceMemberFindUniqueOrThrowArgs} args - Arguments to find a ConferenceMember
     * @example
     * // Get one ConferenceMember
     * const conferenceMember = await prisma.conferenceMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberFindFirstArgs} args - Arguments to find a ConferenceMember
     * @example
     * // Get one ConferenceMember
     * const conferenceMember = await prisma.conferenceMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceMemberFindFirstArgs>(args?: SelectSubset<T, ConferenceMemberFindFirstArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberFindFirstOrThrowArgs} args - Arguments to find a ConferenceMember
     * @example
     * // Get one ConferenceMember
     * const conferenceMember = await prisma.conferenceMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceMembers
     * const conferenceMembers = await prisma.conferenceMember.findMany()
     * 
     * // Get first 10 ConferenceMembers
     * const conferenceMembers = await prisma.conferenceMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceMemberWithIdOnly = await prisma.conferenceMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceMemberFindManyArgs>(args?: SelectSubset<T, ConferenceMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceMember.
     * @param {ConferenceMemberCreateArgs} args - Arguments to create a ConferenceMember.
     * @example
     * // Create one ConferenceMember
     * const ConferenceMember = await prisma.conferenceMember.create({
     *   data: {
     *     // ... data to create a ConferenceMember
     *   }
     * })
     * 
     */
    create<T extends ConferenceMemberCreateArgs>(args: SelectSubset<T, ConferenceMemberCreateArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceMembers.
     * @param {ConferenceMemberCreateManyArgs} args - Arguments to create many ConferenceMembers.
     * @example
     * // Create many ConferenceMembers
     * const conferenceMember = await prisma.conferenceMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceMemberCreateManyArgs>(args?: SelectSubset<T, ConferenceMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceMembers and returns the data saved in the database.
     * @param {ConferenceMemberCreateManyAndReturnArgs} args - Arguments to create many ConferenceMembers.
     * @example
     * // Create many ConferenceMembers
     * const conferenceMember = await prisma.conferenceMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceMembers and only return the `id`
     * const conferenceMemberWithIdOnly = await prisma.conferenceMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceMember.
     * @param {ConferenceMemberDeleteArgs} args - Arguments to delete one ConferenceMember.
     * @example
     * // Delete one ConferenceMember
     * const ConferenceMember = await prisma.conferenceMember.delete({
     *   where: {
     *     // ... filter to delete one ConferenceMember
     *   }
     * })
     * 
     */
    delete<T extends ConferenceMemberDeleteArgs>(args: SelectSubset<T, ConferenceMemberDeleteArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceMember.
     * @param {ConferenceMemberUpdateArgs} args - Arguments to update one ConferenceMember.
     * @example
     * // Update one ConferenceMember
     * const conferenceMember = await prisma.conferenceMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceMemberUpdateArgs>(args: SelectSubset<T, ConferenceMemberUpdateArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceMembers.
     * @param {ConferenceMemberDeleteManyArgs} args - Arguments to filter ConferenceMembers to delete.
     * @example
     * // Delete a few ConferenceMembers
     * const { count } = await prisma.conferenceMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceMemberDeleteManyArgs>(args?: SelectSubset<T, ConferenceMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceMembers
     * const conferenceMember = await prisma.conferenceMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceMemberUpdateManyArgs>(args: SelectSubset<T, ConferenceMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceMembers and returns the data updated in the database.
     * @param {ConferenceMemberUpdateManyAndReturnArgs} args - Arguments to update many ConferenceMembers.
     * @example
     * // Update many ConferenceMembers
     * const conferenceMember = await prisma.conferenceMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceMembers and only return the `id`
     * const conferenceMemberWithIdOnly = await prisma.conferenceMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceMember.
     * @param {ConferenceMemberUpsertArgs} args - Arguments to update or create a ConferenceMember.
     * @example
     * // Update or create a ConferenceMember
     * const conferenceMember = await prisma.conferenceMember.upsert({
     *   create: {
     *     // ... data to create a ConferenceMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceMember we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceMemberUpsertArgs>(args: SelectSubset<T, ConferenceMemberUpsertArgs<ExtArgs>>): Prisma__ConferenceMemberClient<$Result.GetResult<Prisma.$ConferenceMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberCountArgs} args - Arguments to filter ConferenceMembers to count.
     * @example
     * // Count the number of ConferenceMembers
     * const count = await prisma.conferenceMember.count({
     *   where: {
     *     // ... the filter for the ConferenceMembers we want to count
     *   }
     * })
    **/
    count<T extends ConferenceMemberCountArgs>(
      args?: Subset<T, ConferenceMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceMemberAggregateArgs>(args: Subset<T, ConferenceMemberAggregateArgs>): Prisma.PrismaPromise<GetConferenceMemberAggregateType<T>>

    /**
     * Group by ConferenceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceMemberGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceMember model
   */
  readonly fields: ConferenceMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceMember model
   */
  interface ConferenceMemberFieldRefs {
    readonly id: FieldRef<"ConferenceMember", 'Int'>
    readonly conferenceId: FieldRef<"ConferenceMember", 'Int'>
    readonly userId: FieldRef<"ConferenceMember", 'Int'>
    readonly isAttendee: FieldRef<"ConferenceMember", 'Boolean'>
    readonly isSpeaker: FieldRef<"ConferenceMember", 'Boolean'>
    readonly registeredAt: FieldRef<"ConferenceMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceMember findUnique
   */
  export type ConferenceMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceMember to fetch.
     */
    where: ConferenceMemberWhereUniqueInput
  }

  /**
   * ConferenceMember findUniqueOrThrow
   */
  export type ConferenceMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceMember to fetch.
     */
    where: ConferenceMemberWhereUniqueInput
  }

  /**
   * ConferenceMember findFirst
   */
  export type ConferenceMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceMember to fetch.
     */
    where?: ConferenceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceMembers to fetch.
     */
    orderBy?: ConferenceMemberOrderByWithRelationInput | ConferenceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceMembers.
     */
    cursor?: ConferenceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceMembers.
     */
    distinct?: ConferenceMemberScalarFieldEnum | ConferenceMemberScalarFieldEnum[]
  }

  /**
   * ConferenceMember findFirstOrThrow
   */
  export type ConferenceMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceMember to fetch.
     */
    where?: ConferenceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceMembers to fetch.
     */
    orderBy?: ConferenceMemberOrderByWithRelationInput | ConferenceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceMembers.
     */
    cursor?: ConferenceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceMembers.
     */
    distinct?: ConferenceMemberScalarFieldEnum | ConferenceMemberScalarFieldEnum[]
  }

  /**
   * ConferenceMember findMany
   */
  export type ConferenceMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceMembers to fetch.
     */
    where?: ConferenceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceMembers to fetch.
     */
    orderBy?: ConferenceMemberOrderByWithRelationInput | ConferenceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceMembers.
     */
    cursor?: ConferenceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceMembers.
     */
    skip?: number
    distinct?: ConferenceMemberScalarFieldEnum | ConferenceMemberScalarFieldEnum[]
  }

  /**
   * ConferenceMember create
   */
  export type ConferenceMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceMember.
     */
    data: XOR<ConferenceMemberCreateInput, ConferenceMemberUncheckedCreateInput>
  }

  /**
   * ConferenceMember createMany
   */
  export type ConferenceMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceMembers.
     */
    data: ConferenceMemberCreateManyInput | ConferenceMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceMember createManyAndReturn
   */
  export type ConferenceMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceMembers.
     */
    data: ConferenceMemberCreateManyInput | ConferenceMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceMember update
   */
  export type ConferenceMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceMember.
     */
    data: XOR<ConferenceMemberUpdateInput, ConferenceMemberUncheckedUpdateInput>
    /**
     * Choose, which ConferenceMember to update.
     */
    where: ConferenceMemberWhereUniqueInput
  }

  /**
   * ConferenceMember updateMany
   */
  export type ConferenceMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceMembers.
     */
    data: XOR<ConferenceMemberUpdateManyMutationInput, ConferenceMemberUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceMembers to update
     */
    where?: ConferenceMemberWhereInput
    /**
     * Limit how many ConferenceMembers to update.
     */
    limit?: number
  }

  /**
   * ConferenceMember updateManyAndReturn
   */
  export type ConferenceMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceMembers.
     */
    data: XOR<ConferenceMemberUpdateManyMutationInput, ConferenceMemberUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceMembers to update
     */
    where?: ConferenceMemberWhereInput
    /**
     * Limit how many ConferenceMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceMember upsert
   */
  export type ConferenceMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceMember to update in case it exists.
     */
    where: ConferenceMemberWhereUniqueInput
    /**
     * In case the ConferenceMember found by the `where` argument doesn't exist, create a new ConferenceMember with this data.
     */
    create: XOR<ConferenceMemberCreateInput, ConferenceMemberUncheckedCreateInput>
    /**
     * In case the ConferenceMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceMemberUpdateInput, ConferenceMemberUncheckedUpdateInput>
  }

  /**
   * ConferenceMember delete
   */
  export type ConferenceMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
    /**
     * Filter which ConferenceMember to delete.
     */
    where: ConferenceMemberWhereUniqueInput
  }

  /**
   * ConferenceMember deleteMany
   */
  export type ConferenceMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceMembers to delete
     */
    where?: ConferenceMemberWhereInput
    /**
     * Limit how many ConferenceMembers to delete.
     */
    limit?: number
  }

  /**
   * ConferenceMember without action
   */
  export type ConferenceMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceMember
     */
    select?: ConferenceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceMember
     */
    omit?: ConferenceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceMemberInclude<ExtArgs> | null
  }


  /**
   * Model Day
   */

  export type AggregateDay = {
    _count: DayCountAggregateOutputType | null
    _avg: DayAvgAggregateOutputType | null
    _sum: DaySumAggregateOutputType | null
    _min: DayMinAggregateOutputType | null
    _max: DayMaxAggregateOutputType | null
  }

  export type DayAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    order: number | null
  }

  export type DaySumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    order: number | null
  }

  export type DayMinAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    date: Date | null
    name: string | null
    order: number | null
  }

  export type DayMaxAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    date: Date | null
    name: string | null
    order: number | null
  }

  export type DayCountAggregateOutputType = {
    id: number
    conferenceId: number
    date: number
    name: number
    order: number
    _all: number
  }


  export type DayAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    order?: true
  }

  export type DaySumAggregateInputType = {
    id?: true
    conferenceId?: true
    order?: true
  }

  export type DayMinAggregateInputType = {
    id?: true
    conferenceId?: true
    date?: true
    name?: true
    order?: true
  }

  export type DayMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    date?: true
    name?: true
    order?: true
  }

  export type DayCountAggregateInputType = {
    id?: true
    conferenceId?: true
    date?: true
    name?: true
    order?: true
    _all?: true
  }

  export type DayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Day to aggregate.
     */
    where?: DayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Days to fetch.
     */
    orderBy?: DayOrderByWithRelationInput | DayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Days
    **/
    _count?: true | DayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DayMaxAggregateInputType
  }

  export type GetDayAggregateType<T extends DayAggregateArgs> = {
        [P in keyof T & keyof AggregateDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDay[P]>
      : GetScalarType<T[P], AggregateDay[P]>
  }




  export type DayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayWhereInput
    orderBy?: DayOrderByWithAggregationInput | DayOrderByWithAggregationInput[]
    by: DayScalarFieldEnum[] | DayScalarFieldEnum
    having?: DayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DayCountAggregateInputType | true
    _avg?: DayAvgAggregateInputType
    _sum?: DaySumAggregateInputType
    _min?: DayMinAggregateInputType
    _max?: DayMaxAggregateInputType
  }

  export type DayGroupByOutputType = {
    id: number
    conferenceId: number
    date: Date
    name: string
    order: number
    _count: DayCountAggregateOutputType | null
    _avg: DayAvgAggregateOutputType | null
    _sum: DaySumAggregateOutputType | null
    _min: DayMinAggregateOutputType | null
    _max: DayMaxAggregateOutputType | null
  }

  type GetDayGroupByPayload<T extends DayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DayGroupByOutputType[P]>
            : GetScalarType<T[P], DayGroupByOutputType[P]>
        }
      >
    >


  export type DaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    date?: boolean
    name?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    sections?: boolean | Day$sectionsArgs<ExtArgs>
    _count?: boolean | DayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["day"]>

  export type DaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    date?: boolean
    name?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["day"]>

  export type DaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    date?: boolean
    name?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["day"]>

  export type DaySelectScalar = {
    id?: boolean
    conferenceId?: boolean
    date?: boolean
    name?: boolean
    order?: boolean
  }

  export type DayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "date" | "name" | "order", ExtArgs["result"]["day"]>
  export type DayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    sections?: boolean | Day$sectionsArgs<ExtArgs>
    _count?: boolean | DayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }
  export type DayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }

  export type $DayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Day"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      sections: Prisma.$SectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conferenceId: number
      date: Date
      name: string
      order: number
    }, ExtArgs["result"]["day"]>
    composites: {}
  }

  type DayGetPayload<S extends boolean | null | undefined | DayDefaultArgs> = $Result.GetResult<Prisma.$DayPayload, S>

  type DayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DayCountAggregateInputType | true
    }

  export interface DayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Day'], meta: { name: 'Day' } }
    /**
     * Find zero or one Day that matches the filter.
     * @param {DayFindUniqueArgs} args - Arguments to find a Day
     * @example
     * // Get one Day
     * const day = await prisma.day.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DayFindUniqueArgs>(args: SelectSubset<T, DayFindUniqueArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Day that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DayFindUniqueOrThrowArgs} args - Arguments to find a Day
     * @example
     * // Get one Day
     * const day = await prisma.day.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DayFindUniqueOrThrowArgs>(args: SelectSubset<T, DayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Day that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFindFirstArgs} args - Arguments to find a Day
     * @example
     * // Get one Day
     * const day = await prisma.day.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DayFindFirstArgs>(args?: SelectSubset<T, DayFindFirstArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Day that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFindFirstOrThrowArgs} args - Arguments to find a Day
     * @example
     * // Get one Day
     * const day = await prisma.day.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DayFindFirstOrThrowArgs>(args?: SelectSubset<T, DayFindFirstOrThrowArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Days that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Days
     * const days = await prisma.day.findMany()
     * 
     * // Get first 10 Days
     * const days = await prisma.day.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dayWithIdOnly = await prisma.day.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DayFindManyArgs>(args?: SelectSubset<T, DayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Day.
     * @param {DayCreateArgs} args - Arguments to create a Day.
     * @example
     * // Create one Day
     * const Day = await prisma.day.create({
     *   data: {
     *     // ... data to create a Day
     *   }
     * })
     * 
     */
    create<T extends DayCreateArgs>(args: SelectSubset<T, DayCreateArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Days.
     * @param {DayCreateManyArgs} args - Arguments to create many Days.
     * @example
     * // Create many Days
     * const day = await prisma.day.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DayCreateManyArgs>(args?: SelectSubset<T, DayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Days and returns the data saved in the database.
     * @param {DayCreateManyAndReturnArgs} args - Arguments to create many Days.
     * @example
     * // Create many Days
     * const day = await prisma.day.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Days and only return the `id`
     * const dayWithIdOnly = await prisma.day.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DayCreateManyAndReturnArgs>(args?: SelectSubset<T, DayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Day.
     * @param {DayDeleteArgs} args - Arguments to delete one Day.
     * @example
     * // Delete one Day
     * const Day = await prisma.day.delete({
     *   where: {
     *     // ... filter to delete one Day
     *   }
     * })
     * 
     */
    delete<T extends DayDeleteArgs>(args: SelectSubset<T, DayDeleteArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Day.
     * @param {DayUpdateArgs} args - Arguments to update one Day.
     * @example
     * // Update one Day
     * const day = await prisma.day.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DayUpdateArgs>(args: SelectSubset<T, DayUpdateArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Days.
     * @param {DayDeleteManyArgs} args - Arguments to filter Days to delete.
     * @example
     * // Delete a few Days
     * const { count } = await prisma.day.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DayDeleteManyArgs>(args?: SelectSubset<T, DayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Days
     * const day = await prisma.day.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DayUpdateManyArgs>(args: SelectSubset<T, DayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Days and returns the data updated in the database.
     * @param {DayUpdateManyAndReturnArgs} args - Arguments to update many Days.
     * @example
     * // Update many Days
     * const day = await prisma.day.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Days and only return the `id`
     * const dayWithIdOnly = await prisma.day.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DayUpdateManyAndReturnArgs>(args: SelectSubset<T, DayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Day.
     * @param {DayUpsertArgs} args - Arguments to update or create a Day.
     * @example
     * // Update or create a Day
     * const day = await prisma.day.upsert({
     *   create: {
     *     // ... data to create a Day
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Day we want to update
     *   }
     * })
     */
    upsert<T extends DayUpsertArgs>(args: SelectSubset<T, DayUpsertArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayCountArgs} args - Arguments to filter Days to count.
     * @example
     * // Count the number of Days
     * const count = await prisma.day.count({
     *   where: {
     *     // ... the filter for the Days we want to count
     *   }
     * })
    **/
    count<T extends DayCountArgs>(
      args?: Subset<T, DayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Day.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DayAggregateArgs>(args: Subset<T, DayAggregateArgs>): Prisma.PrismaPromise<GetDayAggregateType<T>>

    /**
     * Group by Day.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DayGroupByArgs['orderBy'] }
        : { orderBy?: DayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Day model
   */
  readonly fields: DayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Day.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sections<T extends Day$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Day$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Day model
   */
  interface DayFieldRefs {
    readonly id: FieldRef<"Day", 'Int'>
    readonly conferenceId: FieldRef<"Day", 'Int'>
    readonly date: FieldRef<"Day", 'DateTime'>
    readonly name: FieldRef<"Day", 'String'>
    readonly order: FieldRef<"Day", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Day findUnique
   */
  export type DayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * Filter, which Day to fetch.
     */
    where: DayWhereUniqueInput
  }

  /**
   * Day findUniqueOrThrow
   */
  export type DayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * Filter, which Day to fetch.
     */
    where: DayWhereUniqueInput
  }

  /**
   * Day findFirst
   */
  export type DayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * Filter, which Day to fetch.
     */
    where?: DayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Days to fetch.
     */
    orderBy?: DayOrderByWithRelationInput | DayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Days.
     */
    cursor?: DayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Days.
     */
    distinct?: DayScalarFieldEnum | DayScalarFieldEnum[]
  }

  /**
   * Day findFirstOrThrow
   */
  export type DayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * Filter, which Day to fetch.
     */
    where?: DayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Days to fetch.
     */
    orderBy?: DayOrderByWithRelationInput | DayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Days.
     */
    cursor?: DayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Days.
     */
    distinct?: DayScalarFieldEnum | DayScalarFieldEnum[]
  }

  /**
   * Day findMany
   */
  export type DayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * Filter, which Days to fetch.
     */
    where?: DayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Days to fetch.
     */
    orderBy?: DayOrderByWithRelationInput | DayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Days.
     */
    cursor?: DayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Days.
     */
    skip?: number
    distinct?: DayScalarFieldEnum | DayScalarFieldEnum[]
  }

  /**
   * Day create
   */
  export type DayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * The data needed to create a Day.
     */
    data: XOR<DayCreateInput, DayUncheckedCreateInput>
  }

  /**
   * Day createMany
   */
  export type DayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Days.
     */
    data: DayCreateManyInput | DayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Day createManyAndReturn
   */
  export type DayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * The data used to create many Days.
     */
    data: DayCreateManyInput | DayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Day update
   */
  export type DayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * The data needed to update a Day.
     */
    data: XOR<DayUpdateInput, DayUncheckedUpdateInput>
    /**
     * Choose, which Day to update.
     */
    where: DayWhereUniqueInput
  }

  /**
   * Day updateMany
   */
  export type DayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Days.
     */
    data: XOR<DayUpdateManyMutationInput, DayUncheckedUpdateManyInput>
    /**
     * Filter which Days to update
     */
    where?: DayWhereInput
    /**
     * Limit how many Days to update.
     */
    limit?: number
  }

  /**
   * Day updateManyAndReturn
   */
  export type DayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * The data used to update Days.
     */
    data: XOR<DayUpdateManyMutationInput, DayUncheckedUpdateManyInput>
    /**
     * Filter which Days to update
     */
    where?: DayWhereInput
    /**
     * Limit how many Days to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Day upsert
   */
  export type DayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * The filter to search for the Day to update in case it exists.
     */
    where: DayWhereUniqueInput
    /**
     * In case the Day found by the `where` argument doesn't exist, create a new Day with this data.
     */
    create: XOR<DayCreateInput, DayUncheckedCreateInput>
    /**
     * In case the Day was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DayUpdateInput, DayUncheckedUpdateInput>
  }

  /**
   * Day delete
   */
  export type DayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    /**
     * Filter which Day to delete.
     */
    where: DayWhereUniqueInput
  }

  /**
   * Day deleteMany
   */
  export type DayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Days to delete
     */
    where?: DayWhereInput
    /**
     * Limit how many Days to delete.
     */
    limit?: number
  }

  /**
   * Day.sections
   */
  export type Day$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Day without action
   */
  export type DayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    dayId: number | null
    categoryId: number | null
    capacity: number | null
  }

  export type SectionSumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    dayId: number | null
    categoryId: number | null
    capacity: number | null
  }

  export type SectionMinAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    conferenceId: number | null
    dayId: number | null
    type: $Enums.SectionType | null
    categoryId: number | null
    room: string | null
    capacity: number | null
    description: string | null
  }

  export type SectionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    conferenceId: number | null
    dayId: number | null
    type: $Enums.SectionType | null
    categoryId: number | null
    room: string | null
    capacity: number | null
    description: string | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    conferenceId: number
    dayId: number
    type: number
    categoryId: number
    room: number
    capacity: number
    description: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    dayId?: true
    categoryId?: true
    capacity?: true
  }

  export type SectionSumAggregateInputType = {
    id?: true
    conferenceId?: true
    dayId?: true
    categoryId?: true
    capacity?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    conferenceId?: true
    dayId?: true
    type?: true
    categoryId?: true
    room?: true
    capacity?: true
    description?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    conferenceId?: true
    dayId?: true
    type?: true
    categoryId?: true
    room?: true
    capacity?: true
    description?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    conferenceId?: true
    dayId?: true
    type?: true
    categoryId?: true
    room?: true
    capacity?: true
    description?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: number
    name: string
    startTime: Date | null
    endTime: Date | null
    conferenceId: number
    dayId: number | null
    type: $Enums.SectionType
    categoryId: number | null
    room: string | null
    capacity: number | null
    description: string | null
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    conferenceId?: boolean
    dayId?: boolean
    type?: boolean
    categoryId?: boolean
    room?: boolean
    capacity?: boolean
    description?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    day?: boolean | Section$dayArgs<ExtArgs>
    category?: boolean | Section$categoryArgs<ExtArgs>
    timeSlots?: boolean | Section$timeSlotsArgs<ExtArgs>
    presentations?: boolean | Section$presentationsArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    conferenceId?: boolean
    dayId?: boolean
    type?: boolean
    categoryId?: boolean
    room?: boolean
    capacity?: boolean
    description?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    day?: boolean | Section$dayArgs<ExtArgs>
    category?: boolean | Section$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    conferenceId?: boolean
    dayId?: boolean
    type?: boolean
    categoryId?: boolean
    room?: boolean
    capacity?: boolean
    description?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    day?: boolean | Section$dayArgs<ExtArgs>
    category?: boolean | Section$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    conferenceId?: boolean
    dayId?: boolean
    type?: boolean
    categoryId?: boolean
    room?: boolean
    capacity?: boolean
    description?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "conferenceId" | "dayId" | "type" | "categoryId" | "room" | "capacity" | "description", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    day?: boolean | Section$dayArgs<ExtArgs>
    category?: boolean | Section$categoryArgs<ExtArgs>
    timeSlots?: boolean | Section$timeSlotsArgs<ExtArgs>
    presentations?: boolean | Section$presentationsArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    day?: boolean | Section$dayArgs<ExtArgs>
    category?: boolean | Section$categoryArgs<ExtArgs>
  }
  export type SectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    day?: boolean | Section$dayArgs<ExtArgs>
    category?: boolean | Section$categoryArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      day: Prisma.$DayPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      timeSlots: Prisma.$TimeSlotPayload<ExtArgs>[]
      presentations: Prisma.$PresentationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      startTime: Date | null
      endTime: Date | null
      conferenceId: number
      dayId: number | null
      type: $Enums.SectionType
      categoryId: number | null
      room: string | null
      capacity: number | null
      description: string | null
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {SectionUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    day<T extends Section$dayArgs<ExtArgs> = {}>(args?: Subset<T, Section$dayArgs<ExtArgs>>): Prisma__DayClient<$Result.GetResult<Prisma.$DayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Section$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Section$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    timeSlots<T extends Section$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Section$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presentations<T extends Section$presentationsArgs<ExtArgs> = {}>(args?: Subset<T, Section$presentationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'Int'>
    readonly name: FieldRef<"Section", 'String'>
    readonly startTime: FieldRef<"Section", 'DateTime'>
    readonly endTime: FieldRef<"Section", 'DateTime'>
    readonly conferenceId: FieldRef<"Section", 'Int'>
    readonly dayId: FieldRef<"Section", 'Int'>
    readonly type: FieldRef<"Section", 'SectionType'>
    readonly categoryId: FieldRef<"Section", 'Int'>
    readonly room: FieldRef<"Section", 'String'>
    readonly capacity: FieldRef<"Section", 'Int'>
    readonly description: FieldRef<"Section", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section updateManyAndReturn
   */
  export type SectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.day
   */
  export type Section$dayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Day
     */
    select?: DaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Day
     */
    omit?: DayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayInclude<ExtArgs> | null
    where?: DayWhereInput
  }

  /**
   * Section.category
   */
  export type Section$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Section.timeSlots
   */
  export type Section$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    cursor?: TimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * Section.presentations
   */
  export type Section$presentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    where?: PresentationWhereInput
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    cursor?: PresentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model TimeSlot
   */

  export type AggregateTimeSlot = {
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  export type TimeSlotAvgAggregateOutputType = {
    id: number | null
    sectionId: number | null
    presentationId: number | null
  }

  export type TimeSlotSumAggregateOutputType = {
    id: number | null
    sectionId: number | null
    presentationId: number | null
  }

  export type TimeSlotMinAggregateOutputType = {
    id: number | null
    sectionId: number | null
    startTime: Date | null
    endTime: Date | null
    slotType: $Enums.SlotType | null
    isOccupied: boolean | null
    presentationId: number | null
    title: string | null
    breakType: $Enums.BreakType | null
    description: string | null
  }

  export type TimeSlotMaxAggregateOutputType = {
    id: number | null
    sectionId: number | null
    startTime: Date | null
    endTime: Date | null
    slotType: $Enums.SlotType | null
    isOccupied: boolean | null
    presentationId: number | null
    title: string | null
    breakType: $Enums.BreakType | null
    description: string | null
  }

  export type TimeSlotCountAggregateOutputType = {
    id: number
    sectionId: number
    startTime: number
    endTime: number
    slotType: number
    isOccupied: number
    presentationId: number
    title: number
    breakType: number
    description: number
    _all: number
  }


  export type TimeSlotAvgAggregateInputType = {
    id?: true
    sectionId?: true
    presentationId?: true
  }

  export type TimeSlotSumAggregateInputType = {
    id?: true
    sectionId?: true
    presentationId?: true
  }

  export type TimeSlotMinAggregateInputType = {
    id?: true
    sectionId?: true
    startTime?: true
    endTime?: true
    slotType?: true
    isOccupied?: true
    presentationId?: true
    title?: true
    breakType?: true
    description?: true
  }

  export type TimeSlotMaxAggregateInputType = {
    id?: true
    sectionId?: true
    startTime?: true
    endTime?: true
    slotType?: true
    isOccupied?: true
    presentationId?: true
    title?: true
    breakType?: true
    description?: true
  }

  export type TimeSlotCountAggregateInputType = {
    id?: true
    sectionId?: true
    startTime?: true
    endTime?: true
    slotType?: true
    isOccupied?: true
    presentationId?: true
    title?: true
    breakType?: true
    description?: true
    _all?: true
  }

  export type TimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlot to aggregate.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlots
    **/
    _count?: true | TimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSlotMaxAggregateInputType
  }

  export type GetTimeSlotAggregateType<T extends TimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlot[P]>
      : GetScalarType<T[P], AggregateTimeSlot[P]>
  }




  export type TimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithAggregationInput | TimeSlotOrderByWithAggregationInput[]
    by: TimeSlotScalarFieldEnum[] | TimeSlotScalarFieldEnum
    having?: TimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSlotCountAggregateInputType | true
    _avg?: TimeSlotAvgAggregateInputType
    _sum?: TimeSlotSumAggregateInputType
    _min?: TimeSlotMinAggregateInputType
    _max?: TimeSlotMaxAggregateInputType
  }

  export type TimeSlotGroupByOutputType = {
    id: number
    sectionId: number
    startTime: Date
    endTime: Date
    slotType: $Enums.SlotType
    isOccupied: boolean
    presentationId: number | null
    title: string | null
    breakType: $Enums.BreakType | null
    description: string | null
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  type GetTimeSlotGroupByPayload<T extends TimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type TimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    isOccupied?: boolean
    presentationId?: boolean
    title?: boolean
    breakType?: boolean
    description?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    presentation?: boolean | TimeSlot$presentationArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    isOccupied?: boolean
    presentationId?: boolean
    title?: boolean
    breakType?: boolean
    description?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    presentation?: boolean | TimeSlot$presentationArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    isOccupied?: boolean
    presentationId?: boolean
    title?: boolean
    breakType?: boolean
    description?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    presentation?: boolean | TimeSlot$presentationArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectScalar = {
    id?: boolean
    sectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    isOccupied?: boolean
    presentationId?: boolean
    title?: boolean
    breakType?: boolean
    description?: boolean
  }

  export type TimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "startTime" | "endTime" | "slotType" | "isOccupied" | "presentationId" | "title" | "breakType" | "description", ExtArgs["result"]["timeSlot"]>
  export type TimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    presentation?: boolean | TimeSlot$presentationArgs<ExtArgs>
  }
  export type TimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    presentation?: boolean | TimeSlot$presentationArgs<ExtArgs>
  }
  export type TimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    presentation?: boolean | TimeSlot$presentationArgs<ExtArgs>
  }

  export type $TimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSlot"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
      presentation: Prisma.$PresentationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sectionId: number
      startTime: Date
      endTime: Date
      slotType: $Enums.SlotType
      isOccupied: boolean
      presentationId: number | null
      title: string | null
      breakType: $Enums.BreakType | null
      description: string | null
    }, ExtArgs["result"]["timeSlot"]>
    composites: {}
  }

  type TimeSlotGetPayload<S extends boolean | null | undefined | TimeSlotDefaultArgs> = $Result.GetResult<Prisma.$TimeSlotPayload, S>

  type TimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeSlotCountAggregateInputType | true
    }

  export interface TimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSlot'], meta: { name: 'TimeSlot' } }
    /**
     * Find zero or one TimeSlot that matches the filter.
     * @param {TimeSlotFindUniqueArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSlotFindUniqueArgs>(args: SelectSubset<T, TimeSlotFindUniqueArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeSlotFindUniqueOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSlotFindFirstArgs>(args?: SelectSubset<T, TimeSlotFindFirstArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany()
     * 
     * // Get first 10 TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSlotFindManyArgs>(args?: SelectSubset<T, TimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSlot.
     * @param {TimeSlotCreateArgs} args - Arguments to create a TimeSlot.
     * @example
     * // Create one TimeSlot
     * const TimeSlot = await prisma.timeSlot.create({
     *   data: {
     *     // ... data to create a TimeSlot
     *   }
     * })
     * 
     */
    create<T extends TimeSlotCreateArgs>(args: SelectSubset<T, TimeSlotCreateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSlots.
     * @param {TimeSlotCreateManyArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSlotCreateManyArgs>(args?: SelectSubset<T, TimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSlots and returns the data saved in the database.
     * @param {TimeSlotCreateManyAndReturnArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSlot.
     * @param {TimeSlotDeleteArgs} args - Arguments to delete one TimeSlot.
     * @example
     * // Delete one TimeSlot
     * const TimeSlot = await prisma.timeSlot.delete({
     *   where: {
     *     // ... filter to delete one TimeSlot
     *   }
     * })
     * 
     */
    delete<T extends TimeSlotDeleteArgs>(args: SelectSubset<T, TimeSlotDeleteArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSlot.
     * @param {TimeSlotUpdateArgs} args - Arguments to update one TimeSlot.
     * @example
     * // Update one TimeSlot
     * const timeSlot = await prisma.timeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSlotUpdateArgs>(args: SelectSubset<T, TimeSlotUpdateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSlots.
     * @param {TimeSlotDeleteManyArgs} args - Arguments to filter TimeSlots to delete.
     * @example
     * // Delete a few TimeSlots
     * const { count } = await prisma.timeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSlotDeleteManyArgs>(args?: SelectSubset<T, TimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSlotUpdateManyArgs>(args: SelectSubset<T, TimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots and returns the data updated in the database.
     * @param {TimeSlotUpdateManyAndReturnArgs} args - Arguments to update many TimeSlots.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSlot.
     * @param {TimeSlotUpsertArgs} args - Arguments to update or create a TimeSlot.
     * @example
     * // Update or create a TimeSlot
     * const timeSlot = await prisma.timeSlot.upsert({
     *   create: {
     *     // ... data to create a TimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends TimeSlotUpsertArgs>(args: SelectSubset<T, TimeSlotUpsertArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotCountArgs} args - Arguments to filter TimeSlots to count.
     * @example
     * // Count the number of TimeSlots
     * const count = await prisma.timeSlot.count({
     *   where: {
     *     // ... the filter for the TimeSlots we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotCountArgs>(
      args?: Subset<T, TimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotAggregateArgs>(args: Subset<T, TimeSlotAggregateArgs>): Prisma.PrismaPromise<GetTimeSlotAggregateType<T>>

    /**
     * Group by TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: TimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSlot model
   */
  readonly fields: TimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    presentation<T extends TimeSlot$presentationArgs<ExtArgs> = {}>(args?: Subset<T, TimeSlot$presentationArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSlot model
   */
  interface TimeSlotFieldRefs {
    readonly id: FieldRef<"TimeSlot", 'Int'>
    readonly sectionId: FieldRef<"TimeSlot", 'Int'>
    readonly startTime: FieldRef<"TimeSlot", 'DateTime'>
    readonly endTime: FieldRef<"TimeSlot", 'DateTime'>
    readonly slotType: FieldRef<"TimeSlot", 'SlotType'>
    readonly isOccupied: FieldRef<"TimeSlot", 'Boolean'>
    readonly presentationId: FieldRef<"TimeSlot", 'Int'>
    readonly title: FieldRef<"TimeSlot", 'String'>
    readonly breakType: FieldRef<"TimeSlot", 'BreakType'>
    readonly description: FieldRef<"TimeSlot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeSlot findUnique
   */
  export type TimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findUniqueOrThrow
   */
  export type TimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findFirst
   */
  export type TimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findFirstOrThrow
   */
  export type TimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findMany
   */
  export type TimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot create
   */
  export type TimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSlot.
     */
    data: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
  }

  /**
   * TimeSlot createMany
   */
  export type TimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSlot createManyAndReturn
   */
  export type TimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot update
   */
  export type TimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSlot.
     */
    data: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
    /**
     * Choose, which TimeSlot to update.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot updateMany
   */
  export type TimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
  }

  /**
   * TimeSlot updateManyAndReturn
   */
  export type TimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot upsert
   */
  export type TimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSlot to update in case it exists.
     */
    where: TimeSlotWhereUniqueInput
    /**
     * In case the TimeSlot found by the `where` argument doesn't exist, create a new TimeSlot with this data.
     */
    create: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
    /**
     * In case the TimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
  }

  /**
   * TimeSlot delete
   */
  export type TimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter which TimeSlot to delete.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot deleteMany
   */
  export type TimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to delete
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to delete.
     */
    limit?: number
  }

  /**
   * TimeSlot.presentation
   */
  export type TimeSlot$presentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    where?: PresentationWhereInput
  }

  /**
   * TimeSlot without action
   */
  export type TimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model AbstractSubmission
   */

  export type AggregateAbstractSubmission = {
    _count: AbstractSubmissionCountAggregateOutputType | null
    _avg: AbstractSubmissionAvgAggregateOutputType | null
    _sum: AbstractSubmissionSumAggregateOutputType | null
    _min: AbstractSubmissionMinAggregateOutputType | null
    _max: AbstractSubmissionMaxAggregateOutputType | null
  }

  export type AbstractSubmissionAvgAggregateOutputType = {
    id: number | null
    submitterId: number | null
    conferenceId: number | null
    presentationTypeId: number | null
  }

  export type AbstractSubmissionSumAggregateOutputType = {
    id: number | null
    submitterId: number | null
    conferenceId: number | null
    presentationTypeId: number | null
  }

  export type AbstractSubmissionMinAggregateOutputType = {
    id: number | null
    title: string | null
    abstractText: string | null
    fileUrl: string | null
    submitterId: number | null
    conferenceId: number | null
    status: $Enums.AbstractSubmissionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    presentationTypeId: number | null
  }

  export type AbstractSubmissionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    abstractText: string | null
    fileUrl: string | null
    submitterId: number | null
    conferenceId: number | null
    status: $Enums.AbstractSubmissionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    presentationTypeId: number | null
  }

  export type AbstractSubmissionCountAggregateOutputType = {
    id: number
    title: number
    abstractText: number
    fileUrl: number
    submitterId: number
    conferenceId: number
    status: number
    keywords: number
    createdAt: number
    updatedAt: number
    presentationTypeId: number
    _all: number
  }


  export type AbstractSubmissionAvgAggregateInputType = {
    id?: true
    submitterId?: true
    conferenceId?: true
    presentationTypeId?: true
  }

  export type AbstractSubmissionSumAggregateInputType = {
    id?: true
    submitterId?: true
    conferenceId?: true
    presentationTypeId?: true
  }

  export type AbstractSubmissionMinAggregateInputType = {
    id?: true
    title?: true
    abstractText?: true
    fileUrl?: true
    submitterId?: true
    conferenceId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    presentationTypeId?: true
  }

  export type AbstractSubmissionMaxAggregateInputType = {
    id?: true
    title?: true
    abstractText?: true
    fileUrl?: true
    submitterId?: true
    conferenceId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    presentationTypeId?: true
  }

  export type AbstractSubmissionCountAggregateInputType = {
    id?: true
    title?: true
    abstractText?: true
    fileUrl?: true
    submitterId?: true
    conferenceId?: true
    status?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    presentationTypeId?: true
    _all?: true
  }

  export type AbstractSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbstractSubmission to aggregate.
     */
    where?: AbstractSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractSubmissions to fetch.
     */
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbstractSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AbstractSubmissions
    **/
    _count?: true | AbstractSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbstractSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbstractSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbstractSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbstractSubmissionMaxAggregateInputType
  }

  export type GetAbstractSubmissionAggregateType<T extends AbstractSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAbstractSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbstractSubmission[P]>
      : GetScalarType<T[P], AggregateAbstractSubmission[P]>
  }




  export type AbstractSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractSubmissionWhereInput
    orderBy?: AbstractSubmissionOrderByWithAggregationInput | AbstractSubmissionOrderByWithAggregationInput[]
    by: AbstractSubmissionScalarFieldEnum[] | AbstractSubmissionScalarFieldEnum
    having?: AbstractSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbstractSubmissionCountAggregateInputType | true
    _avg?: AbstractSubmissionAvgAggregateInputType
    _sum?: AbstractSubmissionSumAggregateInputType
    _min?: AbstractSubmissionMinAggregateInputType
    _max?: AbstractSubmissionMaxAggregateInputType
  }

  export type AbstractSubmissionGroupByOutputType = {
    id: number
    title: string
    abstractText: string | null
    fileUrl: string | null
    submitterId: number
    conferenceId: number
    status: $Enums.AbstractSubmissionStatus
    keywords: string[]
    createdAt: Date
    updatedAt: Date
    presentationTypeId: number | null
    _count: AbstractSubmissionCountAggregateOutputType | null
    _avg: AbstractSubmissionAvgAggregateOutputType | null
    _sum: AbstractSubmissionSumAggregateOutputType | null
    _min: AbstractSubmissionMinAggregateOutputType | null
    _max: AbstractSubmissionMaxAggregateOutputType | null
  }

  type GetAbstractSubmissionGroupByPayload<T extends AbstractSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbstractSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbstractSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbstractSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AbstractSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type AbstractSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    abstractText?: boolean
    fileUrl?: boolean
    submitterId?: boolean
    conferenceId?: boolean
    status?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    presentationTypeId?: boolean
    submitter?: boolean | UserDefaultArgs<ExtArgs>
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    reviews?: boolean | AbstractSubmission$reviewsArgs<ExtArgs>
    presentationType?: boolean | AbstractSubmission$presentationTypeArgs<ExtArgs>
    _count?: boolean | AbstractSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abstractSubmission"]>

  export type AbstractSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    abstractText?: boolean
    fileUrl?: boolean
    submitterId?: boolean
    conferenceId?: boolean
    status?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    presentationTypeId?: boolean
    submitter?: boolean | UserDefaultArgs<ExtArgs>
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentationType?: boolean | AbstractSubmission$presentationTypeArgs<ExtArgs>
  }, ExtArgs["result"]["abstractSubmission"]>

  export type AbstractSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    abstractText?: boolean
    fileUrl?: boolean
    submitterId?: boolean
    conferenceId?: boolean
    status?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    presentationTypeId?: boolean
    submitter?: boolean | UserDefaultArgs<ExtArgs>
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentationType?: boolean | AbstractSubmission$presentationTypeArgs<ExtArgs>
  }, ExtArgs["result"]["abstractSubmission"]>

  export type AbstractSubmissionSelectScalar = {
    id?: boolean
    title?: boolean
    abstractText?: boolean
    fileUrl?: boolean
    submitterId?: boolean
    conferenceId?: boolean
    status?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    presentationTypeId?: boolean
  }

  export type AbstractSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "abstractText" | "fileUrl" | "submitterId" | "conferenceId" | "status" | "keywords" | "createdAt" | "updatedAt" | "presentationTypeId", ExtArgs["result"]["abstractSubmission"]>
  export type AbstractSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserDefaultArgs<ExtArgs>
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    reviews?: boolean | AbstractSubmission$reviewsArgs<ExtArgs>
    presentationType?: boolean | AbstractSubmission$presentationTypeArgs<ExtArgs>
    _count?: boolean | AbstractSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AbstractSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserDefaultArgs<ExtArgs>
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentationType?: boolean | AbstractSubmission$presentationTypeArgs<ExtArgs>
  }
  export type AbstractSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserDefaultArgs<ExtArgs>
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentationType?: boolean | AbstractSubmission$presentationTypeArgs<ExtArgs>
  }

  export type $AbstractSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AbstractSubmission"
    objects: {
      submitter: Prisma.$UserPayload<ExtArgs>
      conference: Prisma.$ConferencePayload<ExtArgs>
      reviews: Prisma.$AbstractReviewPayload<ExtArgs>[]
      presentationType: Prisma.$PresentationTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      abstractText: string | null
      fileUrl: string | null
      submitterId: number
      conferenceId: number
      status: $Enums.AbstractSubmissionStatus
      keywords: string[]
      createdAt: Date
      updatedAt: Date
      presentationTypeId: number | null
    }, ExtArgs["result"]["abstractSubmission"]>
    composites: {}
  }

  type AbstractSubmissionGetPayload<S extends boolean | null | undefined | AbstractSubmissionDefaultArgs> = $Result.GetResult<Prisma.$AbstractSubmissionPayload, S>

  type AbstractSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbstractSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbstractSubmissionCountAggregateInputType | true
    }

  export interface AbstractSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AbstractSubmission'], meta: { name: 'AbstractSubmission' } }
    /**
     * Find zero or one AbstractSubmission that matches the filter.
     * @param {AbstractSubmissionFindUniqueArgs} args - Arguments to find a AbstractSubmission
     * @example
     * // Get one AbstractSubmission
     * const abstractSubmission = await prisma.abstractSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbstractSubmissionFindUniqueArgs>(args: SelectSubset<T, AbstractSubmissionFindUniqueArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AbstractSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbstractSubmissionFindUniqueOrThrowArgs} args - Arguments to find a AbstractSubmission
     * @example
     * // Get one AbstractSubmission
     * const abstractSubmission = await prisma.abstractSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbstractSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AbstractSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AbstractSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionFindFirstArgs} args - Arguments to find a AbstractSubmission
     * @example
     * // Get one AbstractSubmission
     * const abstractSubmission = await prisma.abstractSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbstractSubmissionFindFirstArgs>(args?: SelectSubset<T, AbstractSubmissionFindFirstArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AbstractSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionFindFirstOrThrowArgs} args - Arguments to find a AbstractSubmission
     * @example
     * // Get one AbstractSubmission
     * const abstractSubmission = await prisma.abstractSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbstractSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AbstractSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AbstractSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AbstractSubmissions
     * const abstractSubmissions = await prisma.abstractSubmission.findMany()
     * 
     * // Get first 10 AbstractSubmissions
     * const abstractSubmissions = await prisma.abstractSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abstractSubmissionWithIdOnly = await prisma.abstractSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbstractSubmissionFindManyArgs>(args?: SelectSubset<T, AbstractSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AbstractSubmission.
     * @param {AbstractSubmissionCreateArgs} args - Arguments to create a AbstractSubmission.
     * @example
     * // Create one AbstractSubmission
     * const AbstractSubmission = await prisma.abstractSubmission.create({
     *   data: {
     *     // ... data to create a AbstractSubmission
     *   }
     * })
     * 
     */
    create<T extends AbstractSubmissionCreateArgs>(args: SelectSubset<T, AbstractSubmissionCreateArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AbstractSubmissions.
     * @param {AbstractSubmissionCreateManyArgs} args - Arguments to create many AbstractSubmissions.
     * @example
     * // Create many AbstractSubmissions
     * const abstractSubmission = await prisma.abstractSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbstractSubmissionCreateManyArgs>(args?: SelectSubset<T, AbstractSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AbstractSubmissions and returns the data saved in the database.
     * @param {AbstractSubmissionCreateManyAndReturnArgs} args - Arguments to create many AbstractSubmissions.
     * @example
     * // Create many AbstractSubmissions
     * const abstractSubmission = await prisma.abstractSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AbstractSubmissions and only return the `id`
     * const abstractSubmissionWithIdOnly = await prisma.abstractSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AbstractSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AbstractSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AbstractSubmission.
     * @param {AbstractSubmissionDeleteArgs} args - Arguments to delete one AbstractSubmission.
     * @example
     * // Delete one AbstractSubmission
     * const AbstractSubmission = await prisma.abstractSubmission.delete({
     *   where: {
     *     // ... filter to delete one AbstractSubmission
     *   }
     * })
     * 
     */
    delete<T extends AbstractSubmissionDeleteArgs>(args: SelectSubset<T, AbstractSubmissionDeleteArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AbstractSubmission.
     * @param {AbstractSubmissionUpdateArgs} args - Arguments to update one AbstractSubmission.
     * @example
     * // Update one AbstractSubmission
     * const abstractSubmission = await prisma.abstractSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbstractSubmissionUpdateArgs>(args: SelectSubset<T, AbstractSubmissionUpdateArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AbstractSubmissions.
     * @param {AbstractSubmissionDeleteManyArgs} args - Arguments to filter AbstractSubmissions to delete.
     * @example
     * // Delete a few AbstractSubmissions
     * const { count } = await prisma.abstractSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbstractSubmissionDeleteManyArgs>(args?: SelectSubset<T, AbstractSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbstractSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AbstractSubmissions
     * const abstractSubmission = await prisma.abstractSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbstractSubmissionUpdateManyArgs>(args: SelectSubset<T, AbstractSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbstractSubmissions and returns the data updated in the database.
     * @param {AbstractSubmissionUpdateManyAndReturnArgs} args - Arguments to update many AbstractSubmissions.
     * @example
     * // Update many AbstractSubmissions
     * const abstractSubmission = await prisma.abstractSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AbstractSubmissions and only return the `id`
     * const abstractSubmissionWithIdOnly = await prisma.abstractSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AbstractSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AbstractSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AbstractSubmission.
     * @param {AbstractSubmissionUpsertArgs} args - Arguments to update or create a AbstractSubmission.
     * @example
     * // Update or create a AbstractSubmission
     * const abstractSubmission = await prisma.abstractSubmission.upsert({
     *   create: {
     *     // ... data to create a AbstractSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AbstractSubmission we want to update
     *   }
     * })
     */
    upsert<T extends AbstractSubmissionUpsertArgs>(args: SelectSubset<T, AbstractSubmissionUpsertArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AbstractSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionCountArgs} args - Arguments to filter AbstractSubmissions to count.
     * @example
     * // Count the number of AbstractSubmissions
     * const count = await prisma.abstractSubmission.count({
     *   where: {
     *     // ... the filter for the AbstractSubmissions we want to count
     *   }
     * })
    **/
    count<T extends AbstractSubmissionCountArgs>(
      args?: Subset<T, AbstractSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbstractSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AbstractSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbstractSubmissionAggregateArgs>(args: Subset<T, AbstractSubmissionAggregateArgs>): Prisma.PrismaPromise<GetAbstractSubmissionAggregateType<T>>

    /**
     * Group by AbstractSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbstractSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbstractSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: AbstractSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbstractSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbstractSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AbstractSubmission model
   */
  readonly fields: AbstractSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AbstractSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbstractSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submitter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends AbstractSubmission$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, AbstractSubmission$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presentationType<T extends AbstractSubmission$presentationTypeArgs<ExtArgs> = {}>(args?: Subset<T, AbstractSubmission$presentationTypeArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AbstractSubmission model
   */
  interface AbstractSubmissionFieldRefs {
    readonly id: FieldRef<"AbstractSubmission", 'Int'>
    readonly title: FieldRef<"AbstractSubmission", 'String'>
    readonly abstractText: FieldRef<"AbstractSubmission", 'String'>
    readonly fileUrl: FieldRef<"AbstractSubmission", 'String'>
    readonly submitterId: FieldRef<"AbstractSubmission", 'Int'>
    readonly conferenceId: FieldRef<"AbstractSubmission", 'Int'>
    readonly status: FieldRef<"AbstractSubmission", 'AbstractSubmissionStatus'>
    readonly keywords: FieldRef<"AbstractSubmission", 'String[]'>
    readonly createdAt: FieldRef<"AbstractSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"AbstractSubmission", 'DateTime'>
    readonly presentationTypeId: FieldRef<"AbstractSubmission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AbstractSubmission findUnique
   */
  export type AbstractSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AbstractSubmission to fetch.
     */
    where: AbstractSubmissionWhereUniqueInput
  }

  /**
   * AbstractSubmission findUniqueOrThrow
   */
  export type AbstractSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AbstractSubmission to fetch.
     */
    where: AbstractSubmissionWhereUniqueInput
  }

  /**
   * AbstractSubmission findFirst
   */
  export type AbstractSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AbstractSubmission to fetch.
     */
    where?: AbstractSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractSubmissions to fetch.
     */
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbstractSubmissions.
     */
    cursor?: AbstractSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbstractSubmissions.
     */
    distinct?: AbstractSubmissionScalarFieldEnum | AbstractSubmissionScalarFieldEnum[]
  }

  /**
   * AbstractSubmission findFirstOrThrow
   */
  export type AbstractSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AbstractSubmission to fetch.
     */
    where?: AbstractSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractSubmissions to fetch.
     */
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbstractSubmissions.
     */
    cursor?: AbstractSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbstractSubmissions.
     */
    distinct?: AbstractSubmissionScalarFieldEnum | AbstractSubmissionScalarFieldEnum[]
  }

  /**
   * AbstractSubmission findMany
   */
  export type AbstractSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AbstractSubmissions to fetch.
     */
    where?: AbstractSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractSubmissions to fetch.
     */
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AbstractSubmissions.
     */
    cursor?: AbstractSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractSubmissions.
     */
    skip?: number
    distinct?: AbstractSubmissionScalarFieldEnum | AbstractSubmissionScalarFieldEnum[]
  }

  /**
   * AbstractSubmission create
   */
  export type AbstractSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AbstractSubmission.
     */
    data: XOR<AbstractSubmissionCreateInput, AbstractSubmissionUncheckedCreateInput>
  }

  /**
   * AbstractSubmission createMany
   */
  export type AbstractSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AbstractSubmissions.
     */
    data: AbstractSubmissionCreateManyInput | AbstractSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AbstractSubmission createManyAndReturn
   */
  export type AbstractSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many AbstractSubmissions.
     */
    data: AbstractSubmissionCreateManyInput | AbstractSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AbstractSubmission update
   */
  export type AbstractSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AbstractSubmission.
     */
    data: XOR<AbstractSubmissionUpdateInput, AbstractSubmissionUncheckedUpdateInput>
    /**
     * Choose, which AbstractSubmission to update.
     */
    where: AbstractSubmissionWhereUniqueInput
  }

  /**
   * AbstractSubmission updateMany
   */
  export type AbstractSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AbstractSubmissions.
     */
    data: XOR<AbstractSubmissionUpdateManyMutationInput, AbstractSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AbstractSubmissions to update
     */
    where?: AbstractSubmissionWhereInput
    /**
     * Limit how many AbstractSubmissions to update.
     */
    limit?: number
  }

  /**
   * AbstractSubmission updateManyAndReturn
   */
  export type AbstractSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update AbstractSubmissions.
     */
    data: XOR<AbstractSubmissionUpdateManyMutationInput, AbstractSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AbstractSubmissions to update
     */
    where?: AbstractSubmissionWhereInput
    /**
     * Limit how many AbstractSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AbstractSubmission upsert
   */
  export type AbstractSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AbstractSubmission to update in case it exists.
     */
    where: AbstractSubmissionWhereUniqueInput
    /**
     * In case the AbstractSubmission found by the `where` argument doesn't exist, create a new AbstractSubmission with this data.
     */
    create: XOR<AbstractSubmissionCreateInput, AbstractSubmissionUncheckedCreateInput>
    /**
     * In case the AbstractSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbstractSubmissionUpdateInput, AbstractSubmissionUncheckedUpdateInput>
  }

  /**
   * AbstractSubmission delete
   */
  export type AbstractSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    /**
     * Filter which AbstractSubmission to delete.
     */
    where: AbstractSubmissionWhereUniqueInput
  }

  /**
   * AbstractSubmission deleteMany
   */
  export type AbstractSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbstractSubmissions to delete
     */
    where?: AbstractSubmissionWhereInput
    /**
     * Limit how many AbstractSubmissions to delete.
     */
    limit?: number
  }

  /**
   * AbstractSubmission.reviews
   */
  export type AbstractSubmission$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    where?: AbstractReviewWhereInput
    orderBy?: AbstractReviewOrderByWithRelationInput | AbstractReviewOrderByWithRelationInput[]
    cursor?: AbstractReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbstractReviewScalarFieldEnum | AbstractReviewScalarFieldEnum[]
  }

  /**
   * AbstractSubmission.presentationType
   */
  export type AbstractSubmission$presentationTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    where?: PresentationTypeWhereInput
  }

  /**
   * AbstractSubmission without action
   */
  export type AbstractSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model AbstractReview
   */

  export type AggregateAbstractReview = {
    _count: AbstractReviewCountAggregateOutputType | null
    _avg: AbstractReviewAvgAggregateOutputType | null
    _sum: AbstractReviewSumAggregateOutputType | null
    _min: AbstractReviewMinAggregateOutputType | null
    _max: AbstractReviewMaxAggregateOutputType | null
  }

  export type AbstractReviewAvgAggregateOutputType = {
    id: number | null
    abstractId: number | null
    reviewerId: number | null
    score: number | null
  }

  export type AbstractReviewSumAggregateOutputType = {
    id: number | null
    abstractId: number | null
    reviewerId: number | null
    score: number | null
  }

  export type AbstractReviewMinAggregateOutputType = {
    id: number | null
    abstractId: number | null
    reviewerId: number | null
    score: number | null
    comments: string | null
    recommendation: string | null
  }

  export type AbstractReviewMaxAggregateOutputType = {
    id: number | null
    abstractId: number | null
    reviewerId: number | null
    score: number | null
    comments: string | null
    recommendation: string | null
  }

  export type AbstractReviewCountAggregateOutputType = {
    id: number
    abstractId: number
    reviewerId: number
    score: number
    comments: number
    recommendation: number
    _all: number
  }


  export type AbstractReviewAvgAggregateInputType = {
    id?: true
    abstractId?: true
    reviewerId?: true
    score?: true
  }

  export type AbstractReviewSumAggregateInputType = {
    id?: true
    abstractId?: true
    reviewerId?: true
    score?: true
  }

  export type AbstractReviewMinAggregateInputType = {
    id?: true
    abstractId?: true
    reviewerId?: true
    score?: true
    comments?: true
    recommendation?: true
  }

  export type AbstractReviewMaxAggregateInputType = {
    id?: true
    abstractId?: true
    reviewerId?: true
    score?: true
    comments?: true
    recommendation?: true
  }

  export type AbstractReviewCountAggregateInputType = {
    id?: true
    abstractId?: true
    reviewerId?: true
    score?: true
    comments?: true
    recommendation?: true
    _all?: true
  }

  export type AbstractReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbstractReview to aggregate.
     */
    where?: AbstractReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractReviews to fetch.
     */
    orderBy?: AbstractReviewOrderByWithRelationInput | AbstractReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbstractReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AbstractReviews
    **/
    _count?: true | AbstractReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbstractReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbstractReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbstractReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbstractReviewMaxAggregateInputType
  }

  export type GetAbstractReviewAggregateType<T extends AbstractReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateAbstractReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbstractReview[P]>
      : GetScalarType<T[P], AggregateAbstractReview[P]>
  }




  export type AbstractReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbstractReviewWhereInput
    orderBy?: AbstractReviewOrderByWithAggregationInput | AbstractReviewOrderByWithAggregationInput[]
    by: AbstractReviewScalarFieldEnum[] | AbstractReviewScalarFieldEnum
    having?: AbstractReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbstractReviewCountAggregateInputType | true
    _avg?: AbstractReviewAvgAggregateInputType
    _sum?: AbstractReviewSumAggregateInputType
    _min?: AbstractReviewMinAggregateInputType
    _max?: AbstractReviewMaxAggregateInputType
  }

  export type AbstractReviewGroupByOutputType = {
    id: number
    abstractId: number
    reviewerId: number
    score: number
    comments: string | null
    recommendation: string
    _count: AbstractReviewCountAggregateOutputType | null
    _avg: AbstractReviewAvgAggregateOutputType | null
    _sum: AbstractReviewSumAggregateOutputType | null
    _min: AbstractReviewMinAggregateOutputType | null
    _max: AbstractReviewMaxAggregateOutputType | null
  }

  type GetAbstractReviewGroupByPayload<T extends AbstractReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbstractReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbstractReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbstractReviewGroupByOutputType[P]>
            : GetScalarType<T[P], AbstractReviewGroupByOutputType[P]>
        }
      >
    >


  export type AbstractReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    abstractId?: boolean
    reviewerId?: boolean
    score?: boolean
    comments?: boolean
    recommendation?: boolean
    abstract?: boolean | AbstractSubmissionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abstractReview"]>

  export type AbstractReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    abstractId?: boolean
    reviewerId?: boolean
    score?: boolean
    comments?: boolean
    recommendation?: boolean
    abstract?: boolean | AbstractSubmissionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abstractReview"]>

  export type AbstractReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    abstractId?: boolean
    reviewerId?: boolean
    score?: boolean
    comments?: boolean
    recommendation?: boolean
    abstract?: boolean | AbstractSubmissionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abstractReview"]>

  export type AbstractReviewSelectScalar = {
    id?: boolean
    abstractId?: boolean
    reviewerId?: boolean
    score?: boolean
    comments?: boolean
    recommendation?: boolean
  }

  export type AbstractReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "abstractId" | "reviewerId" | "score" | "comments" | "recommendation", ExtArgs["result"]["abstractReview"]>
  export type AbstractReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abstract?: boolean | AbstractSubmissionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AbstractReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abstract?: boolean | AbstractSubmissionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AbstractReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abstract?: boolean | AbstractSubmissionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AbstractReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AbstractReview"
    objects: {
      abstract: Prisma.$AbstractSubmissionPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      abstractId: number
      reviewerId: number
      score: number
      comments: string | null
      recommendation: string
    }, ExtArgs["result"]["abstractReview"]>
    composites: {}
  }

  type AbstractReviewGetPayload<S extends boolean | null | undefined | AbstractReviewDefaultArgs> = $Result.GetResult<Prisma.$AbstractReviewPayload, S>

  type AbstractReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbstractReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbstractReviewCountAggregateInputType | true
    }

  export interface AbstractReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AbstractReview'], meta: { name: 'AbstractReview' } }
    /**
     * Find zero or one AbstractReview that matches the filter.
     * @param {AbstractReviewFindUniqueArgs} args - Arguments to find a AbstractReview
     * @example
     * // Get one AbstractReview
     * const abstractReview = await prisma.abstractReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbstractReviewFindUniqueArgs>(args: SelectSubset<T, AbstractReviewFindUniqueArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AbstractReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbstractReviewFindUniqueOrThrowArgs} args - Arguments to find a AbstractReview
     * @example
     * // Get one AbstractReview
     * const abstractReview = await prisma.abstractReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbstractReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, AbstractReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AbstractReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewFindFirstArgs} args - Arguments to find a AbstractReview
     * @example
     * // Get one AbstractReview
     * const abstractReview = await prisma.abstractReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbstractReviewFindFirstArgs>(args?: SelectSubset<T, AbstractReviewFindFirstArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AbstractReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewFindFirstOrThrowArgs} args - Arguments to find a AbstractReview
     * @example
     * // Get one AbstractReview
     * const abstractReview = await prisma.abstractReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbstractReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, AbstractReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AbstractReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AbstractReviews
     * const abstractReviews = await prisma.abstractReview.findMany()
     * 
     * // Get first 10 AbstractReviews
     * const abstractReviews = await prisma.abstractReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abstractReviewWithIdOnly = await prisma.abstractReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbstractReviewFindManyArgs>(args?: SelectSubset<T, AbstractReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AbstractReview.
     * @param {AbstractReviewCreateArgs} args - Arguments to create a AbstractReview.
     * @example
     * // Create one AbstractReview
     * const AbstractReview = await prisma.abstractReview.create({
     *   data: {
     *     // ... data to create a AbstractReview
     *   }
     * })
     * 
     */
    create<T extends AbstractReviewCreateArgs>(args: SelectSubset<T, AbstractReviewCreateArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AbstractReviews.
     * @param {AbstractReviewCreateManyArgs} args - Arguments to create many AbstractReviews.
     * @example
     * // Create many AbstractReviews
     * const abstractReview = await prisma.abstractReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbstractReviewCreateManyArgs>(args?: SelectSubset<T, AbstractReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AbstractReviews and returns the data saved in the database.
     * @param {AbstractReviewCreateManyAndReturnArgs} args - Arguments to create many AbstractReviews.
     * @example
     * // Create many AbstractReviews
     * const abstractReview = await prisma.abstractReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AbstractReviews and only return the `id`
     * const abstractReviewWithIdOnly = await prisma.abstractReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AbstractReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, AbstractReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AbstractReview.
     * @param {AbstractReviewDeleteArgs} args - Arguments to delete one AbstractReview.
     * @example
     * // Delete one AbstractReview
     * const AbstractReview = await prisma.abstractReview.delete({
     *   where: {
     *     // ... filter to delete one AbstractReview
     *   }
     * })
     * 
     */
    delete<T extends AbstractReviewDeleteArgs>(args: SelectSubset<T, AbstractReviewDeleteArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AbstractReview.
     * @param {AbstractReviewUpdateArgs} args - Arguments to update one AbstractReview.
     * @example
     * // Update one AbstractReview
     * const abstractReview = await prisma.abstractReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbstractReviewUpdateArgs>(args: SelectSubset<T, AbstractReviewUpdateArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AbstractReviews.
     * @param {AbstractReviewDeleteManyArgs} args - Arguments to filter AbstractReviews to delete.
     * @example
     * // Delete a few AbstractReviews
     * const { count } = await prisma.abstractReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbstractReviewDeleteManyArgs>(args?: SelectSubset<T, AbstractReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbstractReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AbstractReviews
     * const abstractReview = await prisma.abstractReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbstractReviewUpdateManyArgs>(args: SelectSubset<T, AbstractReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbstractReviews and returns the data updated in the database.
     * @param {AbstractReviewUpdateManyAndReturnArgs} args - Arguments to update many AbstractReviews.
     * @example
     * // Update many AbstractReviews
     * const abstractReview = await prisma.abstractReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AbstractReviews and only return the `id`
     * const abstractReviewWithIdOnly = await prisma.abstractReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AbstractReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, AbstractReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AbstractReview.
     * @param {AbstractReviewUpsertArgs} args - Arguments to update or create a AbstractReview.
     * @example
     * // Update or create a AbstractReview
     * const abstractReview = await prisma.abstractReview.upsert({
     *   create: {
     *     // ... data to create a AbstractReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AbstractReview we want to update
     *   }
     * })
     */
    upsert<T extends AbstractReviewUpsertArgs>(args: SelectSubset<T, AbstractReviewUpsertArgs<ExtArgs>>): Prisma__AbstractReviewClient<$Result.GetResult<Prisma.$AbstractReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AbstractReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewCountArgs} args - Arguments to filter AbstractReviews to count.
     * @example
     * // Count the number of AbstractReviews
     * const count = await prisma.abstractReview.count({
     *   where: {
     *     // ... the filter for the AbstractReviews we want to count
     *   }
     * })
    **/
    count<T extends AbstractReviewCountArgs>(
      args?: Subset<T, AbstractReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbstractReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AbstractReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbstractReviewAggregateArgs>(args: Subset<T, AbstractReviewAggregateArgs>): Prisma.PrismaPromise<GetAbstractReviewAggregateType<T>>

    /**
     * Group by AbstractReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbstractReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbstractReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbstractReviewGroupByArgs['orderBy'] }
        : { orderBy?: AbstractReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbstractReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbstractReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AbstractReview model
   */
  readonly fields: AbstractReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AbstractReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbstractReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abstract<T extends AbstractSubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AbstractSubmissionDefaultArgs<ExtArgs>>): Prisma__AbstractSubmissionClient<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AbstractReview model
   */
  interface AbstractReviewFieldRefs {
    readonly id: FieldRef<"AbstractReview", 'Int'>
    readonly abstractId: FieldRef<"AbstractReview", 'Int'>
    readonly reviewerId: FieldRef<"AbstractReview", 'Int'>
    readonly score: FieldRef<"AbstractReview", 'Int'>
    readonly comments: FieldRef<"AbstractReview", 'String'>
    readonly recommendation: FieldRef<"AbstractReview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AbstractReview findUnique
   */
  export type AbstractReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * Filter, which AbstractReview to fetch.
     */
    where: AbstractReviewWhereUniqueInput
  }

  /**
   * AbstractReview findUniqueOrThrow
   */
  export type AbstractReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * Filter, which AbstractReview to fetch.
     */
    where: AbstractReviewWhereUniqueInput
  }

  /**
   * AbstractReview findFirst
   */
  export type AbstractReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * Filter, which AbstractReview to fetch.
     */
    where?: AbstractReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractReviews to fetch.
     */
    orderBy?: AbstractReviewOrderByWithRelationInput | AbstractReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbstractReviews.
     */
    cursor?: AbstractReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbstractReviews.
     */
    distinct?: AbstractReviewScalarFieldEnum | AbstractReviewScalarFieldEnum[]
  }

  /**
   * AbstractReview findFirstOrThrow
   */
  export type AbstractReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * Filter, which AbstractReview to fetch.
     */
    where?: AbstractReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractReviews to fetch.
     */
    orderBy?: AbstractReviewOrderByWithRelationInput | AbstractReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbstractReviews.
     */
    cursor?: AbstractReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbstractReviews.
     */
    distinct?: AbstractReviewScalarFieldEnum | AbstractReviewScalarFieldEnum[]
  }

  /**
   * AbstractReview findMany
   */
  export type AbstractReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * Filter, which AbstractReviews to fetch.
     */
    where?: AbstractReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbstractReviews to fetch.
     */
    orderBy?: AbstractReviewOrderByWithRelationInput | AbstractReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AbstractReviews.
     */
    cursor?: AbstractReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbstractReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbstractReviews.
     */
    skip?: number
    distinct?: AbstractReviewScalarFieldEnum | AbstractReviewScalarFieldEnum[]
  }

  /**
   * AbstractReview create
   */
  export type AbstractReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a AbstractReview.
     */
    data: XOR<AbstractReviewCreateInput, AbstractReviewUncheckedCreateInput>
  }

  /**
   * AbstractReview createMany
   */
  export type AbstractReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AbstractReviews.
     */
    data: AbstractReviewCreateManyInput | AbstractReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AbstractReview createManyAndReturn
   */
  export type AbstractReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * The data used to create many AbstractReviews.
     */
    data: AbstractReviewCreateManyInput | AbstractReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AbstractReview update
   */
  export type AbstractReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a AbstractReview.
     */
    data: XOR<AbstractReviewUpdateInput, AbstractReviewUncheckedUpdateInput>
    /**
     * Choose, which AbstractReview to update.
     */
    where: AbstractReviewWhereUniqueInput
  }

  /**
   * AbstractReview updateMany
   */
  export type AbstractReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AbstractReviews.
     */
    data: XOR<AbstractReviewUpdateManyMutationInput, AbstractReviewUncheckedUpdateManyInput>
    /**
     * Filter which AbstractReviews to update
     */
    where?: AbstractReviewWhereInput
    /**
     * Limit how many AbstractReviews to update.
     */
    limit?: number
  }

  /**
   * AbstractReview updateManyAndReturn
   */
  export type AbstractReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * The data used to update AbstractReviews.
     */
    data: XOR<AbstractReviewUpdateManyMutationInput, AbstractReviewUncheckedUpdateManyInput>
    /**
     * Filter which AbstractReviews to update
     */
    where?: AbstractReviewWhereInput
    /**
     * Limit how many AbstractReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AbstractReview upsert
   */
  export type AbstractReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the AbstractReview to update in case it exists.
     */
    where: AbstractReviewWhereUniqueInput
    /**
     * In case the AbstractReview found by the `where` argument doesn't exist, create a new AbstractReview with this data.
     */
    create: XOR<AbstractReviewCreateInput, AbstractReviewUncheckedCreateInput>
    /**
     * In case the AbstractReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbstractReviewUpdateInput, AbstractReviewUncheckedUpdateInput>
  }

  /**
   * AbstractReview delete
   */
  export type AbstractReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
    /**
     * Filter which AbstractReview to delete.
     */
    where: AbstractReviewWhereUniqueInput
  }

  /**
   * AbstractReview deleteMany
   */
  export type AbstractReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbstractReviews to delete
     */
    where?: AbstractReviewWhereInput
    /**
     * Limit how many AbstractReviews to delete.
     */
    limit?: number
  }

  /**
   * AbstractReview without action
   */
  export type AbstractReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractReview
     */
    select?: AbstractReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractReview
     */
    omit?: AbstractReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractReviewInclude<ExtArgs> | null
  }


  /**
   * Model Presentation
   */

  export type AggregatePresentation = {
    _count: PresentationCountAggregateOutputType | null
    _avg: PresentationAvgAggregateOutputType | null
    _sum: PresentationSumAggregateOutputType | null
    _min: PresentationMinAggregateOutputType | null
    _max: PresentationMaxAggregateOutputType | null
  }

  export type PresentationAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    duration: number | null
    sectionId: number | null
    categoryId: number | null
    presentationTypeId: number | null
  }

  export type PresentationSumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    duration: number | null
    sectionId: number | null
    categoryId: number | null
    presentationTypeId: number | null
  }

  export type PresentationMinAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    title: string | null
    abstract: string | null
    duration: number | null
    status: string | null
    createdAt: Date | null
    sectionId: number | null
    categoryId: number | null
    presentationTypeId: number | null
  }

  export type PresentationMaxAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    title: string | null
    abstract: string | null
    duration: number | null
    status: string | null
    createdAt: Date | null
    sectionId: number | null
    categoryId: number | null
    presentationTypeId: number | null
  }

  export type PresentationCountAggregateOutputType = {
    id: number
    conferenceId: number
    title: number
    abstract: number
    duration: number
    status: number
    createdAt: number
    sectionId: number
    categoryId: number
    presentationTypeId: number
    _all: number
  }


  export type PresentationAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    duration?: true
    sectionId?: true
    categoryId?: true
    presentationTypeId?: true
  }

  export type PresentationSumAggregateInputType = {
    id?: true
    conferenceId?: true
    duration?: true
    sectionId?: true
    categoryId?: true
    presentationTypeId?: true
  }

  export type PresentationMinAggregateInputType = {
    id?: true
    conferenceId?: true
    title?: true
    abstract?: true
    duration?: true
    status?: true
    createdAt?: true
    sectionId?: true
    categoryId?: true
    presentationTypeId?: true
  }

  export type PresentationMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    title?: true
    abstract?: true
    duration?: true
    status?: true
    createdAt?: true
    sectionId?: true
    categoryId?: true
    presentationTypeId?: true
  }

  export type PresentationCountAggregateInputType = {
    id?: true
    conferenceId?: true
    title?: true
    abstract?: true
    duration?: true
    status?: true
    createdAt?: true
    sectionId?: true
    categoryId?: true
    presentationTypeId?: true
    _all?: true
  }

  export type PresentationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Presentation to aggregate.
     */
    where?: PresentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presentations to fetch.
     */
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Presentations
    **/
    _count?: true | PresentationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresentationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresentationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresentationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresentationMaxAggregateInputType
  }

  export type GetPresentationAggregateType<T extends PresentationAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentation[P]>
      : GetScalarType<T[P], AggregatePresentation[P]>
  }




  export type PresentationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationWhereInput
    orderBy?: PresentationOrderByWithAggregationInput | PresentationOrderByWithAggregationInput[]
    by: PresentationScalarFieldEnum[] | PresentationScalarFieldEnum
    having?: PresentationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresentationCountAggregateInputType | true
    _avg?: PresentationAvgAggregateInputType
    _sum?: PresentationSumAggregateInputType
    _min?: PresentationMinAggregateInputType
    _max?: PresentationMaxAggregateInputType
  }

  export type PresentationGroupByOutputType = {
    id: number
    conferenceId: number
    title: string
    abstract: string | null
    duration: number | null
    status: string
    createdAt: Date
    sectionId: number | null
    categoryId: number | null
    presentationTypeId: number | null
    _count: PresentationCountAggregateOutputType | null
    _avg: PresentationAvgAggregateOutputType | null
    _sum: PresentationSumAggregateOutputType | null
    _min: PresentationMinAggregateOutputType | null
    _max: PresentationMaxAggregateOutputType | null
  }

  type GetPresentationGroupByPayload<T extends PresentationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresentationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresentationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresentationGroupByOutputType[P]>
            : GetScalarType<T[P], PresentationGroupByOutputType[P]>
        }
      >
    >


  export type PresentationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    title?: boolean
    abstract?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    sectionId?: boolean
    categoryId?: boolean
    presentationTypeId?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    section?: boolean | Presentation$sectionArgs<ExtArgs>
    authors?: boolean | Presentation$authorsArgs<ExtArgs>
    category?: boolean | Presentation$categoryArgs<ExtArgs>
    presentationType?: boolean | Presentation$presentationTypeArgs<ExtArgs>
    timeSlot?: boolean | Presentation$timeSlotArgs<ExtArgs>
    feedback?: boolean | Presentation$feedbackArgs<ExtArgs>
    _count?: boolean | PresentationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentation"]>

  export type PresentationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    title?: boolean
    abstract?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    sectionId?: boolean
    categoryId?: boolean
    presentationTypeId?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    section?: boolean | Presentation$sectionArgs<ExtArgs>
    category?: boolean | Presentation$categoryArgs<ExtArgs>
    presentationType?: boolean | Presentation$presentationTypeArgs<ExtArgs>
  }, ExtArgs["result"]["presentation"]>

  export type PresentationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    title?: boolean
    abstract?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    sectionId?: boolean
    categoryId?: boolean
    presentationTypeId?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    section?: boolean | Presentation$sectionArgs<ExtArgs>
    category?: boolean | Presentation$categoryArgs<ExtArgs>
    presentationType?: boolean | Presentation$presentationTypeArgs<ExtArgs>
  }, ExtArgs["result"]["presentation"]>

  export type PresentationSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    title?: boolean
    abstract?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    sectionId?: boolean
    categoryId?: boolean
    presentationTypeId?: boolean
  }

  export type PresentationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "title" | "abstract" | "duration" | "status" | "createdAt" | "sectionId" | "categoryId" | "presentationTypeId", ExtArgs["result"]["presentation"]>
  export type PresentationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    section?: boolean | Presentation$sectionArgs<ExtArgs>
    authors?: boolean | Presentation$authorsArgs<ExtArgs>
    category?: boolean | Presentation$categoryArgs<ExtArgs>
    presentationType?: boolean | Presentation$presentationTypeArgs<ExtArgs>
    timeSlot?: boolean | Presentation$timeSlotArgs<ExtArgs>
    feedback?: boolean | Presentation$feedbackArgs<ExtArgs>
    _count?: boolean | PresentationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PresentationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    section?: boolean | Presentation$sectionArgs<ExtArgs>
    category?: boolean | Presentation$categoryArgs<ExtArgs>
    presentationType?: boolean | Presentation$presentationTypeArgs<ExtArgs>
  }
  export type PresentationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    section?: boolean | Presentation$sectionArgs<ExtArgs>
    category?: boolean | Presentation$categoryArgs<ExtArgs>
    presentationType?: boolean | Presentation$presentationTypeArgs<ExtArgs>
  }

  export type $PresentationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Presentation"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs> | null
      authors: Prisma.$PresentationAuthorPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      presentationType: Prisma.$PresentationTypePayload<ExtArgs> | null
      timeSlot: Prisma.$TimeSlotPayload<ExtArgs> | null
      feedback: Prisma.$PresentationFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conferenceId: number
      title: string
      abstract: string | null
      duration: number | null
      status: string
      createdAt: Date
      sectionId: number | null
      categoryId: number | null
      presentationTypeId: number | null
    }, ExtArgs["result"]["presentation"]>
    composites: {}
  }

  type PresentationGetPayload<S extends boolean | null | undefined | PresentationDefaultArgs> = $Result.GetResult<Prisma.$PresentationPayload, S>

  type PresentationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresentationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresentationCountAggregateInputType | true
    }

  export interface PresentationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Presentation'], meta: { name: 'Presentation' } }
    /**
     * Find zero or one Presentation that matches the filter.
     * @param {PresentationFindUniqueArgs} args - Arguments to find a Presentation
     * @example
     * // Get one Presentation
     * const presentation = await prisma.presentation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresentationFindUniqueArgs>(args: SelectSubset<T, PresentationFindUniqueArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Presentation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresentationFindUniqueOrThrowArgs} args - Arguments to find a Presentation
     * @example
     * // Get one Presentation
     * const presentation = await prisma.presentation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresentationFindUniqueOrThrowArgs>(args: SelectSubset<T, PresentationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Presentation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFindFirstArgs} args - Arguments to find a Presentation
     * @example
     * // Get one Presentation
     * const presentation = await prisma.presentation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresentationFindFirstArgs>(args?: SelectSubset<T, PresentationFindFirstArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Presentation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFindFirstOrThrowArgs} args - Arguments to find a Presentation
     * @example
     * // Get one Presentation
     * const presentation = await prisma.presentation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresentationFindFirstOrThrowArgs>(args?: SelectSubset<T, PresentationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Presentations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presentations
     * const presentations = await prisma.presentation.findMany()
     * 
     * // Get first 10 Presentations
     * const presentations = await prisma.presentation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presentationWithIdOnly = await prisma.presentation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresentationFindManyArgs>(args?: SelectSubset<T, PresentationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Presentation.
     * @param {PresentationCreateArgs} args - Arguments to create a Presentation.
     * @example
     * // Create one Presentation
     * const Presentation = await prisma.presentation.create({
     *   data: {
     *     // ... data to create a Presentation
     *   }
     * })
     * 
     */
    create<T extends PresentationCreateArgs>(args: SelectSubset<T, PresentationCreateArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Presentations.
     * @param {PresentationCreateManyArgs} args - Arguments to create many Presentations.
     * @example
     * // Create many Presentations
     * const presentation = await prisma.presentation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresentationCreateManyArgs>(args?: SelectSubset<T, PresentationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Presentations and returns the data saved in the database.
     * @param {PresentationCreateManyAndReturnArgs} args - Arguments to create many Presentations.
     * @example
     * // Create many Presentations
     * const presentation = await prisma.presentation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Presentations and only return the `id`
     * const presentationWithIdOnly = await prisma.presentation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresentationCreateManyAndReturnArgs>(args?: SelectSubset<T, PresentationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Presentation.
     * @param {PresentationDeleteArgs} args - Arguments to delete one Presentation.
     * @example
     * // Delete one Presentation
     * const Presentation = await prisma.presentation.delete({
     *   where: {
     *     // ... filter to delete one Presentation
     *   }
     * })
     * 
     */
    delete<T extends PresentationDeleteArgs>(args: SelectSubset<T, PresentationDeleteArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Presentation.
     * @param {PresentationUpdateArgs} args - Arguments to update one Presentation.
     * @example
     * // Update one Presentation
     * const presentation = await prisma.presentation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresentationUpdateArgs>(args: SelectSubset<T, PresentationUpdateArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Presentations.
     * @param {PresentationDeleteManyArgs} args - Arguments to filter Presentations to delete.
     * @example
     * // Delete a few Presentations
     * const { count } = await prisma.presentation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresentationDeleteManyArgs>(args?: SelectSubset<T, PresentationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presentations
     * const presentation = await prisma.presentation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresentationUpdateManyArgs>(args: SelectSubset<T, PresentationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presentations and returns the data updated in the database.
     * @param {PresentationUpdateManyAndReturnArgs} args - Arguments to update many Presentations.
     * @example
     * // Update many Presentations
     * const presentation = await prisma.presentation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Presentations and only return the `id`
     * const presentationWithIdOnly = await prisma.presentation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresentationUpdateManyAndReturnArgs>(args: SelectSubset<T, PresentationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Presentation.
     * @param {PresentationUpsertArgs} args - Arguments to update or create a Presentation.
     * @example
     * // Update or create a Presentation
     * const presentation = await prisma.presentation.upsert({
     *   create: {
     *     // ... data to create a Presentation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presentation we want to update
     *   }
     * })
     */
    upsert<T extends PresentationUpsertArgs>(args: SelectSubset<T, PresentationUpsertArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Presentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationCountArgs} args - Arguments to filter Presentations to count.
     * @example
     * // Count the number of Presentations
     * const count = await prisma.presentation.count({
     *   where: {
     *     // ... the filter for the Presentations we want to count
     *   }
     * })
    **/
    count<T extends PresentationCountArgs>(
      args?: Subset<T, PresentationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresentationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresentationAggregateArgs>(args: Subset<T, PresentationAggregateArgs>): Prisma.PrismaPromise<GetPresentationAggregateType<T>>

    /**
     * Group by Presentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresentationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresentationGroupByArgs['orderBy'] }
        : { orderBy?: PresentationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresentationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Presentation model
   */
  readonly fields: PresentationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Presentation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresentationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends Presentation$sectionArgs<ExtArgs> = {}>(args?: Subset<T, Presentation$sectionArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    authors<T extends Presentation$authorsArgs<ExtArgs> = {}>(args?: Subset<T, Presentation$authorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Presentation$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Presentation$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    presentationType<T extends Presentation$presentationTypeArgs<ExtArgs> = {}>(args?: Subset<T, Presentation$presentationTypeArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    timeSlot<T extends Presentation$timeSlotArgs<ExtArgs> = {}>(args?: Subset<T, Presentation$timeSlotArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedback<T extends Presentation$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Presentation$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Presentation model
   */
  interface PresentationFieldRefs {
    readonly id: FieldRef<"Presentation", 'Int'>
    readonly conferenceId: FieldRef<"Presentation", 'Int'>
    readonly title: FieldRef<"Presentation", 'String'>
    readonly abstract: FieldRef<"Presentation", 'String'>
    readonly duration: FieldRef<"Presentation", 'Int'>
    readonly status: FieldRef<"Presentation", 'String'>
    readonly createdAt: FieldRef<"Presentation", 'DateTime'>
    readonly sectionId: FieldRef<"Presentation", 'Int'>
    readonly categoryId: FieldRef<"Presentation", 'Int'>
    readonly presentationTypeId: FieldRef<"Presentation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Presentation findUnique
   */
  export type PresentationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * Filter, which Presentation to fetch.
     */
    where: PresentationWhereUniqueInput
  }

  /**
   * Presentation findUniqueOrThrow
   */
  export type PresentationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * Filter, which Presentation to fetch.
     */
    where: PresentationWhereUniqueInput
  }

  /**
   * Presentation findFirst
   */
  export type PresentationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * Filter, which Presentation to fetch.
     */
    where?: PresentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presentations to fetch.
     */
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presentations.
     */
    cursor?: PresentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presentations.
     */
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * Presentation findFirstOrThrow
   */
  export type PresentationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * Filter, which Presentation to fetch.
     */
    where?: PresentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presentations to fetch.
     */
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presentations.
     */
    cursor?: PresentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presentations.
     */
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * Presentation findMany
   */
  export type PresentationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * Filter, which Presentations to fetch.
     */
    where?: PresentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presentations to fetch.
     */
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Presentations.
     */
    cursor?: PresentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presentations.
     */
    skip?: number
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * Presentation create
   */
  export type PresentationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * The data needed to create a Presentation.
     */
    data: XOR<PresentationCreateInput, PresentationUncheckedCreateInput>
  }

  /**
   * Presentation createMany
   */
  export type PresentationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Presentations.
     */
    data: PresentationCreateManyInput | PresentationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Presentation createManyAndReturn
   */
  export type PresentationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * The data used to create many Presentations.
     */
    data: PresentationCreateManyInput | PresentationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Presentation update
   */
  export type PresentationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * The data needed to update a Presentation.
     */
    data: XOR<PresentationUpdateInput, PresentationUncheckedUpdateInput>
    /**
     * Choose, which Presentation to update.
     */
    where: PresentationWhereUniqueInput
  }

  /**
   * Presentation updateMany
   */
  export type PresentationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Presentations.
     */
    data: XOR<PresentationUpdateManyMutationInput, PresentationUncheckedUpdateManyInput>
    /**
     * Filter which Presentations to update
     */
    where?: PresentationWhereInput
    /**
     * Limit how many Presentations to update.
     */
    limit?: number
  }

  /**
   * Presentation updateManyAndReturn
   */
  export type PresentationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * The data used to update Presentations.
     */
    data: XOR<PresentationUpdateManyMutationInput, PresentationUncheckedUpdateManyInput>
    /**
     * Filter which Presentations to update
     */
    where?: PresentationWhereInput
    /**
     * Limit how many Presentations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Presentation upsert
   */
  export type PresentationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * The filter to search for the Presentation to update in case it exists.
     */
    where: PresentationWhereUniqueInput
    /**
     * In case the Presentation found by the `where` argument doesn't exist, create a new Presentation with this data.
     */
    create: XOR<PresentationCreateInput, PresentationUncheckedCreateInput>
    /**
     * In case the Presentation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresentationUpdateInput, PresentationUncheckedUpdateInput>
  }

  /**
   * Presentation delete
   */
  export type PresentationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    /**
     * Filter which Presentation to delete.
     */
    where: PresentationWhereUniqueInput
  }

  /**
   * Presentation deleteMany
   */
  export type PresentationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Presentations to delete
     */
    where?: PresentationWhereInput
    /**
     * Limit how many Presentations to delete.
     */
    limit?: number
  }

  /**
   * Presentation.section
   */
  export type Presentation$sectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
  }

  /**
   * Presentation.authors
   */
  export type Presentation$authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    where?: PresentationAuthorWhereInput
    orderBy?: PresentationAuthorOrderByWithRelationInput | PresentationAuthorOrderByWithRelationInput[]
    cursor?: PresentationAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationAuthorScalarFieldEnum | PresentationAuthorScalarFieldEnum[]
  }

  /**
   * Presentation.category
   */
  export type Presentation$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Presentation.presentationType
   */
  export type Presentation$presentationTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    where?: PresentationTypeWhereInput
  }

  /**
   * Presentation.timeSlot
   */
  export type Presentation$timeSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    where?: TimeSlotWhereInput
  }

  /**
   * Presentation.feedback
   */
  export type Presentation$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    where?: PresentationFeedbackWhereInput
    orderBy?: PresentationFeedbackOrderByWithRelationInput | PresentationFeedbackOrderByWithRelationInput[]
    cursor?: PresentationFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationFeedbackScalarFieldEnum | PresentationFeedbackScalarFieldEnum[]
  }

  /**
   * Presentation without action
   */
  export type PresentationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
  }


  /**
   * Model PresentationAuthor
   */

  export type AggregatePresentationAuthor = {
    _count: PresentationAuthorCountAggregateOutputType | null
    _avg: PresentationAuthorAvgAggregateOutputType | null
    _sum: PresentationAuthorSumAggregateOutputType | null
    _min: PresentationAuthorMinAggregateOutputType | null
    _max: PresentationAuthorMaxAggregateOutputType | null
  }

  export type PresentationAuthorAvgAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
  }

  export type PresentationAuthorSumAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
  }

  export type PresentationAuthorMinAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
    authorName: string | null
    authorEmail: string | null
    affiliation: string | null
    isPresenter: boolean | null
    isExternal: boolean | null
  }

  export type PresentationAuthorMaxAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
    authorName: string | null
    authorEmail: string | null
    affiliation: string | null
    isPresenter: boolean | null
    isExternal: boolean | null
  }

  export type PresentationAuthorCountAggregateOutputType = {
    id: number
    presentationId: number
    userId: number
    authorName: number
    authorEmail: number
    affiliation: number
    isPresenter: number
    isExternal: number
    _all: number
  }


  export type PresentationAuthorAvgAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
  }

  export type PresentationAuthorSumAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
  }

  export type PresentationAuthorMinAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    authorName?: true
    authorEmail?: true
    affiliation?: true
    isPresenter?: true
    isExternal?: true
  }

  export type PresentationAuthorMaxAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    authorName?: true
    authorEmail?: true
    affiliation?: true
    isPresenter?: true
    isExternal?: true
  }

  export type PresentationAuthorCountAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    authorName?: true
    authorEmail?: true
    affiliation?: true
    isPresenter?: true
    isExternal?: true
    _all?: true
  }

  export type PresentationAuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresentationAuthor to aggregate.
     */
    where?: PresentationAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationAuthors to fetch.
     */
    orderBy?: PresentationAuthorOrderByWithRelationInput | PresentationAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresentationAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PresentationAuthors
    **/
    _count?: true | PresentationAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresentationAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresentationAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresentationAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresentationAuthorMaxAggregateInputType
  }

  export type GetPresentationAuthorAggregateType<T extends PresentationAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentationAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentationAuthor[P]>
      : GetScalarType<T[P], AggregatePresentationAuthor[P]>
  }




  export type PresentationAuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationAuthorWhereInput
    orderBy?: PresentationAuthorOrderByWithAggregationInput | PresentationAuthorOrderByWithAggregationInput[]
    by: PresentationAuthorScalarFieldEnum[] | PresentationAuthorScalarFieldEnum
    having?: PresentationAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresentationAuthorCountAggregateInputType | true
    _avg?: PresentationAuthorAvgAggregateInputType
    _sum?: PresentationAuthorSumAggregateInputType
    _min?: PresentationAuthorMinAggregateInputType
    _max?: PresentationAuthorMaxAggregateInputType
  }

  export type PresentationAuthorGroupByOutputType = {
    id: number
    presentationId: number
    userId: number | null
    authorName: string
    authorEmail: string | null
    affiliation: string | null
    isPresenter: boolean
    isExternal: boolean
    _count: PresentationAuthorCountAggregateOutputType | null
    _avg: PresentationAuthorAvgAggregateOutputType | null
    _sum: PresentationAuthorSumAggregateOutputType | null
    _min: PresentationAuthorMinAggregateOutputType | null
    _max: PresentationAuthorMaxAggregateOutputType | null
  }

  type GetPresentationAuthorGroupByPayload<T extends PresentationAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresentationAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresentationAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresentationAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], PresentationAuthorGroupByOutputType[P]>
        }
      >
    >


  export type PresentationAuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    authorName?: boolean
    authorEmail?: boolean
    affiliation?: boolean
    isPresenter?: boolean
    isExternal?: boolean
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | PresentationAuthor$userArgs<ExtArgs>
  }, ExtArgs["result"]["presentationAuthor"]>

  export type PresentationAuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    authorName?: boolean
    authorEmail?: boolean
    affiliation?: boolean
    isPresenter?: boolean
    isExternal?: boolean
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | PresentationAuthor$userArgs<ExtArgs>
  }, ExtArgs["result"]["presentationAuthor"]>

  export type PresentationAuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    authorName?: boolean
    authorEmail?: boolean
    affiliation?: boolean
    isPresenter?: boolean
    isExternal?: boolean
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | PresentationAuthor$userArgs<ExtArgs>
  }, ExtArgs["result"]["presentationAuthor"]>

  export type PresentationAuthorSelectScalar = {
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    authorName?: boolean
    authorEmail?: boolean
    affiliation?: boolean
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type PresentationAuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "presentationId" | "userId" | "authorName" | "authorEmail" | "affiliation" | "isPresenter" | "isExternal", ExtArgs["result"]["presentationAuthor"]>
  export type PresentationAuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | PresentationAuthor$userArgs<ExtArgs>
  }
  export type PresentationAuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | PresentationAuthor$userArgs<ExtArgs>
  }
  export type PresentationAuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | PresentationAuthor$userArgs<ExtArgs>
  }

  export type $PresentationAuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PresentationAuthor"
    objects: {
      presentation: Prisma.$PresentationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      presentationId: number
      userId: number | null
      authorName: string
      authorEmail: string | null
      affiliation: string | null
      isPresenter: boolean
      isExternal: boolean
    }, ExtArgs["result"]["presentationAuthor"]>
    composites: {}
  }

  type PresentationAuthorGetPayload<S extends boolean | null | undefined | PresentationAuthorDefaultArgs> = $Result.GetResult<Prisma.$PresentationAuthorPayload, S>

  type PresentationAuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresentationAuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresentationAuthorCountAggregateInputType | true
    }

  export interface PresentationAuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PresentationAuthor'], meta: { name: 'PresentationAuthor' } }
    /**
     * Find zero or one PresentationAuthor that matches the filter.
     * @param {PresentationAuthorFindUniqueArgs} args - Arguments to find a PresentationAuthor
     * @example
     * // Get one PresentationAuthor
     * const presentationAuthor = await prisma.presentationAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresentationAuthorFindUniqueArgs>(args: SelectSubset<T, PresentationAuthorFindUniqueArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PresentationAuthor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresentationAuthorFindUniqueOrThrowArgs} args - Arguments to find a PresentationAuthor
     * @example
     * // Get one PresentationAuthor
     * const presentationAuthor = await prisma.presentationAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresentationAuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, PresentationAuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresentationAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorFindFirstArgs} args - Arguments to find a PresentationAuthor
     * @example
     * // Get one PresentationAuthor
     * const presentationAuthor = await prisma.presentationAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresentationAuthorFindFirstArgs>(args?: SelectSubset<T, PresentationAuthorFindFirstArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresentationAuthor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorFindFirstOrThrowArgs} args - Arguments to find a PresentationAuthor
     * @example
     * // Get one PresentationAuthor
     * const presentationAuthor = await prisma.presentationAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresentationAuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, PresentationAuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PresentationAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PresentationAuthors
     * const presentationAuthors = await prisma.presentationAuthor.findMany()
     * 
     * // Get first 10 PresentationAuthors
     * const presentationAuthors = await prisma.presentationAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presentationAuthorWithIdOnly = await prisma.presentationAuthor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresentationAuthorFindManyArgs>(args?: SelectSubset<T, PresentationAuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PresentationAuthor.
     * @param {PresentationAuthorCreateArgs} args - Arguments to create a PresentationAuthor.
     * @example
     * // Create one PresentationAuthor
     * const PresentationAuthor = await prisma.presentationAuthor.create({
     *   data: {
     *     // ... data to create a PresentationAuthor
     *   }
     * })
     * 
     */
    create<T extends PresentationAuthorCreateArgs>(args: SelectSubset<T, PresentationAuthorCreateArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PresentationAuthors.
     * @param {PresentationAuthorCreateManyArgs} args - Arguments to create many PresentationAuthors.
     * @example
     * // Create many PresentationAuthors
     * const presentationAuthor = await prisma.presentationAuthor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresentationAuthorCreateManyArgs>(args?: SelectSubset<T, PresentationAuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PresentationAuthors and returns the data saved in the database.
     * @param {PresentationAuthorCreateManyAndReturnArgs} args - Arguments to create many PresentationAuthors.
     * @example
     * // Create many PresentationAuthors
     * const presentationAuthor = await prisma.presentationAuthor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PresentationAuthors and only return the `id`
     * const presentationAuthorWithIdOnly = await prisma.presentationAuthor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresentationAuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, PresentationAuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PresentationAuthor.
     * @param {PresentationAuthorDeleteArgs} args - Arguments to delete one PresentationAuthor.
     * @example
     * // Delete one PresentationAuthor
     * const PresentationAuthor = await prisma.presentationAuthor.delete({
     *   where: {
     *     // ... filter to delete one PresentationAuthor
     *   }
     * })
     * 
     */
    delete<T extends PresentationAuthorDeleteArgs>(args: SelectSubset<T, PresentationAuthorDeleteArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PresentationAuthor.
     * @param {PresentationAuthorUpdateArgs} args - Arguments to update one PresentationAuthor.
     * @example
     * // Update one PresentationAuthor
     * const presentationAuthor = await prisma.presentationAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresentationAuthorUpdateArgs>(args: SelectSubset<T, PresentationAuthorUpdateArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PresentationAuthors.
     * @param {PresentationAuthorDeleteManyArgs} args - Arguments to filter PresentationAuthors to delete.
     * @example
     * // Delete a few PresentationAuthors
     * const { count } = await prisma.presentationAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresentationAuthorDeleteManyArgs>(args?: SelectSubset<T, PresentationAuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresentationAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PresentationAuthors
     * const presentationAuthor = await prisma.presentationAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresentationAuthorUpdateManyArgs>(args: SelectSubset<T, PresentationAuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresentationAuthors and returns the data updated in the database.
     * @param {PresentationAuthorUpdateManyAndReturnArgs} args - Arguments to update many PresentationAuthors.
     * @example
     * // Update many PresentationAuthors
     * const presentationAuthor = await prisma.presentationAuthor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PresentationAuthors and only return the `id`
     * const presentationAuthorWithIdOnly = await prisma.presentationAuthor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresentationAuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, PresentationAuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PresentationAuthor.
     * @param {PresentationAuthorUpsertArgs} args - Arguments to update or create a PresentationAuthor.
     * @example
     * // Update or create a PresentationAuthor
     * const presentationAuthor = await prisma.presentationAuthor.upsert({
     *   create: {
     *     // ... data to create a PresentationAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PresentationAuthor we want to update
     *   }
     * })
     */
    upsert<T extends PresentationAuthorUpsertArgs>(args: SelectSubset<T, PresentationAuthorUpsertArgs<ExtArgs>>): Prisma__PresentationAuthorClient<$Result.GetResult<Prisma.$PresentationAuthorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PresentationAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorCountArgs} args - Arguments to filter PresentationAuthors to count.
     * @example
     * // Count the number of PresentationAuthors
     * const count = await prisma.presentationAuthor.count({
     *   where: {
     *     // ... the filter for the PresentationAuthors we want to count
     *   }
     * })
    **/
    count<T extends PresentationAuthorCountArgs>(
      args?: Subset<T, PresentationAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresentationAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PresentationAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresentationAuthorAggregateArgs>(args: Subset<T, PresentationAuthorAggregateArgs>): Prisma.PrismaPromise<GetPresentationAuthorAggregateType<T>>

    /**
     * Group by PresentationAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresentationAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresentationAuthorGroupByArgs['orderBy'] }
        : { orderBy?: PresentationAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresentationAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentationAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PresentationAuthor model
   */
  readonly fields: PresentationAuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PresentationAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresentationAuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    presentation<T extends PresentationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PresentationDefaultArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends PresentationAuthor$userArgs<ExtArgs> = {}>(args?: Subset<T, PresentationAuthor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PresentationAuthor model
   */
  interface PresentationAuthorFieldRefs {
    readonly id: FieldRef<"PresentationAuthor", 'Int'>
    readonly presentationId: FieldRef<"PresentationAuthor", 'Int'>
    readonly userId: FieldRef<"PresentationAuthor", 'Int'>
    readonly authorName: FieldRef<"PresentationAuthor", 'String'>
    readonly authorEmail: FieldRef<"PresentationAuthor", 'String'>
    readonly affiliation: FieldRef<"PresentationAuthor", 'String'>
    readonly isPresenter: FieldRef<"PresentationAuthor", 'Boolean'>
    readonly isExternal: FieldRef<"PresentationAuthor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PresentationAuthor findUnique
   */
  export type PresentationAuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PresentationAuthor to fetch.
     */
    where: PresentationAuthorWhereUniqueInput
  }

  /**
   * PresentationAuthor findUniqueOrThrow
   */
  export type PresentationAuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PresentationAuthor to fetch.
     */
    where: PresentationAuthorWhereUniqueInput
  }

  /**
   * PresentationAuthor findFirst
   */
  export type PresentationAuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PresentationAuthor to fetch.
     */
    where?: PresentationAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationAuthors to fetch.
     */
    orderBy?: PresentationAuthorOrderByWithRelationInput | PresentationAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresentationAuthors.
     */
    cursor?: PresentationAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresentationAuthors.
     */
    distinct?: PresentationAuthorScalarFieldEnum | PresentationAuthorScalarFieldEnum[]
  }

  /**
   * PresentationAuthor findFirstOrThrow
   */
  export type PresentationAuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PresentationAuthor to fetch.
     */
    where?: PresentationAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationAuthors to fetch.
     */
    orderBy?: PresentationAuthorOrderByWithRelationInput | PresentationAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresentationAuthors.
     */
    cursor?: PresentationAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresentationAuthors.
     */
    distinct?: PresentationAuthorScalarFieldEnum | PresentationAuthorScalarFieldEnum[]
  }

  /**
   * PresentationAuthor findMany
   */
  export type PresentationAuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PresentationAuthors to fetch.
     */
    where?: PresentationAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationAuthors to fetch.
     */
    orderBy?: PresentationAuthorOrderByWithRelationInput | PresentationAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PresentationAuthors.
     */
    cursor?: PresentationAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationAuthors.
     */
    skip?: number
    distinct?: PresentationAuthorScalarFieldEnum | PresentationAuthorScalarFieldEnum[]
  }

  /**
   * PresentationAuthor create
   */
  export type PresentationAuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a PresentationAuthor.
     */
    data: XOR<PresentationAuthorCreateInput, PresentationAuthorUncheckedCreateInput>
  }

  /**
   * PresentationAuthor createMany
   */
  export type PresentationAuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PresentationAuthors.
     */
    data: PresentationAuthorCreateManyInput | PresentationAuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PresentationAuthor createManyAndReturn
   */
  export type PresentationAuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * The data used to create many PresentationAuthors.
     */
    data: PresentationAuthorCreateManyInput | PresentationAuthorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresentationAuthor update
   */
  export type PresentationAuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a PresentationAuthor.
     */
    data: XOR<PresentationAuthorUpdateInput, PresentationAuthorUncheckedUpdateInput>
    /**
     * Choose, which PresentationAuthor to update.
     */
    where: PresentationAuthorWhereUniqueInput
  }

  /**
   * PresentationAuthor updateMany
   */
  export type PresentationAuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PresentationAuthors.
     */
    data: XOR<PresentationAuthorUpdateManyMutationInput, PresentationAuthorUncheckedUpdateManyInput>
    /**
     * Filter which PresentationAuthors to update
     */
    where?: PresentationAuthorWhereInput
    /**
     * Limit how many PresentationAuthors to update.
     */
    limit?: number
  }

  /**
   * PresentationAuthor updateManyAndReturn
   */
  export type PresentationAuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * The data used to update PresentationAuthors.
     */
    data: XOR<PresentationAuthorUpdateManyMutationInput, PresentationAuthorUncheckedUpdateManyInput>
    /**
     * Filter which PresentationAuthors to update
     */
    where?: PresentationAuthorWhereInput
    /**
     * Limit how many PresentationAuthors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresentationAuthor upsert
   */
  export type PresentationAuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the PresentationAuthor to update in case it exists.
     */
    where: PresentationAuthorWhereUniqueInput
    /**
     * In case the PresentationAuthor found by the `where` argument doesn't exist, create a new PresentationAuthor with this data.
     */
    create: XOR<PresentationAuthorCreateInput, PresentationAuthorUncheckedCreateInput>
    /**
     * In case the PresentationAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresentationAuthorUpdateInput, PresentationAuthorUncheckedUpdateInput>
  }

  /**
   * PresentationAuthor delete
   */
  export type PresentationAuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
    /**
     * Filter which PresentationAuthor to delete.
     */
    where: PresentationAuthorWhereUniqueInput
  }

  /**
   * PresentationAuthor deleteMany
   */
  export type PresentationAuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresentationAuthors to delete
     */
    where?: PresentationAuthorWhereInput
    /**
     * Limit how many PresentationAuthors to delete.
     */
    limit?: number
  }

  /**
   * PresentationAuthor.user
   */
  export type PresentationAuthor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PresentationAuthor without action
   */
  export type PresentationAuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationAuthor
     */
    select?: PresentationAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationAuthor
     */
    omit?: PresentationAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationAuthorInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    order: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    order: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    conferenceId: number | null
    order: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    conferenceId: number | null
    order: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    conferenceId: number
    order: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    order?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    conferenceId?: true
    order?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    conferenceId?: true
    order?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    conferenceId?: true
    order?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    conferenceId?: true
    order?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    conferenceId: number
    order: number
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    conferenceId?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentations?: boolean | Category$presentationsArgs<ExtArgs>
    sections?: boolean | Category$sectionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    conferenceId?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    conferenceId?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    conferenceId?: boolean
    order?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "conferenceId" | "order", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentations?: boolean | Category$presentationsArgs<ExtArgs>
    sections?: boolean | Category$sectionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      presentations: Prisma.$PresentationPayload<ExtArgs>[]
      sections: Prisma.$SectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      conferenceId: number
      order: number
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    presentations<T extends Category$presentationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$presentationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends Category$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly conferenceId: FieldRef<"Category", 'Int'>
    readonly order: FieldRef<"Category", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.presentations
   */
  export type Category$presentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    where?: PresentationWhereInput
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    cursor?: PresentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * Category.sections
   */
  export type Category$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model PresentationType
   */

  export type AggregatePresentationType = {
    _count: PresentationTypeCountAggregateOutputType | null
    _avg: PresentationTypeAvgAggregateOutputType | null
    _sum: PresentationTypeSumAggregateOutputType | null
    _min: PresentationTypeMinAggregateOutputType | null
    _max: PresentationTypeMaxAggregateOutputType | null
  }

  export type PresentationTypeAvgAggregateOutputType = {
    id: number | null
    defaultDuration: number | null
    conferenceId: number | null
    order: number | null
  }

  export type PresentationTypeSumAggregateOutputType = {
    id: number | null
    defaultDuration: number | null
    conferenceId: number | null
    order: number | null
  }

  export type PresentationTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    defaultDuration: number | null
    conferenceId: number | null
    order: number | null
  }

  export type PresentationTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    defaultDuration: number | null
    conferenceId: number | null
    order: number | null
  }

  export type PresentationTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    defaultDuration: number
    conferenceId: number
    order: number
    _all: number
  }


  export type PresentationTypeAvgAggregateInputType = {
    id?: true
    defaultDuration?: true
    conferenceId?: true
    order?: true
  }

  export type PresentationTypeSumAggregateInputType = {
    id?: true
    defaultDuration?: true
    conferenceId?: true
    order?: true
  }

  export type PresentationTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultDuration?: true
    conferenceId?: true
    order?: true
  }

  export type PresentationTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultDuration?: true
    conferenceId?: true
    order?: true
  }

  export type PresentationTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultDuration?: true
    conferenceId?: true
    order?: true
    _all?: true
  }

  export type PresentationTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresentationType to aggregate.
     */
    where?: PresentationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationTypes to fetch.
     */
    orderBy?: PresentationTypeOrderByWithRelationInput | PresentationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresentationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PresentationTypes
    **/
    _count?: true | PresentationTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresentationTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresentationTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresentationTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresentationTypeMaxAggregateInputType
  }

  export type GetPresentationTypeAggregateType<T extends PresentationTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentationType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentationType[P]>
      : GetScalarType<T[P], AggregatePresentationType[P]>
  }




  export type PresentationTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationTypeWhereInput
    orderBy?: PresentationTypeOrderByWithAggregationInput | PresentationTypeOrderByWithAggregationInput[]
    by: PresentationTypeScalarFieldEnum[] | PresentationTypeScalarFieldEnum
    having?: PresentationTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresentationTypeCountAggregateInputType | true
    _avg?: PresentationTypeAvgAggregateInputType
    _sum?: PresentationTypeSumAggregateInputType
    _min?: PresentationTypeMinAggregateInputType
    _max?: PresentationTypeMaxAggregateInputType
  }

  export type PresentationTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    defaultDuration: number
    conferenceId: number
    order: number
    _count: PresentationTypeCountAggregateOutputType | null
    _avg: PresentationTypeAvgAggregateOutputType | null
    _sum: PresentationTypeSumAggregateOutputType | null
    _min: PresentationTypeMinAggregateOutputType | null
    _max: PresentationTypeMaxAggregateOutputType | null
  }

  type GetPresentationTypeGroupByPayload<T extends PresentationTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresentationTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresentationTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresentationTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PresentationTypeGroupByOutputType[P]>
        }
      >
    >


  export type PresentationTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDuration?: boolean
    conferenceId?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentations?: boolean | PresentationType$presentationsArgs<ExtArgs>
    abstractSubmissions?: boolean | PresentationType$abstractSubmissionsArgs<ExtArgs>
    _count?: boolean | PresentationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentationType"]>

  export type PresentationTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDuration?: boolean
    conferenceId?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentationType"]>

  export type PresentationTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDuration?: boolean
    conferenceId?: boolean
    order?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentationType"]>

  export type PresentationTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDuration?: boolean
    conferenceId?: boolean
    order?: boolean
  }

  export type PresentationTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "defaultDuration" | "conferenceId" | "order", ExtArgs["result"]["presentationType"]>
  export type PresentationTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    presentations?: boolean | PresentationType$presentationsArgs<ExtArgs>
    abstractSubmissions?: boolean | PresentationType$abstractSubmissionsArgs<ExtArgs>
    _count?: boolean | PresentationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PresentationTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }
  export type PresentationTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }

  export type $PresentationTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PresentationType"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      presentations: Prisma.$PresentationPayload<ExtArgs>[]
      abstractSubmissions: Prisma.$AbstractSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      defaultDuration: number
      conferenceId: number
      order: number
    }, ExtArgs["result"]["presentationType"]>
    composites: {}
  }

  type PresentationTypeGetPayload<S extends boolean | null | undefined | PresentationTypeDefaultArgs> = $Result.GetResult<Prisma.$PresentationTypePayload, S>

  type PresentationTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresentationTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresentationTypeCountAggregateInputType | true
    }

  export interface PresentationTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PresentationType'], meta: { name: 'PresentationType' } }
    /**
     * Find zero or one PresentationType that matches the filter.
     * @param {PresentationTypeFindUniqueArgs} args - Arguments to find a PresentationType
     * @example
     * // Get one PresentationType
     * const presentationType = await prisma.presentationType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresentationTypeFindUniqueArgs>(args: SelectSubset<T, PresentationTypeFindUniqueArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PresentationType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresentationTypeFindUniqueOrThrowArgs} args - Arguments to find a PresentationType
     * @example
     * // Get one PresentationType
     * const presentationType = await prisma.presentationType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresentationTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PresentationTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresentationType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeFindFirstArgs} args - Arguments to find a PresentationType
     * @example
     * // Get one PresentationType
     * const presentationType = await prisma.presentationType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresentationTypeFindFirstArgs>(args?: SelectSubset<T, PresentationTypeFindFirstArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresentationType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeFindFirstOrThrowArgs} args - Arguments to find a PresentationType
     * @example
     * // Get one PresentationType
     * const presentationType = await prisma.presentationType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresentationTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PresentationTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PresentationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PresentationTypes
     * const presentationTypes = await prisma.presentationType.findMany()
     * 
     * // Get first 10 PresentationTypes
     * const presentationTypes = await prisma.presentationType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presentationTypeWithIdOnly = await prisma.presentationType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresentationTypeFindManyArgs>(args?: SelectSubset<T, PresentationTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PresentationType.
     * @param {PresentationTypeCreateArgs} args - Arguments to create a PresentationType.
     * @example
     * // Create one PresentationType
     * const PresentationType = await prisma.presentationType.create({
     *   data: {
     *     // ... data to create a PresentationType
     *   }
     * })
     * 
     */
    create<T extends PresentationTypeCreateArgs>(args: SelectSubset<T, PresentationTypeCreateArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PresentationTypes.
     * @param {PresentationTypeCreateManyArgs} args - Arguments to create many PresentationTypes.
     * @example
     * // Create many PresentationTypes
     * const presentationType = await prisma.presentationType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresentationTypeCreateManyArgs>(args?: SelectSubset<T, PresentationTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PresentationTypes and returns the data saved in the database.
     * @param {PresentationTypeCreateManyAndReturnArgs} args - Arguments to create many PresentationTypes.
     * @example
     * // Create many PresentationTypes
     * const presentationType = await prisma.presentationType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PresentationTypes and only return the `id`
     * const presentationTypeWithIdOnly = await prisma.presentationType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresentationTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PresentationTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PresentationType.
     * @param {PresentationTypeDeleteArgs} args - Arguments to delete one PresentationType.
     * @example
     * // Delete one PresentationType
     * const PresentationType = await prisma.presentationType.delete({
     *   where: {
     *     // ... filter to delete one PresentationType
     *   }
     * })
     * 
     */
    delete<T extends PresentationTypeDeleteArgs>(args: SelectSubset<T, PresentationTypeDeleteArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PresentationType.
     * @param {PresentationTypeUpdateArgs} args - Arguments to update one PresentationType.
     * @example
     * // Update one PresentationType
     * const presentationType = await prisma.presentationType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresentationTypeUpdateArgs>(args: SelectSubset<T, PresentationTypeUpdateArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PresentationTypes.
     * @param {PresentationTypeDeleteManyArgs} args - Arguments to filter PresentationTypes to delete.
     * @example
     * // Delete a few PresentationTypes
     * const { count } = await prisma.presentationType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresentationTypeDeleteManyArgs>(args?: SelectSubset<T, PresentationTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresentationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PresentationTypes
     * const presentationType = await prisma.presentationType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresentationTypeUpdateManyArgs>(args: SelectSubset<T, PresentationTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresentationTypes and returns the data updated in the database.
     * @param {PresentationTypeUpdateManyAndReturnArgs} args - Arguments to update many PresentationTypes.
     * @example
     * // Update many PresentationTypes
     * const presentationType = await prisma.presentationType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PresentationTypes and only return the `id`
     * const presentationTypeWithIdOnly = await prisma.presentationType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresentationTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PresentationTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PresentationType.
     * @param {PresentationTypeUpsertArgs} args - Arguments to update or create a PresentationType.
     * @example
     * // Update or create a PresentationType
     * const presentationType = await prisma.presentationType.upsert({
     *   create: {
     *     // ... data to create a PresentationType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PresentationType we want to update
     *   }
     * })
     */
    upsert<T extends PresentationTypeUpsertArgs>(args: SelectSubset<T, PresentationTypeUpsertArgs<ExtArgs>>): Prisma__PresentationTypeClient<$Result.GetResult<Prisma.$PresentationTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PresentationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeCountArgs} args - Arguments to filter PresentationTypes to count.
     * @example
     * // Count the number of PresentationTypes
     * const count = await prisma.presentationType.count({
     *   where: {
     *     // ... the filter for the PresentationTypes we want to count
     *   }
     * })
    **/
    count<T extends PresentationTypeCountArgs>(
      args?: Subset<T, PresentationTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresentationTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PresentationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresentationTypeAggregateArgs>(args: Subset<T, PresentationTypeAggregateArgs>): Prisma.PrismaPromise<GetPresentationTypeAggregateType<T>>

    /**
     * Group by PresentationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresentationTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresentationTypeGroupByArgs['orderBy'] }
        : { orderBy?: PresentationTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresentationTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentationTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PresentationType model
   */
  readonly fields: PresentationTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PresentationType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresentationTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    presentations<T extends PresentationType$presentationsArgs<ExtArgs> = {}>(args?: Subset<T, PresentationType$presentationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abstractSubmissions<T extends PresentationType$abstractSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, PresentationType$abstractSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbstractSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PresentationType model
   */
  interface PresentationTypeFieldRefs {
    readonly id: FieldRef<"PresentationType", 'Int'>
    readonly name: FieldRef<"PresentationType", 'String'>
    readonly description: FieldRef<"PresentationType", 'String'>
    readonly defaultDuration: FieldRef<"PresentationType", 'Int'>
    readonly conferenceId: FieldRef<"PresentationType", 'Int'>
    readonly order: FieldRef<"PresentationType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PresentationType findUnique
   */
  export type PresentationTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * Filter, which PresentationType to fetch.
     */
    where: PresentationTypeWhereUniqueInput
  }

  /**
   * PresentationType findUniqueOrThrow
   */
  export type PresentationTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * Filter, which PresentationType to fetch.
     */
    where: PresentationTypeWhereUniqueInput
  }

  /**
   * PresentationType findFirst
   */
  export type PresentationTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * Filter, which PresentationType to fetch.
     */
    where?: PresentationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationTypes to fetch.
     */
    orderBy?: PresentationTypeOrderByWithRelationInput | PresentationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresentationTypes.
     */
    cursor?: PresentationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresentationTypes.
     */
    distinct?: PresentationTypeScalarFieldEnum | PresentationTypeScalarFieldEnum[]
  }

  /**
   * PresentationType findFirstOrThrow
   */
  export type PresentationTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * Filter, which PresentationType to fetch.
     */
    where?: PresentationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationTypes to fetch.
     */
    orderBy?: PresentationTypeOrderByWithRelationInput | PresentationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresentationTypes.
     */
    cursor?: PresentationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresentationTypes.
     */
    distinct?: PresentationTypeScalarFieldEnum | PresentationTypeScalarFieldEnum[]
  }

  /**
   * PresentationType findMany
   */
  export type PresentationTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * Filter, which PresentationTypes to fetch.
     */
    where?: PresentationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationTypes to fetch.
     */
    orderBy?: PresentationTypeOrderByWithRelationInput | PresentationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PresentationTypes.
     */
    cursor?: PresentationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationTypes.
     */
    skip?: number
    distinct?: PresentationTypeScalarFieldEnum | PresentationTypeScalarFieldEnum[]
  }

  /**
   * PresentationType create
   */
  export type PresentationTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PresentationType.
     */
    data: XOR<PresentationTypeCreateInput, PresentationTypeUncheckedCreateInput>
  }

  /**
   * PresentationType createMany
   */
  export type PresentationTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PresentationTypes.
     */
    data: PresentationTypeCreateManyInput | PresentationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PresentationType createManyAndReturn
   */
  export type PresentationTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PresentationTypes.
     */
    data: PresentationTypeCreateManyInput | PresentationTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresentationType update
   */
  export type PresentationTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PresentationType.
     */
    data: XOR<PresentationTypeUpdateInput, PresentationTypeUncheckedUpdateInput>
    /**
     * Choose, which PresentationType to update.
     */
    where: PresentationTypeWhereUniqueInput
  }

  /**
   * PresentationType updateMany
   */
  export type PresentationTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PresentationTypes.
     */
    data: XOR<PresentationTypeUpdateManyMutationInput, PresentationTypeUncheckedUpdateManyInput>
    /**
     * Filter which PresentationTypes to update
     */
    where?: PresentationTypeWhereInput
    /**
     * Limit how many PresentationTypes to update.
     */
    limit?: number
  }

  /**
   * PresentationType updateManyAndReturn
   */
  export type PresentationTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * The data used to update PresentationTypes.
     */
    data: XOR<PresentationTypeUpdateManyMutationInput, PresentationTypeUncheckedUpdateManyInput>
    /**
     * Filter which PresentationTypes to update
     */
    where?: PresentationTypeWhereInput
    /**
     * Limit how many PresentationTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresentationType upsert
   */
  export type PresentationTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PresentationType to update in case it exists.
     */
    where: PresentationTypeWhereUniqueInput
    /**
     * In case the PresentationType found by the `where` argument doesn't exist, create a new PresentationType with this data.
     */
    create: XOR<PresentationTypeCreateInput, PresentationTypeUncheckedCreateInput>
    /**
     * In case the PresentationType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresentationTypeUpdateInput, PresentationTypeUncheckedUpdateInput>
  }

  /**
   * PresentationType delete
   */
  export type PresentationTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
    /**
     * Filter which PresentationType to delete.
     */
    where: PresentationTypeWhereUniqueInput
  }

  /**
   * PresentationType deleteMany
   */
  export type PresentationTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresentationTypes to delete
     */
    where?: PresentationTypeWhereInput
    /**
     * Limit how many PresentationTypes to delete.
     */
    limit?: number
  }

  /**
   * PresentationType.presentations
   */
  export type PresentationType$presentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation
     */
    select?: PresentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presentation
     */
    omit?: PresentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationInclude<ExtArgs> | null
    where?: PresentationWhereInput
    orderBy?: PresentationOrderByWithRelationInput | PresentationOrderByWithRelationInput[]
    cursor?: PresentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresentationScalarFieldEnum | PresentationScalarFieldEnum[]
  }

  /**
   * PresentationType.abstractSubmissions
   */
  export type PresentationType$abstractSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbstractSubmission
     */
    select?: AbstractSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbstractSubmission
     */
    omit?: AbstractSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbstractSubmissionInclude<ExtArgs> | null
    where?: AbstractSubmissionWhereInput
    orderBy?: AbstractSubmissionOrderByWithRelationInput | AbstractSubmissionOrderByWithRelationInput[]
    cursor?: AbstractSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbstractSubmissionScalarFieldEnum | AbstractSubmissionScalarFieldEnum[]
  }

  /**
   * PresentationType without action
   */
  export type PresentationTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationType
     */
    select?: PresentationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationType
     */
    omit?: PresentationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationTypeInclude<ExtArgs> | null
  }


  /**
   * Model SubmissionSettings
   */

  export type AggregateSubmissionSettings = {
    _count: SubmissionSettingsCountAggregateOutputType | null
    _avg: SubmissionSettingsAvgAggregateOutputType | null
    _sum: SubmissionSettingsSumAggregateOutputType | null
    _min: SubmissionSettingsMinAggregateOutputType | null
    _max: SubmissionSettingsMaxAggregateOutputType | null
  }

  export type SubmissionSettingsAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    maxFileSize: number | null
    maxCoAuthors: number | null
    minKeywords: number | null
    maxKeywords: number | null
  }

  export type SubmissionSettingsSumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    maxFileSize: number | null
    maxCoAuthors: number | null
    minKeywords: number | null
    maxKeywords: number | null
  }

  export type SubmissionSettingsMinAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    submissionDeadline: Date | null
    requireAbstract: boolean | null
    requireFullPaper: boolean | null
    maxFileSize: number | null
    maxCoAuthors: number | null
    minKeywords: number | null
    maxKeywords: number | null
    enableSubmissions: boolean | null
    sendConfirmationEmail: boolean | null
  }

  export type SubmissionSettingsMaxAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    submissionDeadline: Date | null
    requireAbstract: boolean | null
    requireFullPaper: boolean | null
    maxFileSize: number | null
    maxCoAuthors: number | null
    minKeywords: number | null
    maxKeywords: number | null
    enableSubmissions: boolean | null
    sendConfirmationEmail: boolean | null
  }

  export type SubmissionSettingsCountAggregateOutputType = {
    id: number
    conferenceId: number
    submissionDeadline: number
    requireAbstract: number
    requireFullPaper: number
    allowedFileTypes: number
    maxFileSize: number
    maxCoAuthors: number
    minKeywords: number
    maxKeywords: number
    enableSubmissions: number
    sendConfirmationEmail: number
    _all: number
  }


  export type SubmissionSettingsAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    maxFileSize?: true
    maxCoAuthors?: true
    minKeywords?: true
    maxKeywords?: true
  }

  export type SubmissionSettingsSumAggregateInputType = {
    id?: true
    conferenceId?: true
    maxFileSize?: true
    maxCoAuthors?: true
    minKeywords?: true
    maxKeywords?: true
  }

  export type SubmissionSettingsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    submissionDeadline?: true
    requireAbstract?: true
    requireFullPaper?: true
    maxFileSize?: true
    maxCoAuthors?: true
    minKeywords?: true
    maxKeywords?: true
    enableSubmissions?: true
    sendConfirmationEmail?: true
  }

  export type SubmissionSettingsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    submissionDeadline?: true
    requireAbstract?: true
    requireFullPaper?: true
    maxFileSize?: true
    maxCoAuthors?: true
    minKeywords?: true
    maxKeywords?: true
    enableSubmissions?: true
    sendConfirmationEmail?: true
  }

  export type SubmissionSettingsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    submissionDeadline?: true
    requireAbstract?: true
    requireFullPaper?: true
    allowedFileTypes?: true
    maxFileSize?: true
    maxCoAuthors?: true
    minKeywords?: true
    maxKeywords?: true
    enableSubmissions?: true
    sendConfirmationEmail?: true
    _all?: true
  }

  export type SubmissionSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubmissionSettings to aggregate.
     */
    where?: SubmissionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionSettings to fetch.
     */
    orderBy?: SubmissionSettingsOrderByWithRelationInput | SubmissionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubmissionSettings
    **/
    _count?: true | SubmissionSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionSettingsMaxAggregateInputType
  }

  export type GetSubmissionSettingsAggregateType<T extends SubmissionSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissionSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionSettings[P]>
      : GetScalarType<T[P], AggregateSubmissionSettings[P]>
  }




  export type SubmissionSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionSettingsWhereInput
    orderBy?: SubmissionSettingsOrderByWithAggregationInput | SubmissionSettingsOrderByWithAggregationInput[]
    by: SubmissionSettingsScalarFieldEnum[] | SubmissionSettingsScalarFieldEnum
    having?: SubmissionSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionSettingsCountAggregateInputType | true
    _avg?: SubmissionSettingsAvgAggregateInputType
    _sum?: SubmissionSettingsSumAggregateInputType
    _min?: SubmissionSettingsMinAggregateInputType
    _max?: SubmissionSettingsMaxAggregateInputType
  }

  export type SubmissionSettingsGroupByOutputType = {
    id: number
    conferenceId: number
    submissionDeadline: Date
    requireAbstract: boolean
    requireFullPaper: boolean
    allowedFileTypes: string[]
    maxFileSize: number
    maxCoAuthors: number
    minKeywords: number
    maxKeywords: number
    enableSubmissions: boolean
    sendConfirmationEmail: boolean
    _count: SubmissionSettingsCountAggregateOutputType | null
    _avg: SubmissionSettingsAvgAggregateOutputType | null
    _sum: SubmissionSettingsSumAggregateOutputType | null
    _min: SubmissionSettingsMinAggregateOutputType | null
    _max: SubmissionSettingsMaxAggregateOutputType | null
  }

  type GetSubmissionSettingsGroupByPayload<T extends SubmissionSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    submissionDeadline?: boolean
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxCoAuthors?: boolean
    minKeywords?: boolean
    maxKeywords?: boolean
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionSettings"]>

  export type SubmissionSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    submissionDeadline?: boolean
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxCoAuthors?: boolean
    minKeywords?: boolean
    maxKeywords?: boolean
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionSettings"]>

  export type SubmissionSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    submissionDeadline?: boolean
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxCoAuthors?: boolean
    minKeywords?: boolean
    maxKeywords?: boolean
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionSettings"]>

  export type SubmissionSettingsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    submissionDeadline?: boolean
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxCoAuthors?: boolean
    minKeywords?: boolean
    maxKeywords?: boolean
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
  }

  export type SubmissionSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "submissionDeadline" | "requireAbstract" | "requireFullPaper" | "allowedFileTypes" | "maxFileSize" | "maxCoAuthors" | "minKeywords" | "maxKeywords" | "enableSubmissions" | "sendConfirmationEmail", ExtArgs["result"]["submissionSettings"]>
  export type SubmissionSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }
  export type SubmissionSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }
  export type SubmissionSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
  }

  export type $SubmissionSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubmissionSettings"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conferenceId: number
      submissionDeadline: Date
      requireAbstract: boolean
      requireFullPaper: boolean
      allowedFileTypes: string[]
      maxFileSize: number
      maxCoAuthors: number
      minKeywords: number
      maxKeywords: number
      enableSubmissions: boolean
      sendConfirmationEmail: boolean
    }, ExtArgs["result"]["submissionSettings"]>
    composites: {}
  }

  type SubmissionSettingsGetPayload<S extends boolean | null | undefined | SubmissionSettingsDefaultArgs> = $Result.GetResult<Prisma.$SubmissionSettingsPayload, S>

  type SubmissionSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmissionSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmissionSettingsCountAggregateInputType | true
    }

  export interface SubmissionSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubmissionSettings'], meta: { name: 'SubmissionSettings' } }
    /**
     * Find zero or one SubmissionSettings that matches the filter.
     * @param {SubmissionSettingsFindUniqueArgs} args - Arguments to find a SubmissionSettings
     * @example
     * // Get one SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionSettingsFindUniqueArgs>(args: SelectSubset<T, SubmissionSettingsFindUniqueArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubmissionSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionSettingsFindUniqueOrThrowArgs} args - Arguments to find a SubmissionSettings
     * @example
     * // Get one SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubmissionSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsFindFirstArgs} args - Arguments to find a SubmissionSettings
     * @example
     * // Get one SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionSettingsFindFirstArgs>(args?: SelectSubset<T, SubmissionSettingsFindFirstArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubmissionSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsFindFirstOrThrowArgs} args - Arguments to find a SubmissionSettings
     * @example
     * // Get one SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubmissionSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.findMany()
     * 
     * // Get first 10 SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionSettingsWithIdOnly = await prisma.submissionSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionSettingsFindManyArgs>(args?: SelectSubset<T, SubmissionSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubmissionSettings.
     * @param {SubmissionSettingsCreateArgs} args - Arguments to create a SubmissionSettings.
     * @example
     * // Create one SubmissionSettings
     * const SubmissionSettings = await prisma.submissionSettings.create({
     *   data: {
     *     // ... data to create a SubmissionSettings
     *   }
     * })
     * 
     */
    create<T extends SubmissionSettingsCreateArgs>(args: SelectSubset<T, SubmissionSettingsCreateArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubmissionSettings.
     * @param {SubmissionSettingsCreateManyArgs} args - Arguments to create many SubmissionSettings.
     * @example
     * // Create many SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionSettingsCreateManyArgs>(args?: SelectSubset<T, SubmissionSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubmissionSettings and returns the data saved in the database.
     * @param {SubmissionSettingsCreateManyAndReturnArgs} args - Arguments to create many SubmissionSettings.
     * @example
     * // Create many SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubmissionSettings and only return the `id`
     * const submissionSettingsWithIdOnly = await prisma.submissionSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubmissionSettings.
     * @param {SubmissionSettingsDeleteArgs} args - Arguments to delete one SubmissionSettings.
     * @example
     * // Delete one SubmissionSettings
     * const SubmissionSettings = await prisma.submissionSettings.delete({
     *   where: {
     *     // ... filter to delete one SubmissionSettings
     *   }
     * })
     * 
     */
    delete<T extends SubmissionSettingsDeleteArgs>(args: SelectSubset<T, SubmissionSettingsDeleteArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubmissionSettings.
     * @param {SubmissionSettingsUpdateArgs} args - Arguments to update one SubmissionSettings.
     * @example
     * // Update one SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionSettingsUpdateArgs>(args: SelectSubset<T, SubmissionSettingsUpdateArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubmissionSettings.
     * @param {SubmissionSettingsDeleteManyArgs} args - Arguments to filter SubmissionSettings to delete.
     * @example
     * // Delete a few SubmissionSettings
     * const { count } = await prisma.submissionSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionSettingsDeleteManyArgs>(args?: SelectSubset<T, SubmissionSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionSettingsUpdateManyArgs>(args: SelectSubset<T, SubmissionSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionSettings and returns the data updated in the database.
     * @param {SubmissionSettingsUpdateManyAndReturnArgs} args - Arguments to update many SubmissionSettings.
     * @example
     * // Update many SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubmissionSettings and only return the `id`
     * const submissionSettingsWithIdOnly = await prisma.submissionSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubmissionSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubmissionSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubmissionSettings.
     * @param {SubmissionSettingsUpsertArgs} args - Arguments to update or create a SubmissionSettings.
     * @example
     * // Update or create a SubmissionSettings
     * const submissionSettings = await prisma.submissionSettings.upsert({
     *   create: {
     *     // ... data to create a SubmissionSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionSettings we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionSettingsUpsertArgs>(args: SelectSubset<T, SubmissionSettingsUpsertArgs<ExtArgs>>): Prisma__SubmissionSettingsClient<$Result.GetResult<Prisma.$SubmissionSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubmissionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsCountArgs} args - Arguments to filter SubmissionSettings to count.
     * @example
     * // Count the number of SubmissionSettings
     * const count = await prisma.submissionSettings.count({
     *   where: {
     *     // ... the filter for the SubmissionSettings we want to count
     *   }
     * })
    **/
    count<T extends SubmissionSettingsCountArgs>(
      args?: Subset<T, SubmissionSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubmissionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionSettingsAggregateArgs>(args: Subset<T, SubmissionSettingsAggregateArgs>): Prisma.PrismaPromise<GetSubmissionSettingsAggregateType<T>>

    /**
     * Group by SubmissionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubmissionSettings model
   */
  readonly fields: SubmissionSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubmissionSettings model
   */
  interface SubmissionSettingsFieldRefs {
    readonly id: FieldRef<"SubmissionSettings", 'Int'>
    readonly conferenceId: FieldRef<"SubmissionSettings", 'Int'>
    readonly submissionDeadline: FieldRef<"SubmissionSettings", 'DateTime'>
    readonly requireAbstract: FieldRef<"SubmissionSettings", 'Boolean'>
    readonly requireFullPaper: FieldRef<"SubmissionSettings", 'Boolean'>
    readonly allowedFileTypes: FieldRef<"SubmissionSettings", 'String[]'>
    readonly maxFileSize: FieldRef<"SubmissionSettings", 'Int'>
    readonly maxCoAuthors: FieldRef<"SubmissionSettings", 'Int'>
    readonly minKeywords: FieldRef<"SubmissionSettings", 'Int'>
    readonly maxKeywords: FieldRef<"SubmissionSettings", 'Int'>
    readonly enableSubmissions: FieldRef<"SubmissionSettings", 'Boolean'>
    readonly sendConfirmationEmail: FieldRef<"SubmissionSettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SubmissionSettings findUnique
   */
  export type SubmissionSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionSettings to fetch.
     */
    where: SubmissionSettingsWhereUniqueInput
  }

  /**
   * SubmissionSettings findUniqueOrThrow
   */
  export type SubmissionSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionSettings to fetch.
     */
    where: SubmissionSettingsWhereUniqueInput
  }

  /**
   * SubmissionSettings findFirst
   */
  export type SubmissionSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionSettings to fetch.
     */
    where?: SubmissionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionSettings to fetch.
     */
    orderBy?: SubmissionSettingsOrderByWithRelationInput | SubmissionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionSettings.
     */
    cursor?: SubmissionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionSettings.
     */
    distinct?: SubmissionSettingsScalarFieldEnum | SubmissionSettingsScalarFieldEnum[]
  }

  /**
   * SubmissionSettings findFirstOrThrow
   */
  export type SubmissionSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionSettings to fetch.
     */
    where?: SubmissionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionSettings to fetch.
     */
    orderBy?: SubmissionSettingsOrderByWithRelationInput | SubmissionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionSettings.
     */
    cursor?: SubmissionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionSettings.
     */
    distinct?: SubmissionSettingsScalarFieldEnum | SubmissionSettingsScalarFieldEnum[]
  }

  /**
   * SubmissionSettings findMany
   */
  export type SubmissionSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionSettings to fetch.
     */
    where?: SubmissionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionSettings to fetch.
     */
    orderBy?: SubmissionSettingsOrderByWithRelationInput | SubmissionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubmissionSettings.
     */
    cursor?: SubmissionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionSettings.
     */
    skip?: number
    distinct?: SubmissionSettingsScalarFieldEnum | SubmissionSettingsScalarFieldEnum[]
  }

  /**
   * SubmissionSettings create
   */
  export type SubmissionSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a SubmissionSettings.
     */
    data: XOR<SubmissionSettingsCreateInput, SubmissionSettingsUncheckedCreateInput>
  }

  /**
   * SubmissionSettings createMany
   */
  export type SubmissionSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubmissionSettings.
     */
    data: SubmissionSettingsCreateManyInput | SubmissionSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubmissionSettings createManyAndReturn
   */
  export type SubmissionSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SubmissionSettings.
     */
    data: SubmissionSettingsCreateManyInput | SubmissionSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubmissionSettings update
   */
  export type SubmissionSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a SubmissionSettings.
     */
    data: XOR<SubmissionSettingsUpdateInput, SubmissionSettingsUncheckedUpdateInput>
    /**
     * Choose, which SubmissionSettings to update.
     */
    where: SubmissionSettingsWhereUniqueInput
  }

  /**
   * SubmissionSettings updateMany
   */
  export type SubmissionSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubmissionSettings.
     */
    data: XOR<SubmissionSettingsUpdateManyMutationInput, SubmissionSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionSettings to update
     */
    where?: SubmissionSettingsWhereInput
    /**
     * Limit how many SubmissionSettings to update.
     */
    limit?: number
  }

  /**
   * SubmissionSettings updateManyAndReturn
   */
  export type SubmissionSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SubmissionSettings.
     */
    data: XOR<SubmissionSettingsUpdateManyMutationInput, SubmissionSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionSettings to update
     */
    where?: SubmissionSettingsWhereInput
    /**
     * Limit how many SubmissionSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubmissionSettings upsert
   */
  export type SubmissionSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the SubmissionSettings to update in case it exists.
     */
    where: SubmissionSettingsWhereUniqueInput
    /**
     * In case the SubmissionSettings found by the `where` argument doesn't exist, create a new SubmissionSettings with this data.
     */
    create: XOR<SubmissionSettingsCreateInput, SubmissionSettingsUncheckedCreateInput>
    /**
     * In case the SubmissionSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionSettingsUpdateInput, SubmissionSettingsUncheckedUpdateInput>
  }

  /**
   * SubmissionSettings delete
   */
  export type SubmissionSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
    /**
     * Filter which SubmissionSettings to delete.
     */
    where: SubmissionSettingsWhereUniqueInput
  }

  /**
   * SubmissionSettings deleteMany
   */
  export type SubmissionSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubmissionSettings to delete
     */
    where?: SubmissionSettingsWhereInput
    /**
     * Limit how many SubmissionSettings to delete.
     */
    limit?: number
  }

  /**
   * SubmissionSettings without action
   */
  export type SubmissionSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionSettings
     */
    select?: SubmissionSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionSettings
     */
    omit?: SubmissionSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceFeedback
   */

  export type AggregateConferenceFeedback = {
    _count: ConferenceFeedbackCountAggregateOutputType | null
    _avg: ConferenceFeedbackAvgAggregateOutputType | null
    _sum: ConferenceFeedbackSumAggregateOutputType | null
    _min: ConferenceFeedbackMinAggregateOutputType | null
    _max: ConferenceFeedbackMaxAggregateOutputType | null
  }

  export type ConferenceFeedbackAvgAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
    rating: number | null
  }

  export type ConferenceFeedbackSumAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
    rating: number | null
  }

  export type ConferenceFeedbackMinAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
    rating: number | null
    comments: string | null
    submittedAt: Date | null
  }

  export type ConferenceFeedbackMaxAggregateOutputType = {
    id: number | null
    conferenceId: number | null
    userId: number | null
    rating: number | null
    comments: string | null
    submittedAt: Date | null
  }

  export type ConferenceFeedbackCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    rating: number
    comments: number
    submittedAt: number
    _all: number
  }


  export type ConferenceFeedbackAvgAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    rating?: true
  }

  export type ConferenceFeedbackSumAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    rating?: true
  }

  export type ConferenceFeedbackMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    rating?: true
    comments?: true
    submittedAt?: true
  }

  export type ConferenceFeedbackMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    rating?: true
    comments?: true
    submittedAt?: true
  }

  export type ConferenceFeedbackCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    rating?: true
    comments?: true
    submittedAt?: true
    _all?: true
  }

  export type ConferenceFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFeedback to aggregate.
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbackOrderByWithRelationInput | ConferenceFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceFeedbacks
    **/
    _count?: true | ConferenceFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceFeedbackMaxAggregateInputType
  }

  export type GetConferenceFeedbackAggregateType<T extends ConferenceFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceFeedback[P]>
      : GetScalarType<T[P], AggregateConferenceFeedback[P]>
  }




  export type ConferenceFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbackWhereInput
    orderBy?: ConferenceFeedbackOrderByWithAggregationInput | ConferenceFeedbackOrderByWithAggregationInput[]
    by: ConferenceFeedbackScalarFieldEnum[] | ConferenceFeedbackScalarFieldEnum
    having?: ConferenceFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceFeedbackCountAggregateInputType | true
    _avg?: ConferenceFeedbackAvgAggregateInputType
    _sum?: ConferenceFeedbackSumAggregateInputType
    _min?: ConferenceFeedbackMinAggregateInputType
    _max?: ConferenceFeedbackMaxAggregateInputType
  }

  export type ConferenceFeedbackGroupByOutputType = {
    id: number
    conferenceId: number
    userId: number
    rating: number
    comments: string | null
    submittedAt: Date
    _count: ConferenceFeedbackCountAggregateOutputType | null
    _avg: ConferenceFeedbackAvgAggregateOutputType | null
    _sum: ConferenceFeedbackSumAggregateOutputType | null
    _min: ConferenceFeedbackMinAggregateOutputType | null
    _max: ConferenceFeedbackMaxAggregateOutputType | null
  }

  type GetConferenceFeedbackGroupByPayload<T extends ConferenceFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedback"]>

  export type ConferenceFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedback"]>

  export type ConferenceFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedback"]>

  export type ConferenceFeedbackSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
  }

  export type ConferenceFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "rating" | "comments" | "submittedAt", ExtArgs["result"]["conferenceFeedback"]>
  export type ConferenceFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConferenceFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConferenceFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference?: boolean | ConferenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConferenceFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceFeedback"
    objects: {
      conference: Prisma.$ConferencePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conferenceId: number
      userId: number
      rating: number
      comments: string | null
      submittedAt: Date
    }, ExtArgs["result"]["conferenceFeedback"]>
    composites: {}
  }

  type ConferenceFeedbackGetPayload<S extends boolean | null | undefined | ConferenceFeedbackDefaultArgs> = $Result.GetResult<Prisma.$ConferenceFeedbackPayload, S>

  type ConferenceFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceFeedbackCountAggregateInputType | true
    }

  export interface ConferenceFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceFeedback'], meta: { name: 'ConferenceFeedback' } }
    /**
     * Find zero or one ConferenceFeedback that matches the filter.
     * @param {ConferenceFeedbackFindUniqueArgs} args - Arguments to find a ConferenceFeedback
     * @example
     * // Get one ConferenceFeedback
     * const conferenceFeedback = await prisma.conferenceFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceFeedbackFindUniqueArgs>(args: SelectSubset<T, ConferenceFeedbackFindUniqueArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceFeedbackFindUniqueOrThrowArgs} args - Arguments to find a ConferenceFeedback
     * @example
     * // Get one ConferenceFeedback
     * const conferenceFeedback = await prisma.conferenceFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackFindFirstArgs} args - Arguments to find a ConferenceFeedback
     * @example
     * // Get one ConferenceFeedback
     * const conferenceFeedback = await prisma.conferenceFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceFeedbackFindFirstArgs>(args?: SelectSubset<T, ConferenceFeedbackFindFirstArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackFindFirstOrThrowArgs} args - Arguments to find a ConferenceFeedback
     * @example
     * // Get one ConferenceFeedback
     * const conferenceFeedback = await prisma.conferenceFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedback.findMany()
     * 
     * // Get first 10 ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceFeedbackWithIdOnly = await prisma.conferenceFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceFeedbackFindManyArgs>(args?: SelectSubset<T, ConferenceFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceFeedback.
     * @param {ConferenceFeedbackCreateArgs} args - Arguments to create a ConferenceFeedback.
     * @example
     * // Create one ConferenceFeedback
     * const ConferenceFeedback = await prisma.conferenceFeedback.create({
     *   data: {
     *     // ... data to create a ConferenceFeedback
     *   }
     * })
     * 
     */
    create<T extends ConferenceFeedbackCreateArgs>(args: SelectSubset<T, ConferenceFeedbackCreateArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceFeedbacks.
     * @param {ConferenceFeedbackCreateManyArgs} args - Arguments to create many ConferenceFeedbacks.
     * @example
     * // Create many ConferenceFeedbacks
     * const conferenceFeedback = await prisma.conferenceFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceFeedbackCreateManyArgs>(args?: SelectSubset<T, ConferenceFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceFeedbacks and returns the data saved in the database.
     * @param {ConferenceFeedbackCreateManyAndReturnArgs} args - Arguments to create many ConferenceFeedbacks.
     * @example
     * // Create many ConferenceFeedbacks
     * const conferenceFeedback = await prisma.conferenceFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceFeedbacks and only return the `id`
     * const conferenceFeedbackWithIdOnly = await prisma.conferenceFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceFeedback.
     * @param {ConferenceFeedbackDeleteArgs} args - Arguments to delete one ConferenceFeedback.
     * @example
     * // Delete one ConferenceFeedback
     * const ConferenceFeedback = await prisma.conferenceFeedback.delete({
     *   where: {
     *     // ... filter to delete one ConferenceFeedback
     *   }
     * })
     * 
     */
    delete<T extends ConferenceFeedbackDeleteArgs>(args: SelectSubset<T, ConferenceFeedbackDeleteArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceFeedback.
     * @param {ConferenceFeedbackUpdateArgs} args - Arguments to update one ConferenceFeedback.
     * @example
     * // Update one ConferenceFeedback
     * const conferenceFeedback = await prisma.conferenceFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceFeedbackUpdateArgs>(args: SelectSubset<T, ConferenceFeedbackUpdateArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceFeedbacks.
     * @param {ConferenceFeedbackDeleteManyArgs} args - Arguments to filter ConferenceFeedbacks to delete.
     * @example
     * // Delete a few ConferenceFeedbacks
     * const { count } = await prisma.conferenceFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceFeedbackDeleteManyArgs>(args?: SelectSubset<T, ConferenceFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceFeedbacks
     * const conferenceFeedback = await prisma.conferenceFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceFeedbackUpdateManyArgs>(args: SelectSubset<T, ConferenceFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFeedbacks and returns the data updated in the database.
     * @param {ConferenceFeedbackUpdateManyAndReturnArgs} args - Arguments to update many ConferenceFeedbacks.
     * @example
     * // Update many ConferenceFeedbacks
     * const conferenceFeedback = await prisma.conferenceFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceFeedbacks and only return the `id`
     * const conferenceFeedbackWithIdOnly = await prisma.conferenceFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceFeedback.
     * @param {ConferenceFeedbackUpsertArgs} args - Arguments to update or create a ConferenceFeedback.
     * @example
     * // Update or create a ConferenceFeedback
     * const conferenceFeedback = await prisma.conferenceFeedback.upsert({
     *   create: {
     *     // ... data to create a ConferenceFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceFeedback we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceFeedbackUpsertArgs>(args: SelectSubset<T, ConferenceFeedbackUpsertArgs<ExtArgs>>): Prisma__ConferenceFeedbackClient<$Result.GetResult<Prisma.$ConferenceFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackCountArgs} args - Arguments to filter ConferenceFeedbacks to count.
     * @example
     * // Count the number of ConferenceFeedbacks
     * const count = await prisma.conferenceFeedback.count({
     *   where: {
     *     // ... the filter for the ConferenceFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ConferenceFeedbackCountArgs>(
      args?: Subset<T, ConferenceFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceFeedbackAggregateArgs>(args: Subset<T, ConferenceFeedbackAggregateArgs>): Prisma.PrismaPromise<GetConferenceFeedbackAggregateType<T>>

    /**
     * Group by ConferenceFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceFeedback model
   */
  readonly fields: ConferenceFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference<T extends ConferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceDefaultArgs<ExtArgs>>): Prisma__ConferenceClient<$Result.GetResult<Prisma.$ConferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceFeedback model
   */
  interface ConferenceFeedbackFieldRefs {
    readonly id: FieldRef<"ConferenceFeedback", 'Int'>
    readonly conferenceId: FieldRef<"ConferenceFeedback", 'Int'>
    readonly userId: FieldRef<"ConferenceFeedback", 'Int'>
    readonly rating: FieldRef<"ConferenceFeedback", 'Int'>
    readonly comments: FieldRef<"ConferenceFeedback", 'String'>
    readonly submittedAt: FieldRef<"ConferenceFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceFeedback findUnique
   */
  export type ConferenceFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedback to fetch.
     */
    where: ConferenceFeedbackWhereUniqueInput
  }

  /**
   * ConferenceFeedback findUniqueOrThrow
   */
  export type ConferenceFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedback to fetch.
     */
    where: ConferenceFeedbackWhereUniqueInput
  }

  /**
   * ConferenceFeedback findFirst
   */
  export type ConferenceFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedback to fetch.
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbackOrderByWithRelationInput | ConferenceFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFeedbacks.
     */
    distinct?: ConferenceFeedbackScalarFieldEnum | ConferenceFeedbackScalarFieldEnum[]
  }

  /**
   * ConferenceFeedback findFirstOrThrow
   */
  export type ConferenceFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedback to fetch.
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbackOrderByWithRelationInput | ConferenceFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFeedbacks.
     */
    distinct?: ConferenceFeedbackScalarFieldEnum | ConferenceFeedbackScalarFieldEnum[]
  }

  /**
   * ConferenceFeedback findMany
   */
  export type ConferenceFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbackOrderByWithRelationInput | ConferenceFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    distinct?: ConferenceFeedbackScalarFieldEnum | ConferenceFeedbackScalarFieldEnum[]
  }

  /**
   * ConferenceFeedback create
   */
  export type ConferenceFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceFeedback.
     */
    data: XOR<ConferenceFeedbackCreateInput, ConferenceFeedbackUncheckedCreateInput>
  }

  /**
   * ConferenceFeedback createMany
   */
  export type ConferenceFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceFeedbacks.
     */
    data: ConferenceFeedbackCreateManyInput | ConferenceFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceFeedback createManyAndReturn
   */
  export type ConferenceFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceFeedbacks.
     */
    data: ConferenceFeedbackCreateManyInput | ConferenceFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFeedback update
   */
  export type ConferenceFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceFeedback.
     */
    data: XOR<ConferenceFeedbackUpdateInput, ConferenceFeedbackUncheckedUpdateInput>
    /**
     * Choose, which ConferenceFeedback to update.
     */
    where: ConferenceFeedbackWhereUniqueInput
  }

  /**
   * ConferenceFeedback updateMany
   */
  export type ConferenceFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbackUpdateManyMutationInput, ConferenceFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFeedbacks to update
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * Limit how many ConferenceFeedbacks to update.
     */
    limit?: number
  }

  /**
   * ConferenceFeedback updateManyAndReturn
   */
  export type ConferenceFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbackUpdateManyMutationInput, ConferenceFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFeedbacks to update
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * Limit how many ConferenceFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFeedback upsert
   */
  export type ConferenceFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceFeedback to update in case it exists.
     */
    where: ConferenceFeedbackWhereUniqueInput
    /**
     * In case the ConferenceFeedback found by the `where` argument doesn't exist, create a new ConferenceFeedback with this data.
     */
    create: XOR<ConferenceFeedbackCreateInput, ConferenceFeedbackUncheckedCreateInput>
    /**
     * In case the ConferenceFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceFeedbackUpdateInput, ConferenceFeedbackUncheckedUpdateInput>
  }

  /**
   * ConferenceFeedback delete
   */
  export type ConferenceFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
    /**
     * Filter which ConferenceFeedback to delete.
     */
    where: ConferenceFeedbackWhereUniqueInput
  }

  /**
   * ConferenceFeedback deleteMany
   */
  export type ConferenceFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFeedbacks to delete
     */
    where?: ConferenceFeedbackWhereInput
    /**
     * Limit how many ConferenceFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * ConferenceFeedback without action
   */
  export type ConferenceFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedback
     */
    select?: ConferenceFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedback
     */
    omit?: ConferenceFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model PresentationFeedback
   */

  export type AggregatePresentationFeedback = {
    _count: PresentationFeedbackCountAggregateOutputType | null
    _avg: PresentationFeedbackAvgAggregateOutputType | null
    _sum: PresentationFeedbackSumAggregateOutputType | null
    _min: PresentationFeedbackMinAggregateOutputType | null
    _max: PresentationFeedbackMaxAggregateOutputType | null
  }

  export type PresentationFeedbackAvgAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
    rating: number | null
  }

  export type PresentationFeedbackSumAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
    rating: number | null
  }

  export type PresentationFeedbackMinAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
    rating: number | null
    comments: string | null
    submittedAt: Date | null
  }

  export type PresentationFeedbackMaxAggregateOutputType = {
    id: number | null
    presentationId: number | null
    userId: number | null
    rating: number | null
    comments: string | null
    submittedAt: Date | null
  }

  export type PresentationFeedbackCountAggregateOutputType = {
    id: number
    presentationId: number
    userId: number
    rating: number
    comments: number
    submittedAt: number
    _all: number
  }


  export type PresentationFeedbackAvgAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    rating?: true
  }

  export type PresentationFeedbackSumAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    rating?: true
  }

  export type PresentationFeedbackMinAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    rating?: true
    comments?: true
    submittedAt?: true
  }

  export type PresentationFeedbackMaxAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    rating?: true
    comments?: true
    submittedAt?: true
  }

  export type PresentationFeedbackCountAggregateInputType = {
    id?: true
    presentationId?: true
    userId?: true
    rating?: true
    comments?: true
    submittedAt?: true
    _all?: true
  }

  export type PresentationFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresentationFeedback to aggregate.
     */
    where?: PresentationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationFeedbacks to fetch.
     */
    orderBy?: PresentationFeedbackOrderByWithRelationInput | PresentationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresentationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PresentationFeedbacks
    **/
    _count?: true | PresentationFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresentationFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresentationFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresentationFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresentationFeedbackMaxAggregateInputType
  }

  export type GetPresentationFeedbackAggregateType<T extends PresentationFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentationFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentationFeedback[P]>
      : GetScalarType<T[P], AggregatePresentationFeedback[P]>
  }




  export type PresentationFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresentationFeedbackWhereInput
    orderBy?: PresentationFeedbackOrderByWithAggregationInput | PresentationFeedbackOrderByWithAggregationInput[]
    by: PresentationFeedbackScalarFieldEnum[] | PresentationFeedbackScalarFieldEnum
    having?: PresentationFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresentationFeedbackCountAggregateInputType | true
    _avg?: PresentationFeedbackAvgAggregateInputType
    _sum?: PresentationFeedbackSumAggregateInputType
    _min?: PresentationFeedbackMinAggregateInputType
    _max?: PresentationFeedbackMaxAggregateInputType
  }

  export type PresentationFeedbackGroupByOutputType = {
    id: number
    presentationId: number
    userId: number
    rating: number
    comments: string | null
    submittedAt: Date
    _count: PresentationFeedbackCountAggregateOutputType | null
    _avg: PresentationFeedbackAvgAggregateOutputType | null
    _sum: PresentationFeedbackSumAggregateOutputType | null
    _min: PresentationFeedbackMinAggregateOutputType | null
    _max: PresentationFeedbackMaxAggregateOutputType | null
  }

  type GetPresentationFeedbackGroupByPayload<T extends PresentationFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresentationFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresentationFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresentationFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], PresentationFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type PresentationFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentationFeedback"]>

  export type PresentationFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentationFeedback"]>

  export type PresentationFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presentationFeedback"]>

  export type PresentationFeedbackSelectScalar = {
    id?: boolean
    presentationId?: boolean
    userId?: boolean
    rating?: boolean
    comments?: boolean
    submittedAt?: boolean
  }

  export type PresentationFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "presentationId" | "userId" | "rating" | "comments" | "submittedAt", ExtArgs["result"]["presentationFeedback"]>
  export type PresentationFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PresentationFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PresentationFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presentation?: boolean | PresentationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PresentationFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PresentationFeedback"
    objects: {
      presentation: Prisma.$PresentationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      presentationId: number
      userId: number
      rating: number
      comments: string | null
      submittedAt: Date
    }, ExtArgs["result"]["presentationFeedback"]>
    composites: {}
  }

  type PresentationFeedbackGetPayload<S extends boolean | null | undefined | PresentationFeedbackDefaultArgs> = $Result.GetResult<Prisma.$PresentationFeedbackPayload, S>

  type PresentationFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresentationFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresentationFeedbackCountAggregateInputType | true
    }

  export interface PresentationFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PresentationFeedback'], meta: { name: 'PresentationFeedback' } }
    /**
     * Find zero or one PresentationFeedback that matches the filter.
     * @param {PresentationFeedbackFindUniqueArgs} args - Arguments to find a PresentationFeedback
     * @example
     * // Get one PresentationFeedback
     * const presentationFeedback = await prisma.presentationFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresentationFeedbackFindUniqueArgs>(args: SelectSubset<T, PresentationFeedbackFindUniqueArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PresentationFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresentationFeedbackFindUniqueOrThrowArgs} args - Arguments to find a PresentationFeedback
     * @example
     * // Get one PresentationFeedback
     * const presentationFeedback = await prisma.presentationFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresentationFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, PresentationFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresentationFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackFindFirstArgs} args - Arguments to find a PresentationFeedback
     * @example
     * // Get one PresentationFeedback
     * const presentationFeedback = await prisma.presentationFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresentationFeedbackFindFirstArgs>(args?: SelectSubset<T, PresentationFeedbackFindFirstArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresentationFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackFindFirstOrThrowArgs} args - Arguments to find a PresentationFeedback
     * @example
     * // Get one PresentationFeedback
     * const presentationFeedback = await prisma.presentationFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresentationFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, PresentationFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PresentationFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PresentationFeedbacks
     * const presentationFeedbacks = await prisma.presentationFeedback.findMany()
     * 
     * // Get first 10 PresentationFeedbacks
     * const presentationFeedbacks = await prisma.presentationFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presentationFeedbackWithIdOnly = await prisma.presentationFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresentationFeedbackFindManyArgs>(args?: SelectSubset<T, PresentationFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PresentationFeedback.
     * @param {PresentationFeedbackCreateArgs} args - Arguments to create a PresentationFeedback.
     * @example
     * // Create one PresentationFeedback
     * const PresentationFeedback = await prisma.presentationFeedback.create({
     *   data: {
     *     // ... data to create a PresentationFeedback
     *   }
     * })
     * 
     */
    create<T extends PresentationFeedbackCreateArgs>(args: SelectSubset<T, PresentationFeedbackCreateArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PresentationFeedbacks.
     * @param {PresentationFeedbackCreateManyArgs} args - Arguments to create many PresentationFeedbacks.
     * @example
     * // Create many PresentationFeedbacks
     * const presentationFeedback = await prisma.presentationFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresentationFeedbackCreateManyArgs>(args?: SelectSubset<T, PresentationFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PresentationFeedbacks and returns the data saved in the database.
     * @param {PresentationFeedbackCreateManyAndReturnArgs} args - Arguments to create many PresentationFeedbacks.
     * @example
     * // Create many PresentationFeedbacks
     * const presentationFeedback = await prisma.presentationFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PresentationFeedbacks and only return the `id`
     * const presentationFeedbackWithIdOnly = await prisma.presentationFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresentationFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, PresentationFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PresentationFeedback.
     * @param {PresentationFeedbackDeleteArgs} args - Arguments to delete one PresentationFeedback.
     * @example
     * // Delete one PresentationFeedback
     * const PresentationFeedback = await prisma.presentationFeedback.delete({
     *   where: {
     *     // ... filter to delete one PresentationFeedback
     *   }
     * })
     * 
     */
    delete<T extends PresentationFeedbackDeleteArgs>(args: SelectSubset<T, PresentationFeedbackDeleteArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PresentationFeedback.
     * @param {PresentationFeedbackUpdateArgs} args - Arguments to update one PresentationFeedback.
     * @example
     * // Update one PresentationFeedback
     * const presentationFeedback = await prisma.presentationFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresentationFeedbackUpdateArgs>(args: SelectSubset<T, PresentationFeedbackUpdateArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PresentationFeedbacks.
     * @param {PresentationFeedbackDeleteManyArgs} args - Arguments to filter PresentationFeedbacks to delete.
     * @example
     * // Delete a few PresentationFeedbacks
     * const { count } = await prisma.presentationFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresentationFeedbackDeleteManyArgs>(args?: SelectSubset<T, PresentationFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresentationFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PresentationFeedbacks
     * const presentationFeedback = await prisma.presentationFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresentationFeedbackUpdateManyArgs>(args: SelectSubset<T, PresentationFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresentationFeedbacks and returns the data updated in the database.
     * @param {PresentationFeedbackUpdateManyAndReturnArgs} args - Arguments to update many PresentationFeedbacks.
     * @example
     * // Update many PresentationFeedbacks
     * const presentationFeedback = await prisma.presentationFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PresentationFeedbacks and only return the `id`
     * const presentationFeedbackWithIdOnly = await prisma.presentationFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresentationFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, PresentationFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PresentationFeedback.
     * @param {PresentationFeedbackUpsertArgs} args - Arguments to update or create a PresentationFeedback.
     * @example
     * // Update or create a PresentationFeedback
     * const presentationFeedback = await prisma.presentationFeedback.upsert({
     *   create: {
     *     // ... data to create a PresentationFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PresentationFeedback we want to update
     *   }
     * })
     */
    upsert<T extends PresentationFeedbackUpsertArgs>(args: SelectSubset<T, PresentationFeedbackUpsertArgs<ExtArgs>>): Prisma__PresentationFeedbackClient<$Result.GetResult<Prisma.$PresentationFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PresentationFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackCountArgs} args - Arguments to filter PresentationFeedbacks to count.
     * @example
     * // Count the number of PresentationFeedbacks
     * const count = await prisma.presentationFeedback.count({
     *   where: {
     *     // ... the filter for the PresentationFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends PresentationFeedbackCountArgs>(
      args?: Subset<T, PresentationFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresentationFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PresentationFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresentationFeedbackAggregateArgs>(args: Subset<T, PresentationFeedbackAggregateArgs>): Prisma.PrismaPromise<GetPresentationFeedbackAggregateType<T>>

    /**
     * Group by PresentationFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresentationFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresentationFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: PresentationFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresentationFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentationFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PresentationFeedback model
   */
  readonly fields: PresentationFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PresentationFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresentationFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    presentation<T extends PresentationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PresentationDefaultArgs<ExtArgs>>): Prisma__PresentationClient<$Result.GetResult<Prisma.$PresentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PresentationFeedback model
   */
  interface PresentationFeedbackFieldRefs {
    readonly id: FieldRef<"PresentationFeedback", 'Int'>
    readonly presentationId: FieldRef<"PresentationFeedback", 'Int'>
    readonly userId: FieldRef<"PresentationFeedback", 'Int'>
    readonly rating: FieldRef<"PresentationFeedback", 'Int'>
    readonly comments: FieldRef<"PresentationFeedback", 'String'>
    readonly submittedAt: FieldRef<"PresentationFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PresentationFeedback findUnique
   */
  export type PresentationFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PresentationFeedback to fetch.
     */
    where: PresentationFeedbackWhereUniqueInput
  }

  /**
   * PresentationFeedback findUniqueOrThrow
   */
  export type PresentationFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PresentationFeedback to fetch.
     */
    where: PresentationFeedbackWhereUniqueInput
  }

  /**
   * PresentationFeedback findFirst
   */
  export type PresentationFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PresentationFeedback to fetch.
     */
    where?: PresentationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationFeedbacks to fetch.
     */
    orderBy?: PresentationFeedbackOrderByWithRelationInput | PresentationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresentationFeedbacks.
     */
    cursor?: PresentationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresentationFeedbacks.
     */
    distinct?: PresentationFeedbackScalarFieldEnum | PresentationFeedbackScalarFieldEnum[]
  }

  /**
   * PresentationFeedback findFirstOrThrow
   */
  export type PresentationFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PresentationFeedback to fetch.
     */
    where?: PresentationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationFeedbacks to fetch.
     */
    orderBy?: PresentationFeedbackOrderByWithRelationInput | PresentationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresentationFeedbacks.
     */
    cursor?: PresentationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresentationFeedbacks.
     */
    distinct?: PresentationFeedbackScalarFieldEnum | PresentationFeedbackScalarFieldEnum[]
  }

  /**
   * PresentationFeedback findMany
   */
  export type PresentationFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PresentationFeedbacks to fetch.
     */
    where?: PresentationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresentationFeedbacks to fetch.
     */
    orderBy?: PresentationFeedbackOrderByWithRelationInput | PresentationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PresentationFeedbacks.
     */
    cursor?: PresentationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresentationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresentationFeedbacks.
     */
    skip?: number
    distinct?: PresentationFeedbackScalarFieldEnum | PresentationFeedbackScalarFieldEnum[]
  }

  /**
   * PresentationFeedback create
   */
  export type PresentationFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a PresentationFeedback.
     */
    data: XOR<PresentationFeedbackCreateInput, PresentationFeedbackUncheckedCreateInput>
  }

  /**
   * PresentationFeedback createMany
   */
  export type PresentationFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PresentationFeedbacks.
     */
    data: PresentationFeedbackCreateManyInput | PresentationFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PresentationFeedback createManyAndReturn
   */
  export type PresentationFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many PresentationFeedbacks.
     */
    data: PresentationFeedbackCreateManyInput | PresentationFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresentationFeedback update
   */
  export type PresentationFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a PresentationFeedback.
     */
    data: XOR<PresentationFeedbackUpdateInput, PresentationFeedbackUncheckedUpdateInput>
    /**
     * Choose, which PresentationFeedback to update.
     */
    where: PresentationFeedbackWhereUniqueInput
  }

  /**
   * PresentationFeedback updateMany
   */
  export type PresentationFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PresentationFeedbacks.
     */
    data: XOR<PresentationFeedbackUpdateManyMutationInput, PresentationFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which PresentationFeedbacks to update
     */
    where?: PresentationFeedbackWhereInput
    /**
     * Limit how many PresentationFeedbacks to update.
     */
    limit?: number
  }

  /**
   * PresentationFeedback updateManyAndReturn
   */
  export type PresentationFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update PresentationFeedbacks.
     */
    data: XOR<PresentationFeedbackUpdateManyMutationInput, PresentationFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which PresentationFeedbacks to update
     */
    where?: PresentationFeedbackWhereInput
    /**
     * Limit how many PresentationFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresentationFeedback upsert
   */
  export type PresentationFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the PresentationFeedback to update in case it exists.
     */
    where: PresentationFeedbackWhereUniqueInput
    /**
     * In case the PresentationFeedback found by the `where` argument doesn't exist, create a new PresentationFeedback with this data.
     */
    create: XOR<PresentationFeedbackCreateInput, PresentationFeedbackUncheckedCreateInput>
    /**
     * In case the PresentationFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresentationFeedbackUpdateInput, PresentationFeedbackUncheckedUpdateInput>
  }

  /**
   * PresentationFeedback delete
   */
  export type PresentationFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
    /**
     * Filter which PresentationFeedback to delete.
     */
    where: PresentationFeedbackWhereUniqueInput
  }

  /**
   * PresentationFeedback deleteMany
   */
  export type PresentationFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresentationFeedbacks to delete
     */
    where?: PresentationFeedbackWhereInput
    /**
     * Limit how many PresentationFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * PresentationFeedback without action
   */
  export type PresentationFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresentationFeedback
     */
    select?: PresentationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresentationFeedback
     */
    omit?: PresentationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresentationFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    title: string
    message: string
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      message: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: number | null
    tokenHash: string | null
    userId: number | null
    createdAt: Date | null
    revoked: boolean | null
    expiresAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: number | null
    tokenHash: string | null
    userId: number | null
    createdAt: Date | null
    revoked: boolean | null
    expiresAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    tokenHash: number
    userId: number
    createdAt: number
    revoked: number
    expiresAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    tokenHash?: true
    userId?: true
    createdAt?: true
    revoked?: true
    expiresAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    tokenHash?: true
    userId?: true
    createdAt?: true
    revoked?: true
    expiresAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    tokenHash?: true
    userId?: true
    createdAt?: true
    revoked?: true
    expiresAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: number
    tokenHash: string
    userId: number
    createdAt: Date
    revoked: boolean
    expiresAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    userId?: boolean
    createdAt?: boolean
    revoked?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    userId?: boolean
    createdAt?: boolean
    revoked?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    userId?: boolean
    createdAt?: boolean
    revoked?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    tokenHash?: boolean
    userId?: boolean
    createdAt?: boolean
    revoked?: boolean
    expiresAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenHash" | "userId" | "createdAt" | "revoked" | "expiresAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tokenHash: string
      userId: number
      createdAt: Date
      revoked: boolean
      expiresAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'Int'>
    readonly tokenHash: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    cognitoId: 'cognitoId',
    name: 'name',
    email: 'email',
    password: 'password',
    roles: 'roles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ConferenceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    status: 'status',
    topics: 'topics',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceScalarFieldEnum = (typeof ConferenceScalarFieldEnum)[keyof typeof ConferenceScalarFieldEnum]


  export const ConferenceMemberScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    isAttendee: 'isAttendee',
    isSpeaker: 'isSpeaker',
    registeredAt: 'registeredAt'
  };

  export type ConferenceMemberScalarFieldEnum = (typeof ConferenceMemberScalarFieldEnum)[keyof typeof ConferenceMemberScalarFieldEnum]


  export const DayScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    date: 'date',
    name: 'name',
    order: 'order'
  };

  export type DayScalarFieldEnum = (typeof DayScalarFieldEnum)[keyof typeof DayScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    conferenceId: 'conferenceId',
    dayId: 'dayId',
    type: 'type',
    categoryId: 'categoryId',
    room: 'room',
    capacity: 'capacity',
    description: 'description'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const TimeSlotScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    startTime: 'startTime',
    endTime: 'endTime',
    slotType: 'slotType',
    isOccupied: 'isOccupied',
    presentationId: 'presentationId',
    title: 'title',
    breakType: 'breakType',
    description: 'description'
  };

  export type TimeSlotScalarFieldEnum = (typeof TimeSlotScalarFieldEnum)[keyof typeof TimeSlotScalarFieldEnum]


  export const AbstractSubmissionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    abstractText: 'abstractText',
    fileUrl: 'fileUrl',
    submitterId: 'submitterId',
    conferenceId: 'conferenceId',
    status: 'status',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    presentationTypeId: 'presentationTypeId'
  };

  export type AbstractSubmissionScalarFieldEnum = (typeof AbstractSubmissionScalarFieldEnum)[keyof typeof AbstractSubmissionScalarFieldEnum]


  export const AbstractReviewScalarFieldEnum: {
    id: 'id',
    abstractId: 'abstractId',
    reviewerId: 'reviewerId',
    score: 'score',
    comments: 'comments',
    recommendation: 'recommendation'
  };

  export type AbstractReviewScalarFieldEnum = (typeof AbstractReviewScalarFieldEnum)[keyof typeof AbstractReviewScalarFieldEnum]


  export const PresentationScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    title: 'title',
    abstract: 'abstract',
    duration: 'duration',
    status: 'status',
    createdAt: 'createdAt',
    sectionId: 'sectionId',
    categoryId: 'categoryId',
    presentationTypeId: 'presentationTypeId'
  };

  export type PresentationScalarFieldEnum = (typeof PresentationScalarFieldEnum)[keyof typeof PresentationScalarFieldEnum]


  export const PresentationAuthorScalarFieldEnum: {
    id: 'id',
    presentationId: 'presentationId',
    userId: 'userId',
    authorName: 'authorName',
    authorEmail: 'authorEmail',
    affiliation: 'affiliation',
    isPresenter: 'isPresenter',
    isExternal: 'isExternal'
  };

  export type PresentationAuthorScalarFieldEnum = (typeof PresentationAuthorScalarFieldEnum)[keyof typeof PresentationAuthorScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    conferenceId: 'conferenceId',
    order: 'order'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PresentationTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    defaultDuration: 'defaultDuration',
    conferenceId: 'conferenceId',
    order: 'order'
  };

  export type PresentationTypeScalarFieldEnum = (typeof PresentationTypeScalarFieldEnum)[keyof typeof PresentationTypeScalarFieldEnum]


  export const SubmissionSettingsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    submissionDeadline: 'submissionDeadline',
    requireAbstract: 'requireAbstract',
    requireFullPaper: 'requireFullPaper',
    allowedFileTypes: 'allowedFileTypes',
    maxFileSize: 'maxFileSize',
    maxCoAuthors: 'maxCoAuthors',
    minKeywords: 'minKeywords',
    maxKeywords: 'maxKeywords',
    enableSubmissions: 'enableSubmissions',
    sendConfirmationEmail: 'sendConfirmationEmail'
  };

  export type SubmissionSettingsScalarFieldEnum = (typeof SubmissionSettingsScalarFieldEnum)[keyof typeof SubmissionSettingsScalarFieldEnum]


  export const ConferenceFeedbackScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    rating: 'rating',
    comments: 'comments',
    submittedAt: 'submittedAt'
  };

  export type ConferenceFeedbackScalarFieldEnum = (typeof ConferenceFeedbackScalarFieldEnum)[keyof typeof ConferenceFeedbackScalarFieldEnum]


  export const PresentationFeedbackScalarFieldEnum: {
    id: 'id',
    presentationId: 'presentationId',
    userId: 'userId',
    rating: 'rating',
    comments: 'comments',
    submittedAt: 'submittedAt'
  };

  export type PresentationFeedbackScalarFieldEnum = (typeof PresentationFeedbackScalarFieldEnum)[keyof typeof PresentationFeedbackScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    tokenHash: 'tokenHash',
    userId: 'userId',
    createdAt: 'createdAt',
    revoked: 'revoked',
    expiresAt: 'expiresAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ConferenceStatus'
   */
  export type EnumConferenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConferenceStatus'>
    


  /**
   * Reference to a field of type 'ConferenceStatus[]'
   */
  export type ListEnumConferenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConferenceStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SectionType'
   */
  export type EnumSectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SectionType'>
    


  /**
   * Reference to a field of type 'SectionType[]'
   */
  export type ListEnumSectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SectionType[]'>
    


  /**
   * Reference to a field of type 'SlotType'
   */
  export type EnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType'>
    


  /**
   * Reference to a field of type 'SlotType[]'
   */
  export type ListEnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType[]'>
    


  /**
   * Reference to a field of type 'BreakType'
   */
  export type EnumBreakTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BreakType'>
    


  /**
   * Reference to a field of type 'BreakType[]'
   */
  export type ListEnumBreakTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BreakType[]'>
    


  /**
   * Reference to a field of type 'AbstractSubmissionStatus'
   */
  export type EnumAbstractSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbstractSubmissionStatus'>
    


  /**
   * Reference to a field of type 'AbstractSubmissionStatus[]'
   */
  export type ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbstractSubmissionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    cognitoId?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    roles?: EnumRoleNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    conferences?: ConferenceListRelationFilter
    conferenceMembership?: ConferenceMemberListRelationFilter
    abstractSubmissions?: AbstractSubmissionListRelationFilter
    abstractReviews?: AbstractReviewListRelationFilter
    presentations?: PresentationAuthorListRelationFilter
    notifications?: NotificationListRelationFilter
    conferenceFeedback?: ConferenceFeedbackListRelationFilter
    presentationFeedback?: PresentationFeedbackListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    cognitoId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conferences?: ConferenceOrderByRelationAggregateInput
    conferenceMembership?: ConferenceMemberOrderByRelationAggregateInput
    abstractSubmissions?: AbstractSubmissionOrderByRelationAggregateInput
    abstractReviews?: AbstractReviewOrderByRelationAggregateInput
    presentations?: PresentationAuthorOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    conferenceFeedback?: ConferenceFeedbackOrderByRelationAggregateInput
    presentationFeedback?: PresentationFeedbackOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cognitoId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    roles?: EnumRoleNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    conferences?: ConferenceListRelationFilter
    conferenceMembership?: ConferenceMemberListRelationFilter
    abstractSubmissions?: AbstractSubmissionListRelationFilter
    abstractReviews?: AbstractReviewListRelationFilter
    presentations?: PresentationAuthorListRelationFilter
    notifications?: NotificationListRelationFilter
    conferenceFeedback?: ConferenceFeedbackListRelationFilter
    presentationFeedback?: PresentationFeedbackListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }, "id" | "cognitoId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    cognitoId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    cognitoId?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    roles?: EnumRoleNullableListFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ConferenceWhereInput = {
    AND?: ConferenceWhereInput | ConferenceWhereInput[]
    OR?: ConferenceWhereInput[]
    NOT?: ConferenceWhereInput | ConferenceWhereInput[]
    id?: IntFilter<"Conference"> | number
    name?: StringFilter<"Conference"> | string
    description?: StringNullableFilter<"Conference"> | string | null
    startDate?: DateTimeFilter<"Conference"> | Date | string
    endDate?: DateTimeFilter<"Conference"> | Date | string
    location?: StringNullableFilter<"Conference"> | string | null
    status?: EnumConferenceStatusFilter<"Conference"> | $Enums.ConferenceStatus
    topics?: StringNullableListFilter<"Conference">
    createdById?: IntFilter<"Conference"> | number
    createdAt?: DateTimeFilter<"Conference"> | Date | string
    updatedAt?: DateTimeFilter<"Conference"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ConferenceMemberListRelationFilter
    days?: DayListRelationFilter
    sections?: SectionListRelationFilter
    categories?: CategoryListRelationFilter
    presentationTypes?: PresentationTypeListRelationFilter
    submissionSettings?: XOR<SubmissionSettingsNullableScalarRelationFilter, SubmissionSettingsWhereInput> | null
    abstractSubmissions?: AbstractSubmissionListRelationFilter
    presentations?: PresentationListRelationFilter
    feedback?: ConferenceFeedbackListRelationFilter
  }

  export type ConferenceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    topics?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    members?: ConferenceMemberOrderByRelationAggregateInput
    days?: DayOrderByRelationAggregateInput
    sections?: SectionOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    presentationTypes?: PresentationTypeOrderByRelationAggregateInput
    submissionSettings?: SubmissionSettingsOrderByWithRelationInput
    abstractSubmissions?: AbstractSubmissionOrderByRelationAggregateInput
    presentations?: PresentationOrderByRelationAggregateInput
    feedback?: ConferenceFeedbackOrderByRelationAggregateInput
  }

  export type ConferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConferenceWhereInput | ConferenceWhereInput[]
    OR?: ConferenceWhereInput[]
    NOT?: ConferenceWhereInput | ConferenceWhereInput[]
    name?: StringFilter<"Conference"> | string
    description?: StringNullableFilter<"Conference"> | string | null
    startDate?: DateTimeFilter<"Conference"> | Date | string
    endDate?: DateTimeFilter<"Conference"> | Date | string
    location?: StringNullableFilter<"Conference"> | string | null
    status?: EnumConferenceStatusFilter<"Conference"> | $Enums.ConferenceStatus
    topics?: StringNullableListFilter<"Conference">
    createdById?: IntFilter<"Conference"> | number
    createdAt?: DateTimeFilter<"Conference"> | Date | string
    updatedAt?: DateTimeFilter<"Conference"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ConferenceMemberListRelationFilter
    days?: DayListRelationFilter
    sections?: SectionListRelationFilter
    categories?: CategoryListRelationFilter
    presentationTypes?: PresentationTypeListRelationFilter
    submissionSettings?: XOR<SubmissionSettingsNullableScalarRelationFilter, SubmissionSettingsWhereInput> | null
    abstractSubmissions?: AbstractSubmissionListRelationFilter
    presentations?: PresentationListRelationFilter
    feedback?: ConferenceFeedbackListRelationFilter
  }, "id">

  export type ConferenceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    topics?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceCountOrderByAggregateInput
    _avg?: ConferenceAvgOrderByAggregateInput
    _max?: ConferenceMaxOrderByAggregateInput
    _min?: ConferenceMinOrderByAggregateInput
    _sum?: ConferenceSumOrderByAggregateInput
  }

  export type ConferenceScalarWhereWithAggregatesInput = {
    AND?: ConferenceScalarWhereWithAggregatesInput | ConferenceScalarWhereWithAggregatesInput[]
    OR?: ConferenceScalarWhereWithAggregatesInput[]
    NOT?: ConferenceScalarWhereWithAggregatesInput | ConferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conference"> | number
    name?: StringWithAggregatesFilter<"Conference"> | string
    description?: StringNullableWithAggregatesFilter<"Conference"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Conference"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Conference"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Conference"> | string | null
    status?: EnumConferenceStatusWithAggregatesFilter<"Conference"> | $Enums.ConferenceStatus
    topics?: StringNullableListFilter<"Conference">
    createdById?: IntWithAggregatesFilter<"Conference"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Conference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conference"> | Date | string
  }

  export type ConferenceMemberWhereInput = {
    AND?: ConferenceMemberWhereInput | ConferenceMemberWhereInput[]
    OR?: ConferenceMemberWhereInput[]
    NOT?: ConferenceMemberWhereInput | ConferenceMemberWhereInput[]
    id?: IntFilter<"ConferenceMember"> | number
    conferenceId?: IntFilter<"ConferenceMember"> | number
    userId?: IntFilter<"ConferenceMember"> | number
    isAttendee?: BoolFilter<"ConferenceMember"> | boolean
    isSpeaker?: BoolFilter<"ConferenceMember"> | boolean
    registeredAt?: DateTimeFilter<"ConferenceMember"> | Date | string
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ConferenceMemberOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    isAttendee?: SortOrder
    isSpeaker?: SortOrder
    registeredAt?: SortOrder
    conference?: ConferenceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConferenceMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    conferenceId_userId?: ConferenceMemberConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceMemberWhereInput | ConferenceMemberWhereInput[]
    OR?: ConferenceMemberWhereInput[]
    NOT?: ConferenceMemberWhereInput | ConferenceMemberWhereInput[]
    conferenceId?: IntFilter<"ConferenceMember"> | number
    userId?: IntFilter<"ConferenceMember"> | number
    isAttendee?: BoolFilter<"ConferenceMember"> | boolean
    isSpeaker?: BoolFilter<"ConferenceMember"> | boolean
    registeredAt?: DateTimeFilter<"ConferenceMember"> | Date | string
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceMemberOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    isAttendee?: SortOrder
    isSpeaker?: SortOrder
    registeredAt?: SortOrder
    _count?: ConferenceMemberCountOrderByAggregateInput
    _avg?: ConferenceMemberAvgOrderByAggregateInput
    _max?: ConferenceMemberMaxOrderByAggregateInput
    _min?: ConferenceMemberMinOrderByAggregateInput
    _sum?: ConferenceMemberSumOrderByAggregateInput
  }

  export type ConferenceMemberScalarWhereWithAggregatesInput = {
    AND?: ConferenceMemberScalarWhereWithAggregatesInput | ConferenceMemberScalarWhereWithAggregatesInput[]
    OR?: ConferenceMemberScalarWhereWithAggregatesInput[]
    NOT?: ConferenceMemberScalarWhereWithAggregatesInput | ConferenceMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConferenceMember"> | number
    conferenceId?: IntWithAggregatesFilter<"ConferenceMember"> | number
    userId?: IntWithAggregatesFilter<"ConferenceMember"> | number
    isAttendee?: BoolWithAggregatesFilter<"ConferenceMember"> | boolean
    isSpeaker?: BoolWithAggregatesFilter<"ConferenceMember"> | boolean
    registeredAt?: DateTimeWithAggregatesFilter<"ConferenceMember"> | Date | string
  }

  export type DayWhereInput = {
    AND?: DayWhereInput | DayWhereInput[]
    OR?: DayWhereInput[]
    NOT?: DayWhereInput | DayWhereInput[]
    id?: IntFilter<"Day"> | number
    conferenceId?: IntFilter<"Day"> | number
    date?: DateTimeFilter<"Day"> | Date | string
    name?: StringFilter<"Day"> | string
    order?: IntFilter<"Day"> | number
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    sections?: SectionListRelationFilter
  }

  export type DayOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    date?: SortOrder
    name?: SortOrder
    order?: SortOrder
    conference?: ConferenceOrderByWithRelationInput
    sections?: SectionOrderByRelationAggregateInput
  }

  export type DayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    conferenceId_date?: DayConferenceIdDateCompoundUniqueInput
    AND?: DayWhereInput | DayWhereInput[]
    OR?: DayWhereInput[]
    NOT?: DayWhereInput | DayWhereInput[]
    conferenceId?: IntFilter<"Day"> | number
    date?: DateTimeFilter<"Day"> | Date | string
    name?: StringFilter<"Day"> | string
    order?: IntFilter<"Day"> | number
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    sections?: SectionListRelationFilter
  }, "id" | "conferenceId_date">

  export type DayOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    date?: SortOrder
    name?: SortOrder
    order?: SortOrder
    _count?: DayCountOrderByAggregateInput
    _avg?: DayAvgOrderByAggregateInput
    _max?: DayMaxOrderByAggregateInput
    _min?: DayMinOrderByAggregateInput
    _sum?: DaySumOrderByAggregateInput
  }

  export type DayScalarWhereWithAggregatesInput = {
    AND?: DayScalarWhereWithAggregatesInput | DayScalarWhereWithAggregatesInput[]
    OR?: DayScalarWhereWithAggregatesInput[]
    NOT?: DayScalarWhereWithAggregatesInput | DayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Day"> | number
    conferenceId?: IntWithAggregatesFilter<"Day"> | number
    date?: DateTimeWithAggregatesFilter<"Day"> | Date | string
    name?: StringWithAggregatesFilter<"Day"> | string
    order?: IntWithAggregatesFilter<"Day"> | number
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: IntFilter<"Section"> | number
    name?: StringFilter<"Section"> | string
    startTime?: DateTimeNullableFilter<"Section"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Section"> | Date | string | null
    conferenceId?: IntFilter<"Section"> | number
    dayId?: IntNullableFilter<"Section"> | number | null
    type?: EnumSectionTypeFilter<"Section"> | $Enums.SectionType
    categoryId?: IntNullableFilter<"Section"> | number | null
    room?: StringNullableFilter<"Section"> | string | null
    capacity?: IntNullableFilter<"Section"> | number | null
    description?: StringNullableFilter<"Section"> | string | null
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    day?: XOR<DayNullableScalarRelationFilter, DayWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    timeSlots?: TimeSlotListRelationFilter
    presentations?: PresentationListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    conference?: ConferenceOrderByWithRelationInput
    day?: DayOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    timeSlots?: TimeSlotOrderByRelationAggregateInput
    presentations?: PresentationOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    name?: StringFilter<"Section"> | string
    startTime?: DateTimeNullableFilter<"Section"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Section"> | Date | string | null
    conferenceId?: IntFilter<"Section"> | number
    dayId?: IntNullableFilter<"Section"> | number | null
    type?: EnumSectionTypeFilter<"Section"> | $Enums.SectionType
    categoryId?: IntNullableFilter<"Section"> | number | null
    room?: StringNullableFilter<"Section"> | string | null
    capacity?: IntNullableFilter<"Section"> | number | null
    description?: StringNullableFilter<"Section"> | string | null
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    day?: XOR<DayNullableScalarRelationFilter, DayWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    timeSlots?: TimeSlotListRelationFilter
    presentations?: PresentationListRelationFilter
  }, "id">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Section"> | number
    name?: StringWithAggregatesFilter<"Section"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"Section"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Section"> | Date | string | null
    conferenceId?: IntWithAggregatesFilter<"Section"> | number
    dayId?: IntNullableWithAggregatesFilter<"Section"> | number | null
    type?: EnumSectionTypeWithAggregatesFilter<"Section"> | $Enums.SectionType
    categoryId?: IntNullableWithAggregatesFilter<"Section"> | number | null
    room?: StringNullableWithAggregatesFilter<"Section"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"Section"> | number | null
    description?: StringNullableWithAggregatesFilter<"Section"> | string | null
  }

  export type TimeSlotWhereInput = {
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    id?: IntFilter<"TimeSlot"> | number
    sectionId?: IntFilter<"TimeSlot"> | number
    startTime?: DateTimeFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeFilter<"TimeSlot"> | Date | string
    slotType?: EnumSlotTypeFilter<"TimeSlot"> | $Enums.SlotType
    isOccupied?: BoolFilter<"TimeSlot"> | boolean
    presentationId?: IntNullableFilter<"TimeSlot"> | number | null
    title?: StringNullableFilter<"TimeSlot"> | string | null
    breakType?: EnumBreakTypeNullableFilter<"TimeSlot"> | $Enums.BreakType | null
    description?: StringNullableFilter<"TimeSlot"> | string | null
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    presentation?: XOR<PresentationNullableScalarRelationFilter, PresentationWhereInput> | null
  }

  export type TimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    isOccupied?: SortOrder
    presentationId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    breakType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    section?: SectionOrderByWithRelationInput
    presentation?: PresentationOrderByWithRelationInput
  }

  export type TimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    presentationId?: number
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    sectionId?: IntFilter<"TimeSlot"> | number
    startTime?: DateTimeFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeFilter<"TimeSlot"> | Date | string
    slotType?: EnumSlotTypeFilter<"TimeSlot"> | $Enums.SlotType
    isOccupied?: BoolFilter<"TimeSlot"> | boolean
    title?: StringNullableFilter<"TimeSlot"> | string | null
    breakType?: EnumBreakTypeNullableFilter<"TimeSlot"> | $Enums.BreakType | null
    description?: StringNullableFilter<"TimeSlot"> | string | null
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    presentation?: XOR<PresentationNullableScalarRelationFilter, PresentationWhereInput> | null
  }, "id" | "presentationId">

  export type TimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    isOccupied?: SortOrder
    presentationId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    breakType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: TimeSlotCountOrderByAggregateInput
    _avg?: TimeSlotAvgOrderByAggregateInput
    _max?: TimeSlotMaxOrderByAggregateInput
    _min?: TimeSlotMinOrderByAggregateInput
    _sum?: TimeSlotSumOrderByAggregateInput
  }

  export type TimeSlotScalarWhereWithAggregatesInput = {
    AND?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    OR?: TimeSlotScalarWhereWithAggregatesInput[]
    NOT?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TimeSlot"> | number
    sectionId?: IntWithAggregatesFilter<"TimeSlot"> | number
    startTime?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    slotType?: EnumSlotTypeWithAggregatesFilter<"TimeSlot"> | $Enums.SlotType
    isOccupied?: BoolWithAggregatesFilter<"TimeSlot"> | boolean
    presentationId?: IntNullableWithAggregatesFilter<"TimeSlot"> | number | null
    title?: StringNullableWithAggregatesFilter<"TimeSlot"> | string | null
    breakType?: EnumBreakTypeNullableWithAggregatesFilter<"TimeSlot"> | $Enums.BreakType | null
    description?: StringNullableWithAggregatesFilter<"TimeSlot"> | string | null
  }

  export type AbstractSubmissionWhereInput = {
    AND?: AbstractSubmissionWhereInput | AbstractSubmissionWhereInput[]
    OR?: AbstractSubmissionWhereInput[]
    NOT?: AbstractSubmissionWhereInput | AbstractSubmissionWhereInput[]
    id?: IntFilter<"AbstractSubmission"> | number
    title?: StringFilter<"AbstractSubmission"> | string
    abstractText?: StringNullableFilter<"AbstractSubmission"> | string | null
    fileUrl?: StringNullableFilter<"AbstractSubmission"> | string | null
    submitterId?: IntFilter<"AbstractSubmission"> | number
    conferenceId?: IntFilter<"AbstractSubmission"> | number
    status?: EnumAbstractSubmissionStatusFilter<"AbstractSubmission"> | $Enums.AbstractSubmissionStatus
    keywords?: StringNullableListFilter<"AbstractSubmission">
    createdAt?: DateTimeFilter<"AbstractSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AbstractSubmission"> | Date | string
    presentationTypeId?: IntNullableFilter<"AbstractSubmission"> | number | null
    submitter?: XOR<UserScalarRelationFilter, UserWhereInput>
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    reviews?: AbstractReviewListRelationFilter
    presentationType?: XOR<PresentationTypeNullableScalarRelationFilter, PresentationTypeWhereInput> | null
  }

  export type AbstractSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    abstractText?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    presentationTypeId?: SortOrderInput | SortOrder
    submitter?: UserOrderByWithRelationInput
    conference?: ConferenceOrderByWithRelationInput
    reviews?: AbstractReviewOrderByRelationAggregateInput
    presentationType?: PresentationTypeOrderByWithRelationInput
  }

  export type AbstractSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AbstractSubmissionWhereInput | AbstractSubmissionWhereInput[]
    OR?: AbstractSubmissionWhereInput[]
    NOT?: AbstractSubmissionWhereInput | AbstractSubmissionWhereInput[]
    title?: StringFilter<"AbstractSubmission"> | string
    abstractText?: StringNullableFilter<"AbstractSubmission"> | string | null
    fileUrl?: StringNullableFilter<"AbstractSubmission"> | string | null
    submitterId?: IntFilter<"AbstractSubmission"> | number
    conferenceId?: IntFilter<"AbstractSubmission"> | number
    status?: EnumAbstractSubmissionStatusFilter<"AbstractSubmission"> | $Enums.AbstractSubmissionStatus
    keywords?: StringNullableListFilter<"AbstractSubmission">
    createdAt?: DateTimeFilter<"AbstractSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AbstractSubmission"> | Date | string
    presentationTypeId?: IntNullableFilter<"AbstractSubmission"> | number | null
    submitter?: XOR<UserScalarRelationFilter, UserWhereInput>
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    reviews?: AbstractReviewListRelationFilter
    presentationType?: XOR<PresentationTypeNullableScalarRelationFilter, PresentationTypeWhereInput> | null
  }, "id">

  export type AbstractSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    abstractText?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    presentationTypeId?: SortOrderInput | SortOrder
    _count?: AbstractSubmissionCountOrderByAggregateInput
    _avg?: AbstractSubmissionAvgOrderByAggregateInput
    _max?: AbstractSubmissionMaxOrderByAggregateInput
    _min?: AbstractSubmissionMinOrderByAggregateInput
    _sum?: AbstractSubmissionSumOrderByAggregateInput
  }

  export type AbstractSubmissionScalarWhereWithAggregatesInput = {
    AND?: AbstractSubmissionScalarWhereWithAggregatesInput | AbstractSubmissionScalarWhereWithAggregatesInput[]
    OR?: AbstractSubmissionScalarWhereWithAggregatesInput[]
    NOT?: AbstractSubmissionScalarWhereWithAggregatesInput | AbstractSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AbstractSubmission"> | number
    title?: StringWithAggregatesFilter<"AbstractSubmission"> | string
    abstractText?: StringNullableWithAggregatesFilter<"AbstractSubmission"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"AbstractSubmission"> | string | null
    submitterId?: IntWithAggregatesFilter<"AbstractSubmission"> | number
    conferenceId?: IntWithAggregatesFilter<"AbstractSubmission"> | number
    status?: EnumAbstractSubmissionStatusWithAggregatesFilter<"AbstractSubmission"> | $Enums.AbstractSubmissionStatus
    keywords?: StringNullableListFilter<"AbstractSubmission">
    createdAt?: DateTimeWithAggregatesFilter<"AbstractSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AbstractSubmission"> | Date | string
    presentationTypeId?: IntNullableWithAggregatesFilter<"AbstractSubmission"> | number | null
  }

  export type AbstractReviewWhereInput = {
    AND?: AbstractReviewWhereInput | AbstractReviewWhereInput[]
    OR?: AbstractReviewWhereInput[]
    NOT?: AbstractReviewWhereInput | AbstractReviewWhereInput[]
    id?: IntFilter<"AbstractReview"> | number
    abstractId?: IntFilter<"AbstractReview"> | number
    reviewerId?: IntFilter<"AbstractReview"> | number
    score?: IntFilter<"AbstractReview"> | number
    comments?: StringNullableFilter<"AbstractReview"> | string | null
    recommendation?: StringFilter<"AbstractReview"> | string
    abstract?: XOR<AbstractSubmissionScalarRelationFilter, AbstractSubmissionWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AbstractReviewOrderByWithRelationInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
    comments?: SortOrderInput | SortOrder
    recommendation?: SortOrder
    abstract?: AbstractSubmissionOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type AbstractReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AbstractReviewWhereInput | AbstractReviewWhereInput[]
    OR?: AbstractReviewWhereInput[]
    NOT?: AbstractReviewWhereInput | AbstractReviewWhereInput[]
    abstractId?: IntFilter<"AbstractReview"> | number
    reviewerId?: IntFilter<"AbstractReview"> | number
    score?: IntFilter<"AbstractReview"> | number
    comments?: StringNullableFilter<"AbstractReview"> | string | null
    recommendation?: StringFilter<"AbstractReview"> | string
    abstract?: XOR<AbstractSubmissionScalarRelationFilter, AbstractSubmissionWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AbstractReviewOrderByWithAggregationInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
    comments?: SortOrderInput | SortOrder
    recommendation?: SortOrder
    _count?: AbstractReviewCountOrderByAggregateInput
    _avg?: AbstractReviewAvgOrderByAggregateInput
    _max?: AbstractReviewMaxOrderByAggregateInput
    _min?: AbstractReviewMinOrderByAggregateInput
    _sum?: AbstractReviewSumOrderByAggregateInput
  }

  export type AbstractReviewScalarWhereWithAggregatesInput = {
    AND?: AbstractReviewScalarWhereWithAggregatesInput | AbstractReviewScalarWhereWithAggregatesInput[]
    OR?: AbstractReviewScalarWhereWithAggregatesInput[]
    NOT?: AbstractReviewScalarWhereWithAggregatesInput | AbstractReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AbstractReview"> | number
    abstractId?: IntWithAggregatesFilter<"AbstractReview"> | number
    reviewerId?: IntWithAggregatesFilter<"AbstractReview"> | number
    score?: IntWithAggregatesFilter<"AbstractReview"> | number
    comments?: StringNullableWithAggregatesFilter<"AbstractReview"> | string | null
    recommendation?: StringWithAggregatesFilter<"AbstractReview"> | string
  }

  export type PresentationWhereInput = {
    AND?: PresentationWhereInput | PresentationWhereInput[]
    OR?: PresentationWhereInput[]
    NOT?: PresentationWhereInput | PresentationWhereInput[]
    id?: IntFilter<"Presentation"> | number
    conferenceId?: IntFilter<"Presentation"> | number
    title?: StringFilter<"Presentation"> | string
    abstract?: StringNullableFilter<"Presentation"> | string | null
    duration?: IntNullableFilter<"Presentation"> | number | null
    status?: StringFilter<"Presentation"> | string
    createdAt?: DateTimeFilter<"Presentation"> | Date | string
    sectionId?: IntNullableFilter<"Presentation"> | number | null
    categoryId?: IntNullableFilter<"Presentation"> | number | null
    presentationTypeId?: IntNullableFilter<"Presentation"> | number | null
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    section?: XOR<SectionNullableScalarRelationFilter, SectionWhereInput> | null
    authors?: PresentationAuthorListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    presentationType?: XOR<PresentationTypeNullableScalarRelationFilter, PresentationTypeWhereInput> | null
    timeSlot?: XOR<TimeSlotNullableScalarRelationFilter, TimeSlotWhereInput> | null
    feedback?: PresentationFeedbackListRelationFilter
  }

  export type PresentationOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    title?: SortOrder
    abstract?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    sectionId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    presentationTypeId?: SortOrderInput | SortOrder
    conference?: ConferenceOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    authors?: PresentationAuthorOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    presentationType?: PresentationTypeOrderByWithRelationInput
    timeSlot?: TimeSlotOrderByWithRelationInput
    feedback?: PresentationFeedbackOrderByRelationAggregateInput
  }

  export type PresentationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PresentationWhereInput | PresentationWhereInput[]
    OR?: PresentationWhereInput[]
    NOT?: PresentationWhereInput | PresentationWhereInput[]
    conferenceId?: IntFilter<"Presentation"> | number
    title?: StringFilter<"Presentation"> | string
    abstract?: StringNullableFilter<"Presentation"> | string | null
    duration?: IntNullableFilter<"Presentation"> | number | null
    status?: StringFilter<"Presentation"> | string
    createdAt?: DateTimeFilter<"Presentation"> | Date | string
    sectionId?: IntNullableFilter<"Presentation"> | number | null
    categoryId?: IntNullableFilter<"Presentation"> | number | null
    presentationTypeId?: IntNullableFilter<"Presentation"> | number | null
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    section?: XOR<SectionNullableScalarRelationFilter, SectionWhereInput> | null
    authors?: PresentationAuthorListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    presentationType?: XOR<PresentationTypeNullableScalarRelationFilter, PresentationTypeWhereInput> | null
    timeSlot?: XOR<TimeSlotNullableScalarRelationFilter, TimeSlotWhereInput> | null
    feedback?: PresentationFeedbackListRelationFilter
  }, "id">

  export type PresentationOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    title?: SortOrder
    abstract?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    sectionId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    presentationTypeId?: SortOrderInput | SortOrder
    _count?: PresentationCountOrderByAggregateInput
    _avg?: PresentationAvgOrderByAggregateInput
    _max?: PresentationMaxOrderByAggregateInput
    _min?: PresentationMinOrderByAggregateInput
    _sum?: PresentationSumOrderByAggregateInput
  }

  export type PresentationScalarWhereWithAggregatesInput = {
    AND?: PresentationScalarWhereWithAggregatesInput | PresentationScalarWhereWithAggregatesInput[]
    OR?: PresentationScalarWhereWithAggregatesInput[]
    NOT?: PresentationScalarWhereWithAggregatesInput | PresentationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Presentation"> | number
    conferenceId?: IntWithAggregatesFilter<"Presentation"> | number
    title?: StringWithAggregatesFilter<"Presentation"> | string
    abstract?: StringNullableWithAggregatesFilter<"Presentation"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Presentation"> | number | null
    status?: StringWithAggregatesFilter<"Presentation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Presentation"> | Date | string
    sectionId?: IntNullableWithAggregatesFilter<"Presentation"> | number | null
    categoryId?: IntNullableWithAggregatesFilter<"Presentation"> | number | null
    presentationTypeId?: IntNullableWithAggregatesFilter<"Presentation"> | number | null
  }

  export type PresentationAuthorWhereInput = {
    AND?: PresentationAuthorWhereInput | PresentationAuthorWhereInput[]
    OR?: PresentationAuthorWhereInput[]
    NOT?: PresentationAuthorWhereInput | PresentationAuthorWhereInput[]
    id?: IntFilter<"PresentationAuthor"> | number
    presentationId?: IntFilter<"PresentationAuthor"> | number
    userId?: IntNullableFilter<"PresentationAuthor"> | number | null
    authorName?: StringFilter<"PresentationAuthor"> | string
    authorEmail?: StringNullableFilter<"PresentationAuthor"> | string | null
    affiliation?: StringNullableFilter<"PresentationAuthor"> | string | null
    isPresenter?: BoolFilter<"PresentationAuthor"> | boolean
    isExternal?: BoolFilter<"PresentationAuthor"> | boolean
    presentation?: XOR<PresentationScalarRelationFilter, PresentationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PresentationAuthorOrderByWithRelationInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    authorName?: SortOrder
    authorEmail?: SortOrderInput | SortOrder
    affiliation?: SortOrderInput | SortOrder
    isPresenter?: SortOrder
    isExternal?: SortOrder
    presentation?: PresentationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PresentationAuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PresentationAuthorWhereInput | PresentationAuthorWhereInput[]
    OR?: PresentationAuthorWhereInput[]
    NOT?: PresentationAuthorWhereInput | PresentationAuthorWhereInput[]
    presentationId?: IntFilter<"PresentationAuthor"> | number
    userId?: IntNullableFilter<"PresentationAuthor"> | number | null
    authorName?: StringFilter<"PresentationAuthor"> | string
    authorEmail?: StringNullableFilter<"PresentationAuthor"> | string | null
    affiliation?: StringNullableFilter<"PresentationAuthor"> | string | null
    isPresenter?: BoolFilter<"PresentationAuthor"> | boolean
    isExternal?: BoolFilter<"PresentationAuthor"> | boolean
    presentation?: XOR<PresentationScalarRelationFilter, PresentationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PresentationAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    authorName?: SortOrder
    authorEmail?: SortOrderInput | SortOrder
    affiliation?: SortOrderInput | SortOrder
    isPresenter?: SortOrder
    isExternal?: SortOrder
    _count?: PresentationAuthorCountOrderByAggregateInput
    _avg?: PresentationAuthorAvgOrderByAggregateInput
    _max?: PresentationAuthorMaxOrderByAggregateInput
    _min?: PresentationAuthorMinOrderByAggregateInput
    _sum?: PresentationAuthorSumOrderByAggregateInput
  }

  export type PresentationAuthorScalarWhereWithAggregatesInput = {
    AND?: PresentationAuthorScalarWhereWithAggregatesInput | PresentationAuthorScalarWhereWithAggregatesInput[]
    OR?: PresentationAuthorScalarWhereWithAggregatesInput[]
    NOT?: PresentationAuthorScalarWhereWithAggregatesInput | PresentationAuthorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PresentationAuthor"> | number
    presentationId?: IntWithAggregatesFilter<"PresentationAuthor"> | number
    userId?: IntNullableWithAggregatesFilter<"PresentationAuthor"> | number | null
    authorName?: StringWithAggregatesFilter<"PresentationAuthor"> | string
    authorEmail?: StringNullableWithAggregatesFilter<"PresentationAuthor"> | string | null
    affiliation?: StringNullableWithAggregatesFilter<"PresentationAuthor"> | string | null
    isPresenter?: BoolWithAggregatesFilter<"PresentationAuthor"> | boolean
    isExternal?: BoolWithAggregatesFilter<"PresentationAuthor"> | boolean
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    conferenceId?: IntFilter<"Category"> | number
    order?: IntFilter<"Category"> | number
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    presentations?: PresentationListRelationFilter
    sections?: SectionListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
    conference?: ConferenceOrderByWithRelationInput
    presentations?: PresentationOrderByRelationAggregateInput
    sections?: SectionOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    conferenceId?: IntFilter<"Category"> | number
    order?: IntFilter<"Category"> | number
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    presentations?: PresentationListRelationFilter
    sections?: SectionListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    conferenceId?: IntWithAggregatesFilter<"Category"> | number
    order?: IntWithAggregatesFilter<"Category"> | number
  }

  export type PresentationTypeWhereInput = {
    AND?: PresentationTypeWhereInput | PresentationTypeWhereInput[]
    OR?: PresentationTypeWhereInput[]
    NOT?: PresentationTypeWhereInput | PresentationTypeWhereInput[]
    id?: IntFilter<"PresentationType"> | number
    name?: StringFilter<"PresentationType"> | string
    description?: StringNullableFilter<"PresentationType"> | string | null
    defaultDuration?: IntFilter<"PresentationType"> | number
    conferenceId?: IntFilter<"PresentationType"> | number
    order?: IntFilter<"PresentationType"> | number
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    presentations?: PresentationListRelationFilter
    abstractSubmissions?: AbstractSubmissionListRelationFilter
  }

  export type PresentationTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
    conference?: ConferenceOrderByWithRelationInput
    presentations?: PresentationOrderByRelationAggregateInput
    abstractSubmissions?: AbstractSubmissionOrderByRelationAggregateInput
  }

  export type PresentationTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PresentationTypeWhereInput | PresentationTypeWhereInput[]
    OR?: PresentationTypeWhereInput[]
    NOT?: PresentationTypeWhereInput | PresentationTypeWhereInput[]
    name?: StringFilter<"PresentationType"> | string
    description?: StringNullableFilter<"PresentationType"> | string | null
    defaultDuration?: IntFilter<"PresentationType"> | number
    conferenceId?: IntFilter<"PresentationType"> | number
    order?: IntFilter<"PresentationType"> | number
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    presentations?: PresentationListRelationFilter
    abstractSubmissions?: AbstractSubmissionListRelationFilter
  }, "id">

  export type PresentationTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
    _count?: PresentationTypeCountOrderByAggregateInput
    _avg?: PresentationTypeAvgOrderByAggregateInput
    _max?: PresentationTypeMaxOrderByAggregateInput
    _min?: PresentationTypeMinOrderByAggregateInput
    _sum?: PresentationTypeSumOrderByAggregateInput
  }

  export type PresentationTypeScalarWhereWithAggregatesInput = {
    AND?: PresentationTypeScalarWhereWithAggregatesInput | PresentationTypeScalarWhereWithAggregatesInput[]
    OR?: PresentationTypeScalarWhereWithAggregatesInput[]
    NOT?: PresentationTypeScalarWhereWithAggregatesInput | PresentationTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PresentationType"> | number
    name?: StringWithAggregatesFilter<"PresentationType"> | string
    description?: StringNullableWithAggregatesFilter<"PresentationType"> | string | null
    defaultDuration?: IntWithAggregatesFilter<"PresentationType"> | number
    conferenceId?: IntWithAggregatesFilter<"PresentationType"> | number
    order?: IntWithAggregatesFilter<"PresentationType"> | number
  }

  export type SubmissionSettingsWhereInput = {
    AND?: SubmissionSettingsWhereInput | SubmissionSettingsWhereInput[]
    OR?: SubmissionSettingsWhereInput[]
    NOT?: SubmissionSettingsWhereInput | SubmissionSettingsWhereInput[]
    id?: IntFilter<"SubmissionSettings"> | number
    conferenceId?: IntFilter<"SubmissionSettings"> | number
    submissionDeadline?: DateTimeFilter<"SubmissionSettings"> | Date | string
    requireAbstract?: BoolFilter<"SubmissionSettings"> | boolean
    requireFullPaper?: BoolFilter<"SubmissionSettings"> | boolean
    allowedFileTypes?: StringNullableListFilter<"SubmissionSettings">
    maxFileSize?: IntFilter<"SubmissionSettings"> | number
    maxCoAuthors?: IntFilter<"SubmissionSettings"> | number
    minKeywords?: IntFilter<"SubmissionSettings"> | number
    maxKeywords?: IntFilter<"SubmissionSettings"> | number
    enableSubmissions?: BoolFilter<"SubmissionSettings"> | boolean
    sendConfirmationEmail?: BoolFilter<"SubmissionSettings"> | boolean
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
  }

  export type SubmissionSettingsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    submissionDeadline?: SortOrder
    requireAbstract?: SortOrder
    requireFullPaper?: SortOrder
    allowedFileTypes?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
    enableSubmissions?: SortOrder
    sendConfirmationEmail?: SortOrder
    conference?: ConferenceOrderByWithRelationInput
  }

  export type SubmissionSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    conferenceId?: number
    AND?: SubmissionSettingsWhereInput | SubmissionSettingsWhereInput[]
    OR?: SubmissionSettingsWhereInput[]
    NOT?: SubmissionSettingsWhereInput | SubmissionSettingsWhereInput[]
    submissionDeadline?: DateTimeFilter<"SubmissionSettings"> | Date | string
    requireAbstract?: BoolFilter<"SubmissionSettings"> | boolean
    requireFullPaper?: BoolFilter<"SubmissionSettings"> | boolean
    allowedFileTypes?: StringNullableListFilter<"SubmissionSettings">
    maxFileSize?: IntFilter<"SubmissionSettings"> | number
    maxCoAuthors?: IntFilter<"SubmissionSettings"> | number
    minKeywords?: IntFilter<"SubmissionSettings"> | number
    maxKeywords?: IntFilter<"SubmissionSettings"> | number
    enableSubmissions?: BoolFilter<"SubmissionSettings"> | boolean
    sendConfirmationEmail?: BoolFilter<"SubmissionSettings"> | boolean
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
  }, "id" | "conferenceId">

  export type SubmissionSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    submissionDeadline?: SortOrder
    requireAbstract?: SortOrder
    requireFullPaper?: SortOrder
    allowedFileTypes?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
    enableSubmissions?: SortOrder
    sendConfirmationEmail?: SortOrder
    _count?: SubmissionSettingsCountOrderByAggregateInput
    _avg?: SubmissionSettingsAvgOrderByAggregateInput
    _max?: SubmissionSettingsMaxOrderByAggregateInput
    _min?: SubmissionSettingsMinOrderByAggregateInput
    _sum?: SubmissionSettingsSumOrderByAggregateInput
  }

  export type SubmissionSettingsScalarWhereWithAggregatesInput = {
    AND?: SubmissionSettingsScalarWhereWithAggregatesInput | SubmissionSettingsScalarWhereWithAggregatesInput[]
    OR?: SubmissionSettingsScalarWhereWithAggregatesInput[]
    NOT?: SubmissionSettingsScalarWhereWithAggregatesInput | SubmissionSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubmissionSettings"> | number
    conferenceId?: IntWithAggregatesFilter<"SubmissionSettings"> | number
    submissionDeadline?: DateTimeWithAggregatesFilter<"SubmissionSettings"> | Date | string
    requireAbstract?: BoolWithAggregatesFilter<"SubmissionSettings"> | boolean
    requireFullPaper?: BoolWithAggregatesFilter<"SubmissionSettings"> | boolean
    allowedFileTypes?: StringNullableListFilter<"SubmissionSettings">
    maxFileSize?: IntWithAggregatesFilter<"SubmissionSettings"> | number
    maxCoAuthors?: IntWithAggregatesFilter<"SubmissionSettings"> | number
    minKeywords?: IntWithAggregatesFilter<"SubmissionSettings"> | number
    maxKeywords?: IntWithAggregatesFilter<"SubmissionSettings"> | number
    enableSubmissions?: BoolWithAggregatesFilter<"SubmissionSettings"> | boolean
    sendConfirmationEmail?: BoolWithAggregatesFilter<"SubmissionSettings"> | boolean
  }

  export type ConferenceFeedbackWhereInput = {
    AND?: ConferenceFeedbackWhereInput | ConferenceFeedbackWhereInput[]
    OR?: ConferenceFeedbackWhereInput[]
    NOT?: ConferenceFeedbackWhereInput | ConferenceFeedbackWhereInput[]
    id?: IntFilter<"ConferenceFeedback"> | number
    conferenceId?: IntFilter<"ConferenceFeedback"> | number
    userId?: IntFilter<"ConferenceFeedback"> | number
    rating?: IntFilter<"ConferenceFeedback"> | number
    comments?: StringNullableFilter<"ConferenceFeedback"> | string | null
    submittedAt?: DateTimeFilter<"ConferenceFeedback"> | Date | string
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ConferenceFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    conference?: ConferenceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConferenceFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConferenceFeedbackWhereInput | ConferenceFeedbackWhereInput[]
    OR?: ConferenceFeedbackWhereInput[]
    NOT?: ConferenceFeedbackWhereInput | ConferenceFeedbackWhereInput[]
    conferenceId?: IntFilter<"ConferenceFeedback"> | number
    userId?: IntFilter<"ConferenceFeedback"> | number
    rating?: IntFilter<"ConferenceFeedback"> | number
    comments?: StringNullableFilter<"ConferenceFeedback"> | string | null
    submittedAt?: DateTimeFilter<"ConferenceFeedback"> | Date | string
    conference?: XOR<ConferenceScalarRelationFilter, ConferenceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ConferenceFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: ConferenceFeedbackCountOrderByAggregateInput
    _avg?: ConferenceFeedbackAvgOrderByAggregateInput
    _max?: ConferenceFeedbackMaxOrderByAggregateInput
    _min?: ConferenceFeedbackMinOrderByAggregateInput
    _sum?: ConferenceFeedbackSumOrderByAggregateInput
  }

  export type ConferenceFeedbackScalarWhereWithAggregatesInput = {
    AND?: ConferenceFeedbackScalarWhereWithAggregatesInput | ConferenceFeedbackScalarWhereWithAggregatesInput[]
    OR?: ConferenceFeedbackScalarWhereWithAggregatesInput[]
    NOT?: ConferenceFeedbackScalarWhereWithAggregatesInput | ConferenceFeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConferenceFeedback"> | number
    conferenceId?: IntWithAggregatesFilter<"ConferenceFeedback"> | number
    userId?: IntWithAggregatesFilter<"ConferenceFeedback"> | number
    rating?: IntWithAggregatesFilter<"ConferenceFeedback"> | number
    comments?: StringNullableWithAggregatesFilter<"ConferenceFeedback"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"ConferenceFeedback"> | Date | string
  }

  export type PresentationFeedbackWhereInput = {
    AND?: PresentationFeedbackWhereInput | PresentationFeedbackWhereInput[]
    OR?: PresentationFeedbackWhereInput[]
    NOT?: PresentationFeedbackWhereInput | PresentationFeedbackWhereInput[]
    id?: IntFilter<"PresentationFeedback"> | number
    presentationId?: IntFilter<"PresentationFeedback"> | number
    userId?: IntFilter<"PresentationFeedback"> | number
    rating?: IntFilter<"PresentationFeedback"> | number
    comments?: StringNullableFilter<"PresentationFeedback"> | string | null
    submittedAt?: DateTimeFilter<"PresentationFeedback"> | Date | string
    presentation?: XOR<PresentationScalarRelationFilter, PresentationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PresentationFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    presentation?: PresentationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PresentationFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PresentationFeedbackWhereInput | PresentationFeedbackWhereInput[]
    OR?: PresentationFeedbackWhereInput[]
    NOT?: PresentationFeedbackWhereInput | PresentationFeedbackWhereInput[]
    presentationId?: IntFilter<"PresentationFeedback"> | number
    userId?: IntFilter<"PresentationFeedback"> | number
    rating?: IntFilter<"PresentationFeedback"> | number
    comments?: StringNullableFilter<"PresentationFeedback"> | string | null
    submittedAt?: DateTimeFilter<"PresentationFeedback"> | Date | string
    presentation?: XOR<PresentationScalarRelationFilter, PresentationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PresentationFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: PresentationFeedbackCountOrderByAggregateInput
    _avg?: PresentationFeedbackAvgOrderByAggregateInput
    _max?: PresentationFeedbackMaxOrderByAggregateInput
    _min?: PresentationFeedbackMinOrderByAggregateInput
    _sum?: PresentationFeedbackSumOrderByAggregateInput
  }

  export type PresentationFeedbackScalarWhereWithAggregatesInput = {
    AND?: PresentationFeedbackScalarWhereWithAggregatesInput | PresentationFeedbackScalarWhereWithAggregatesInput[]
    OR?: PresentationFeedbackScalarWhereWithAggregatesInput[]
    NOT?: PresentationFeedbackScalarWhereWithAggregatesInput | PresentationFeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PresentationFeedback"> | number
    presentationId?: IntWithAggregatesFilter<"PresentationFeedback"> | number
    userId?: IntWithAggregatesFilter<"PresentationFeedback"> | number
    rating?: IntWithAggregatesFilter<"PresentationFeedback"> | number
    comments?: StringNullableWithAggregatesFilter<"PresentationFeedback"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"PresentationFeedback"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    tokenHash?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    tokenHash?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefreshToken"> | number
    tokenHash?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type UserCreateInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCreateInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberCreateInput = {
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutConferenceMembershipInput
  }

  export type ConferenceMemberUncheckedCreateInput = {
    id?: number
    conferenceId: number
    userId: number
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
  }

  export type ConferenceMemberUpdateInput = {
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutConferenceMembershipNestedInput
  }

  export type ConferenceMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberCreateManyInput = {
    id?: number
    conferenceId: number
    userId: number
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
  }

  export type ConferenceMemberUpdateManyMutationInput = {
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayCreateInput = {
    date: Date | string
    name: string
    order?: number
    conference: ConferenceCreateNestedOneWithoutDaysInput
    sections?: SectionCreateNestedManyWithoutDayInput
  }

  export type DayUncheckedCreateInput = {
    id?: number
    conferenceId: number
    date: Date | string
    name: string
    order?: number
    sections?: SectionUncheckedCreateNestedManyWithoutDayInput
  }

  export type DayUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutDaysNestedInput
    sections?: SectionUpdateManyWithoutDayNestedInput
  }

  export type DayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sections?: SectionUncheckedUpdateManyWithoutDayNestedInput
  }

  export type DayCreateManyInput = {
    id?: number
    conferenceId: number
    date: Date | string
    name: string
    order?: number
  }

  export type DayUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SectionCreateInput = {
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    conference: ConferenceCreateNestedOneWithoutSectionsInput
    day?: DayCreateNestedOneWithoutSectionsInput
    category?: CategoryCreateNestedOneWithoutSectionsInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSectionInput
    presentations?: PresentationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    dayId?: number | null
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSectionInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conference?: ConferenceUpdateOneRequiredWithoutSectionsNestedInput
    day?: DayUpdateOneWithoutSectionsNestedInput
    category?: CategoryUpdateOneWithoutSectionsNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    dayId?: number | null
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
  }

  export type SectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSlotCreateInput = {
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
    section: SectionCreateNestedOneWithoutTimeSlotsInput
    presentation?: PresentationCreateNestedOneWithoutTimeSlotInput
  }

  export type TimeSlotUncheckedCreateInput = {
    id?: number
    sectionId: number
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    presentationId?: number | null
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
  }

  export type TimeSlotUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    section?: SectionUpdateOneRequiredWithoutTimeSlotsNestedInput
    presentation?: PresentationUpdateOneWithoutTimeSlotNestedInput
  }

  export type TimeSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    presentationId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSlotCreateManyInput = {
    id?: number
    sectionId: number
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    presentationId?: number | null
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
  }

  export type TimeSlotUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    presentationId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AbstractSubmissionCreateInput = {
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    submitter: UserCreateNestedOneWithoutAbstractSubmissionsInput
    conference: ConferenceCreateNestedOneWithoutAbstractSubmissionsInput
    reviews?: AbstractReviewCreateNestedManyWithoutAbstractInput
    presentationType?: PresentationTypeCreateNestedOneWithoutAbstractSubmissionsInput
  }

  export type AbstractSubmissionUncheckedCreateInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
    reviews?: AbstractReviewUncheckedCreateNestedManyWithoutAbstractInput
  }

  export type AbstractSubmissionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitter?: UserUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    conference?: ConferenceUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    reviews?: AbstractReviewUpdateManyWithoutAbstractNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutAbstractSubmissionsNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: AbstractReviewUncheckedUpdateManyWithoutAbstractNestedInput
  }

  export type AbstractSubmissionCreateManyInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
  }

  export type AbstractSubmissionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbstractSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AbstractReviewCreateInput = {
    score: number
    comments?: string | null
    recommendation: string
    abstract: AbstractSubmissionCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutAbstractReviewsInput
  }

  export type AbstractReviewUncheckedCreateInput = {
    id?: number
    abstractId: number
    reviewerId: number
    score: number
    comments?: string | null
    recommendation: string
  }

  export type AbstractReviewUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
    abstract?: AbstractSubmissionUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutAbstractReviewsNestedInput
  }

  export type AbstractReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    abstractId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type AbstractReviewCreateManyInput = {
    id?: number
    abstractId: number
    reviewerId: number
    score: number
    comments?: string | null
    recommendation: string
  }

  export type AbstractReviewUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type AbstractReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    abstractId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type PresentationCreateInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    section?: SectionCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationCreateManyInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
  }

  export type PresentationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresentationAuthorCreateInput = {
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
    presentation: PresentationCreateNestedOneWithoutAuthorsInput
    user?: UserCreateNestedOneWithoutPresentationsInput
  }

  export type PresentationAuthorUncheckedCreateInput = {
    id?: number
    presentationId: number
    userId?: number | null
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type PresentationAuthorUpdateInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    presentation?: PresentationUpdateOneRequiredWithoutAuthorsNestedInput
    user?: UserUpdateOneWithoutPresentationsNestedInput
  }

  export type PresentationAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PresentationAuthorCreateManyInput = {
    id?: number
    presentationId: number
    userId?: number | null
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type PresentationAuthorUpdateManyMutationInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PresentationAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryCreateInput = {
    name: string
    order?: number
    conference: ConferenceCreateNestedOneWithoutCategoriesInput
    presentations?: PresentationCreateNestedManyWithoutCategoryInput
    sections?: SectionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    conferenceId: number
    order?: number
    presentations?: PresentationUncheckedCreateNestedManyWithoutCategoryInput
    sections?: SectionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutCategoriesNestedInput
    presentations?: PresentationUpdateManyWithoutCategoryNestedInput
    sections?: SectionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUncheckedUpdateManyWithoutCategoryNestedInput
    sections?: SectionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    conferenceId: number
    order?: number
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PresentationTypeCreateInput = {
    name: string
    description?: string | null
    defaultDuration?: number
    order?: number
    conference: ConferenceCreateNestedOneWithoutPresentationTypesInput
    presentations?: PresentationCreateNestedManyWithoutPresentationTypeInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    defaultDuration?: number
    conferenceId: number
    order?: number
    presentations?: PresentationUncheckedCreateNestedManyWithoutPresentationTypeInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutPresentationTypesNestedInput
    presentations?: PresentationUpdateManyWithoutPresentationTypeNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutPresentationTypeNestedInput
  }

  export type PresentationTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUncheckedUpdateManyWithoutPresentationTypeNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutPresentationTypeNestedInput
  }

  export type PresentationTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    defaultDuration?: number
    conferenceId: number
    order?: number
  }

  export type PresentationTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PresentationTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubmissionSettingsCreateInput = {
    submissionDeadline: Date | string
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: SubmissionSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: number
    maxCoAuthors?: number
    minKeywords?: number
    maxKeywords?: number
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
    conference: ConferenceCreateNestedOneWithoutSubmissionSettingsInput
  }

  export type SubmissionSettingsUncheckedCreateInput = {
    id?: number
    conferenceId: number
    submissionDeadline: Date | string
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: SubmissionSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: number
    maxCoAuthors?: number
    minKeywords?: number
    maxKeywords?: number
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
  }

  export type SubmissionSettingsUpdateInput = {
    submissionDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    requireAbstract?: BoolFieldUpdateOperationsInput | boolean
    requireFullPaper?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: SubmissionSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: IntFieldUpdateOperationsInput | number
    maxCoAuthors?: IntFieldUpdateOperationsInput | number
    minKeywords?: IntFieldUpdateOperationsInput | number
    maxKeywords?: IntFieldUpdateOperationsInput | number
    enableSubmissions?: BoolFieldUpdateOperationsInput | boolean
    sendConfirmationEmail?: BoolFieldUpdateOperationsInput | boolean
    conference?: ConferenceUpdateOneRequiredWithoutSubmissionSettingsNestedInput
  }

  export type SubmissionSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    submissionDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    requireAbstract?: BoolFieldUpdateOperationsInput | boolean
    requireFullPaper?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: SubmissionSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: IntFieldUpdateOperationsInput | number
    maxCoAuthors?: IntFieldUpdateOperationsInput | number
    minKeywords?: IntFieldUpdateOperationsInput | number
    maxKeywords?: IntFieldUpdateOperationsInput | number
    enableSubmissions?: BoolFieldUpdateOperationsInput | boolean
    sendConfirmationEmail?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubmissionSettingsCreateManyInput = {
    id?: number
    conferenceId: number
    submissionDeadline: Date | string
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: SubmissionSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: number
    maxCoAuthors?: number
    minKeywords?: number
    maxKeywords?: number
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
  }

  export type SubmissionSettingsUpdateManyMutationInput = {
    submissionDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    requireAbstract?: BoolFieldUpdateOperationsInput | boolean
    requireFullPaper?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: SubmissionSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: IntFieldUpdateOperationsInput | number
    maxCoAuthors?: IntFieldUpdateOperationsInput | number
    minKeywords?: IntFieldUpdateOperationsInput | number
    maxKeywords?: IntFieldUpdateOperationsInput | number
    enableSubmissions?: BoolFieldUpdateOperationsInput | boolean
    sendConfirmationEmail?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubmissionSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    submissionDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    requireAbstract?: BoolFieldUpdateOperationsInput | boolean
    requireFullPaper?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: SubmissionSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: IntFieldUpdateOperationsInput | number
    maxCoAuthors?: IntFieldUpdateOperationsInput | number
    minKeywords?: IntFieldUpdateOperationsInput | number
    maxKeywords?: IntFieldUpdateOperationsInput | number
    enableSubmissions?: BoolFieldUpdateOperationsInput | boolean
    sendConfirmationEmail?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceFeedbackCreateInput = {
    rating: number
    comments?: string | null
    submittedAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutFeedbackInput
    user: UserCreateNestedOneWithoutConferenceFeedbackInput
  }

  export type ConferenceFeedbackUncheckedCreateInput = {
    id?: number
    conferenceId: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type ConferenceFeedbackUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutFeedbackNestedInput
    user?: UserUpdateOneRequiredWithoutConferenceFeedbackNestedInput
  }

  export type ConferenceFeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbackCreateManyInput = {
    id?: number
    conferenceId: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type ConferenceFeedbackUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationFeedbackCreateInput = {
    rating: number
    comments?: string | null
    submittedAt?: Date | string
    presentation: PresentationCreateNestedOneWithoutFeedbackInput
    user: UserCreateNestedOneWithoutPresentationFeedbackInput
  }

  export type PresentationFeedbackUncheckedCreateInput = {
    id?: number
    presentationId: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PresentationFeedbackUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentation?: PresentationUpdateOneRequiredWithoutFeedbackNestedInput
    user?: UserUpdateOneRequiredWithoutPresentationFeedbackNestedInput
  }

  export type PresentationFeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationFeedbackCreateManyInput = {
    id?: number
    presentationId: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PresentationFeedbackUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationFeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    tokenHash: string
    createdAt?: Date | string
    revoked?: boolean
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: number
    tokenHash: string
    userId: number
    createdAt?: Date | string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: number
    tokenHash: string
    userId: number
    createdAt?: Date | string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ConferenceListRelationFilter = {
    every?: ConferenceWhereInput
    some?: ConferenceWhereInput
    none?: ConferenceWhereInput
  }

  export type ConferenceMemberListRelationFilter = {
    every?: ConferenceMemberWhereInput
    some?: ConferenceMemberWhereInput
    none?: ConferenceMemberWhereInput
  }

  export type AbstractSubmissionListRelationFilter = {
    every?: AbstractSubmissionWhereInput
    some?: AbstractSubmissionWhereInput
    none?: AbstractSubmissionWhereInput
  }

  export type AbstractReviewListRelationFilter = {
    every?: AbstractReviewWhereInput
    some?: AbstractReviewWhereInput
    none?: AbstractReviewWhereInput
  }

  export type PresentationAuthorListRelationFilter = {
    every?: PresentationAuthorWhereInput
    some?: PresentationAuthorWhereInput
    none?: PresentationAuthorWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ConferenceFeedbackListRelationFilter = {
    every?: ConferenceFeedbackWhereInput
    some?: ConferenceFeedbackWhereInput
    none?: ConferenceFeedbackWhereInput
  }

  export type PresentationFeedbackListRelationFilter = {
    every?: PresentationFeedbackWhereInput
    some?: PresentationFeedbackWhereInput
    none?: PresentationFeedbackWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbstractSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbstractReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PresentationAuthorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PresentationFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    cognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    cognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    cognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumConferenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceStatus | EnumConferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceStatusFilter<$PrismaModel> | $Enums.ConferenceStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DayListRelationFilter = {
    every?: DayWhereInput
    some?: DayWhereInput
    none?: DayWhereInput
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type PresentationTypeListRelationFilter = {
    every?: PresentationTypeWhereInput
    some?: PresentationTypeWhereInput
    none?: PresentationTypeWhereInput
  }

  export type SubmissionSettingsNullableScalarRelationFilter = {
    is?: SubmissionSettingsWhereInput | null
    isNot?: SubmissionSettingsWhereInput | null
  }

  export type PresentationListRelationFilter = {
    every?: PresentationWhereInput
    some?: PresentationWhereInput
    none?: PresentationWhereInput
  }

  export type DayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PresentationTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PresentationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    status?: SortOrder
    topics?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type ConferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type EnumConferenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceStatus | EnumConferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConferenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConferenceStatusFilter<$PrismaModel>
    _max?: NestedEnumConferenceStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConferenceScalarRelationFilter = {
    is?: ConferenceWhereInput
    isNot?: ConferenceWhereInput
  }

  export type ConferenceMemberConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: number
    userId: number
  }

  export type ConferenceMemberCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    isAttendee?: SortOrder
    isSpeaker?: SortOrder
    registeredAt?: SortOrder
  }

  export type ConferenceMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
  }

  export type ConferenceMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    isAttendee?: SortOrder
    isSpeaker?: SortOrder
    registeredAt?: SortOrder
  }

  export type ConferenceMemberMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    isAttendee?: SortOrder
    isSpeaker?: SortOrder
    registeredAt?: SortOrder
  }

  export type ConferenceMemberSumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DayConferenceIdDateCompoundUniqueInput = {
    conferenceId: number
    date: Date | string
  }

  export type DayCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    date?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type DayAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type DayMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    date?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type DayMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    date?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type DaySumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSectionTypeFilter<$PrismaModel> | $Enums.SectionType
  }

  export type DayNullableScalarRelationFilter = {
    is?: DayWhereInput | null
    isNot?: DayWhereInput | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TimeSlotListRelationFilter = {
    every?: TimeSlotWhereInput
    some?: TimeSlotWhereInput
    none?: TimeSlotWhereInput
  }

  export type TimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrder
    categoryId?: SortOrder
    capacity?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    dayId?: SortOrder
    categoryId?: SortOrder
    capacity?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectionTypeFilter<$PrismaModel>
    _max?: NestedEnumSectionTypeFilter<$PrismaModel>
  }

  export type EnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type EnumBreakTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BreakType | EnumBreakTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBreakTypeNullableFilter<$PrismaModel> | $Enums.BreakType | null
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type PresentationNullableScalarRelationFilter = {
    is?: PresentationWhereInput | null
    isNot?: PresentationWhereInput | null
  }

  export type TimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    isOccupied?: SortOrder
    presentationId?: SortOrder
    title?: SortOrder
    breakType?: SortOrder
    description?: SortOrder
  }

  export type TimeSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    presentationId?: SortOrder
  }

  export type TimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    isOccupied?: SortOrder
    presentationId?: SortOrder
    title?: SortOrder
    breakType?: SortOrder
    description?: SortOrder
  }

  export type TimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    isOccupied?: SortOrder
    presentationId?: SortOrder
    title?: SortOrder
    breakType?: SortOrder
    description?: SortOrder
  }

  export type TimeSlotSumOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    presentationId?: SortOrder
  }

  export type EnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type EnumBreakTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BreakType | EnumBreakTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBreakTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.BreakType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBreakTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumBreakTypeNullableFilter<$PrismaModel>
  }

  export type EnumAbstractSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AbstractSubmissionStatus | EnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAbstractSubmissionStatusFilter<$PrismaModel> | $Enums.AbstractSubmissionStatus
  }

  export type PresentationTypeNullableScalarRelationFilter = {
    is?: PresentationTypeWhereInput | null
    isNot?: PresentationTypeWhereInput | null
  }

  export type AbstractSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    abstractText?: SortOrder
    fileUrl?: SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type AbstractSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type AbstractSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    abstractText?: SortOrder
    fileUrl?: SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type AbstractSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    abstractText?: SortOrder
    fileUrl?: SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type AbstractSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    submitterId?: SortOrder
    conferenceId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type EnumAbstractSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbstractSubmissionStatus | EnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAbstractSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AbstractSubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbstractSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumAbstractSubmissionStatusFilter<$PrismaModel>
  }

  export type AbstractSubmissionScalarRelationFilter = {
    is?: AbstractSubmissionWhereInput
    isNot?: AbstractSubmissionWhereInput
  }

  export type AbstractReviewCountOrderByAggregateInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    recommendation?: SortOrder
  }

  export type AbstractReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
  }

  export type AbstractReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    recommendation?: SortOrder
  }

  export type AbstractReviewMinOrderByAggregateInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    recommendation?: SortOrder
  }

  export type AbstractReviewSumOrderByAggregateInput = {
    id?: SortOrder
    abstractId?: SortOrder
    reviewerId?: SortOrder
    score?: SortOrder
  }

  export type SectionNullableScalarRelationFilter = {
    is?: SectionWhereInput | null
    isNot?: SectionWhereInput | null
  }

  export type TimeSlotNullableScalarRelationFilter = {
    is?: TimeSlotWhereInput | null
    isNot?: TimeSlotWhereInput | null
  }

  export type PresentationCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type PresentationAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    duration?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type PresentationMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type PresentationMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type PresentationSumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    duration?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    presentationTypeId?: SortOrder
  }

  export type PresentationScalarRelationFilter = {
    is?: PresentationWhereInput
    isNot?: PresentationWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PresentationAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    authorName?: SortOrder
    authorEmail?: SortOrder
    affiliation?: SortOrder
    isPresenter?: SortOrder
    isExternal?: SortOrder
  }

  export type PresentationAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
  }

  export type PresentationAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    authorName?: SortOrder
    authorEmail?: SortOrder
    affiliation?: SortOrder
    isPresenter?: SortOrder
    isExternal?: SortOrder
  }

  export type PresentationAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    authorName?: SortOrder
    authorEmail?: SortOrder
    affiliation?: SortOrder
    isPresenter?: SortOrder
    isExternal?: SortOrder
  }

  export type PresentationAuthorSumOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type PresentationTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type PresentationTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type PresentationTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type PresentationTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type PresentationTypeSumOrderByAggregateInput = {
    id?: SortOrder
    defaultDuration?: SortOrder
    conferenceId?: SortOrder
    order?: SortOrder
  }

  export type SubmissionSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    submissionDeadline?: SortOrder
    requireAbstract?: SortOrder
    requireFullPaper?: SortOrder
    allowedFileTypes?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
    enableSubmissions?: SortOrder
    sendConfirmationEmail?: SortOrder
  }

  export type SubmissionSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
  }

  export type SubmissionSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    submissionDeadline?: SortOrder
    requireAbstract?: SortOrder
    requireFullPaper?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
    enableSubmissions?: SortOrder
    sendConfirmationEmail?: SortOrder
  }

  export type SubmissionSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    submissionDeadline?: SortOrder
    requireAbstract?: SortOrder
    requireFullPaper?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
    enableSubmissions?: SortOrder
    sendConfirmationEmail?: SortOrder
  }

  export type SubmissionSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    maxFileSize?: SortOrder
    maxCoAuthors?: SortOrder
    minKeywords?: SortOrder
    maxKeywords?: SortOrder
  }

  export type ConferenceFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type ConferenceFeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type ConferenceFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type ConferenceFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type ConferenceFeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type PresentationFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type PresentationFeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type PresentationFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type PresentationFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type PresentationFeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    presentationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserCreaterolesInput = {
    set: $Enums.Role[]
  }

  export type ConferenceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConferenceCreateWithoutCreatedByInput, ConferenceUncheckedCreateWithoutCreatedByInput> | ConferenceCreateWithoutCreatedByInput[] | ConferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConferenceCreateOrConnectWithoutCreatedByInput | ConferenceCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConferenceCreateManyCreatedByInputEnvelope
    connect?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
  }

  export type ConferenceMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ConferenceMemberCreateWithoutUserInput, ConferenceMemberUncheckedCreateWithoutUserInput> | ConferenceMemberCreateWithoutUserInput[] | ConferenceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutUserInput | ConferenceMemberCreateOrConnectWithoutUserInput[]
    createMany?: ConferenceMemberCreateManyUserInputEnvelope
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
  }

  export type AbstractSubmissionCreateNestedManyWithoutSubmitterInput = {
    create?: XOR<AbstractSubmissionCreateWithoutSubmitterInput, AbstractSubmissionUncheckedCreateWithoutSubmitterInput> | AbstractSubmissionCreateWithoutSubmitterInput[] | AbstractSubmissionUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutSubmitterInput | AbstractSubmissionCreateOrConnectWithoutSubmitterInput[]
    createMany?: AbstractSubmissionCreateManySubmitterInputEnvelope
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
  }

  export type AbstractReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<AbstractReviewCreateWithoutReviewerInput, AbstractReviewUncheckedCreateWithoutReviewerInput> | AbstractReviewCreateWithoutReviewerInput[] | AbstractReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutReviewerInput | AbstractReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: AbstractReviewCreateManyReviewerInputEnvelope
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
  }

  export type PresentationAuthorCreateNestedManyWithoutUserInput = {
    create?: XOR<PresentationAuthorCreateWithoutUserInput, PresentationAuthorUncheckedCreateWithoutUserInput> | PresentationAuthorCreateWithoutUserInput[] | PresentationAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutUserInput | PresentationAuthorCreateOrConnectWithoutUserInput[]
    createMany?: PresentationAuthorCreateManyUserInputEnvelope
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConferenceFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutUserInput, ConferenceFeedbackUncheckedCreateWithoutUserInput> | ConferenceFeedbackCreateWithoutUserInput[] | ConferenceFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutUserInput | ConferenceFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: ConferenceFeedbackCreateManyUserInputEnvelope
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
  }

  export type PresentationFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<PresentationFeedbackCreateWithoutUserInput, PresentationFeedbackUncheckedCreateWithoutUserInput> | PresentationFeedbackCreateWithoutUserInput[] | PresentationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutUserInput | PresentationFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: PresentationFeedbackCreateManyUserInputEnvelope
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ConferenceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConferenceCreateWithoutCreatedByInput, ConferenceUncheckedCreateWithoutCreatedByInput> | ConferenceCreateWithoutCreatedByInput[] | ConferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConferenceCreateOrConnectWithoutCreatedByInput | ConferenceCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConferenceCreateManyCreatedByInputEnvelope
    connect?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
  }

  export type ConferenceMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConferenceMemberCreateWithoutUserInput, ConferenceMemberUncheckedCreateWithoutUserInput> | ConferenceMemberCreateWithoutUserInput[] | ConferenceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutUserInput | ConferenceMemberCreateOrConnectWithoutUserInput[]
    createMany?: ConferenceMemberCreateManyUserInputEnvelope
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
  }

  export type AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput = {
    create?: XOR<AbstractSubmissionCreateWithoutSubmitterInput, AbstractSubmissionUncheckedCreateWithoutSubmitterInput> | AbstractSubmissionCreateWithoutSubmitterInput[] | AbstractSubmissionUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutSubmitterInput | AbstractSubmissionCreateOrConnectWithoutSubmitterInput[]
    createMany?: AbstractSubmissionCreateManySubmitterInputEnvelope
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
  }

  export type AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<AbstractReviewCreateWithoutReviewerInput, AbstractReviewUncheckedCreateWithoutReviewerInput> | AbstractReviewCreateWithoutReviewerInput[] | AbstractReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutReviewerInput | AbstractReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: AbstractReviewCreateManyReviewerInputEnvelope
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
  }

  export type PresentationAuthorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PresentationAuthorCreateWithoutUserInput, PresentationAuthorUncheckedCreateWithoutUserInput> | PresentationAuthorCreateWithoutUserInput[] | PresentationAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutUserInput | PresentationAuthorCreateOrConnectWithoutUserInput[]
    createMany?: PresentationAuthorCreateManyUserInputEnvelope
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutUserInput, ConferenceFeedbackUncheckedCreateWithoutUserInput> | ConferenceFeedbackCreateWithoutUserInput[] | ConferenceFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutUserInput | ConferenceFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: ConferenceFeedbackCreateManyUserInputEnvelope
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
  }

  export type PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PresentationFeedbackCreateWithoutUserInput, PresentationFeedbackUncheckedCreateWithoutUserInput> | PresentationFeedbackCreateWithoutUserInput[] | PresentationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutUserInput | PresentationFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: PresentationFeedbackCreateManyUserInputEnvelope
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdaterolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ConferenceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConferenceCreateWithoutCreatedByInput, ConferenceUncheckedCreateWithoutCreatedByInput> | ConferenceCreateWithoutCreatedByInput[] | ConferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConferenceCreateOrConnectWithoutCreatedByInput | ConferenceCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConferenceUpsertWithWhereUniqueWithoutCreatedByInput | ConferenceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConferenceCreateManyCreatedByInputEnvelope
    set?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    disconnect?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    delete?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    connect?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    update?: ConferenceUpdateWithWhereUniqueWithoutCreatedByInput | ConferenceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConferenceUpdateManyWithWhereWithoutCreatedByInput | ConferenceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConferenceScalarWhereInput | ConferenceScalarWhereInput[]
  }

  export type ConferenceMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConferenceMemberCreateWithoutUserInput, ConferenceMemberUncheckedCreateWithoutUserInput> | ConferenceMemberCreateWithoutUserInput[] | ConferenceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutUserInput | ConferenceMemberCreateOrConnectWithoutUserInput[]
    upsert?: ConferenceMemberUpsertWithWhereUniqueWithoutUserInput | ConferenceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConferenceMemberCreateManyUserInputEnvelope
    set?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    disconnect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    delete?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    update?: ConferenceMemberUpdateWithWhereUniqueWithoutUserInput | ConferenceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConferenceMemberUpdateManyWithWhereWithoutUserInput | ConferenceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConferenceMemberScalarWhereInput | ConferenceMemberScalarWhereInput[]
  }

  export type AbstractSubmissionUpdateManyWithoutSubmitterNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutSubmitterInput, AbstractSubmissionUncheckedCreateWithoutSubmitterInput> | AbstractSubmissionCreateWithoutSubmitterInput[] | AbstractSubmissionUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutSubmitterInput | AbstractSubmissionCreateOrConnectWithoutSubmitterInput[]
    upsert?: AbstractSubmissionUpsertWithWhereUniqueWithoutSubmitterInput | AbstractSubmissionUpsertWithWhereUniqueWithoutSubmitterInput[]
    createMany?: AbstractSubmissionCreateManySubmitterInputEnvelope
    set?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    disconnect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    delete?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    update?: AbstractSubmissionUpdateWithWhereUniqueWithoutSubmitterInput | AbstractSubmissionUpdateWithWhereUniqueWithoutSubmitterInput[]
    updateMany?: AbstractSubmissionUpdateManyWithWhereWithoutSubmitterInput | AbstractSubmissionUpdateManyWithWhereWithoutSubmitterInput[]
    deleteMany?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
  }

  export type AbstractReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<AbstractReviewCreateWithoutReviewerInput, AbstractReviewUncheckedCreateWithoutReviewerInput> | AbstractReviewCreateWithoutReviewerInput[] | AbstractReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutReviewerInput | AbstractReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: AbstractReviewUpsertWithWhereUniqueWithoutReviewerInput | AbstractReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: AbstractReviewCreateManyReviewerInputEnvelope
    set?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    disconnect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    delete?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    update?: AbstractReviewUpdateWithWhereUniqueWithoutReviewerInput | AbstractReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: AbstractReviewUpdateManyWithWhereWithoutReviewerInput | AbstractReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: AbstractReviewScalarWhereInput | AbstractReviewScalarWhereInput[]
  }

  export type PresentationAuthorUpdateManyWithoutUserNestedInput = {
    create?: XOR<PresentationAuthorCreateWithoutUserInput, PresentationAuthorUncheckedCreateWithoutUserInput> | PresentationAuthorCreateWithoutUserInput[] | PresentationAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutUserInput | PresentationAuthorCreateOrConnectWithoutUserInput[]
    upsert?: PresentationAuthorUpsertWithWhereUniqueWithoutUserInput | PresentationAuthorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PresentationAuthorCreateManyUserInputEnvelope
    set?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    disconnect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    delete?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    update?: PresentationAuthorUpdateWithWhereUniqueWithoutUserInput | PresentationAuthorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PresentationAuthorUpdateManyWithWhereWithoutUserInput | PresentationAuthorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PresentationAuthorScalarWhereInput | PresentationAuthorScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ConferenceFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutUserInput, ConferenceFeedbackUncheckedCreateWithoutUserInput> | ConferenceFeedbackCreateWithoutUserInput[] | ConferenceFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutUserInput | ConferenceFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: ConferenceFeedbackUpsertWithWhereUniqueWithoutUserInput | ConferenceFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConferenceFeedbackCreateManyUserInputEnvelope
    set?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    disconnect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    delete?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    update?: ConferenceFeedbackUpdateWithWhereUniqueWithoutUserInput | ConferenceFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConferenceFeedbackUpdateManyWithWhereWithoutUserInput | ConferenceFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConferenceFeedbackScalarWhereInput | ConferenceFeedbackScalarWhereInput[]
  }

  export type PresentationFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<PresentationFeedbackCreateWithoutUserInput, PresentationFeedbackUncheckedCreateWithoutUserInput> | PresentationFeedbackCreateWithoutUserInput[] | PresentationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutUserInput | PresentationFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: PresentationFeedbackUpsertWithWhereUniqueWithoutUserInput | PresentationFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PresentationFeedbackCreateManyUserInputEnvelope
    set?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    disconnect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    delete?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    update?: PresentationFeedbackUpdateWithWhereUniqueWithoutUserInput | PresentationFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PresentationFeedbackUpdateManyWithWhereWithoutUserInput | PresentationFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PresentationFeedbackScalarWhereInput | PresentationFeedbackScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConferenceCreateWithoutCreatedByInput, ConferenceUncheckedCreateWithoutCreatedByInput> | ConferenceCreateWithoutCreatedByInput[] | ConferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConferenceCreateOrConnectWithoutCreatedByInput | ConferenceCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConferenceUpsertWithWhereUniqueWithoutCreatedByInput | ConferenceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConferenceCreateManyCreatedByInputEnvelope
    set?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    disconnect?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    delete?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    connect?: ConferenceWhereUniqueInput | ConferenceWhereUniqueInput[]
    update?: ConferenceUpdateWithWhereUniqueWithoutCreatedByInput | ConferenceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConferenceUpdateManyWithWhereWithoutCreatedByInput | ConferenceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConferenceScalarWhereInput | ConferenceScalarWhereInput[]
  }

  export type ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConferenceMemberCreateWithoutUserInput, ConferenceMemberUncheckedCreateWithoutUserInput> | ConferenceMemberCreateWithoutUserInput[] | ConferenceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutUserInput | ConferenceMemberCreateOrConnectWithoutUserInput[]
    upsert?: ConferenceMemberUpsertWithWhereUniqueWithoutUserInput | ConferenceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConferenceMemberCreateManyUserInputEnvelope
    set?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    disconnect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    delete?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    update?: ConferenceMemberUpdateWithWhereUniqueWithoutUserInput | ConferenceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConferenceMemberUpdateManyWithWhereWithoutUserInput | ConferenceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConferenceMemberScalarWhereInput | ConferenceMemberScalarWhereInput[]
  }

  export type AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutSubmitterInput, AbstractSubmissionUncheckedCreateWithoutSubmitterInput> | AbstractSubmissionCreateWithoutSubmitterInput[] | AbstractSubmissionUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutSubmitterInput | AbstractSubmissionCreateOrConnectWithoutSubmitterInput[]
    upsert?: AbstractSubmissionUpsertWithWhereUniqueWithoutSubmitterInput | AbstractSubmissionUpsertWithWhereUniqueWithoutSubmitterInput[]
    createMany?: AbstractSubmissionCreateManySubmitterInputEnvelope
    set?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    disconnect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    delete?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    update?: AbstractSubmissionUpdateWithWhereUniqueWithoutSubmitterInput | AbstractSubmissionUpdateWithWhereUniqueWithoutSubmitterInput[]
    updateMany?: AbstractSubmissionUpdateManyWithWhereWithoutSubmitterInput | AbstractSubmissionUpdateManyWithWhereWithoutSubmitterInput[]
    deleteMany?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
  }

  export type AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<AbstractReviewCreateWithoutReviewerInput, AbstractReviewUncheckedCreateWithoutReviewerInput> | AbstractReviewCreateWithoutReviewerInput[] | AbstractReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutReviewerInput | AbstractReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: AbstractReviewUpsertWithWhereUniqueWithoutReviewerInput | AbstractReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: AbstractReviewCreateManyReviewerInputEnvelope
    set?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    disconnect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    delete?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    update?: AbstractReviewUpdateWithWhereUniqueWithoutReviewerInput | AbstractReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: AbstractReviewUpdateManyWithWhereWithoutReviewerInput | AbstractReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: AbstractReviewScalarWhereInput | AbstractReviewScalarWhereInput[]
  }

  export type PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PresentationAuthorCreateWithoutUserInput, PresentationAuthorUncheckedCreateWithoutUserInput> | PresentationAuthorCreateWithoutUserInput[] | PresentationAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutUserInput | PresentationAuthorCreateOrConnectWithoutUserInput[]
    upsert?: PresentationAuthorUpsertWithWhereUniqueWithoutUserInput | PresentationAuthorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PresentationAuthorCreateManyUserInputEnvelope
    set?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    disconnect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    delete?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    update?: PresentationAuthorUpdateWithWhereUniqueWithoutUserInput | PresentationAuthorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PresentationAuthorUpdateManyWithWhereWithoutUserInput | PresentationAuthorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PresentationAuthorScalarWhereInput | PresentationAuthorScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutUserInput, ConferenceFeedbackUncheckedCreateWithoutUserInput> | ConferenceFeedbackCreateWithoutUserInput[] | ConferenceFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutUserInput | ConferenceFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: ConferenceFeedbackUpsertWithWhereUniqueWithoutUserInput | ConferenceFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConferenceFeedbackCreateManyUserInputEnvelope
    set?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    disconnect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    delete?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    update?: ConferenceFeedbackUpdateWithWhereUniqueWithoutUserInput | ConferenceFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConferenceFeedbackUpdateManyWithWhereWithoutUserInput | ConferenceFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConferenceFeedbackScalarWhereInput | ConferenceFeedbackScalarWhereInput[]
  }

  export type PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PresentationFeedbackCreateWithoutUserInput, PresentationFeedbackUncheckedCreateWithoutUserInput> | PresentationFeedbackCreateWithoutUserInput[] | PresentationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutUserInput | PresentationFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: PresentationFeedbackUpsertWithWhereUniqueWithoutUserInput | PresentationFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PresentationFeedbackCreateManyUserInputEnvelope
    set?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    disconnect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    delete?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    update?: PresentationFeedbackUpdateWithWhereUniqueWithoutUserInput | PresentationFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PresentationFeedbackUpdateManyWithWhereWithoutUserInput | PresentationFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PresentationFeedbackScalarWhereInput | PresentationFeedbackScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ConferenceCreatetopicsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutConferencesInput = {
    create?: XOR<UserCreateWithoutConferencesInput, UserUncheckedCreateWithoutConferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferencesInput
    connect?: UserWhereUniqueInput
  }

  export type ConferenceMemberCreateNestedManyWithoutConferenceInput = {
    create?: XOR<ConferenceMemberCreateWithoutConferenceInput, ConferenceMemberUncheckedCreateWithoutConferenceInput> | ConferenceMemberCreateWithoutConferenceInput[] | ConferenceMemberUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutConferenceInput | ConferenceMemberCreateOrConnectWithoutConferenceInput[]
    createMany?: ConferenceMemberCreateManyConferenceInputEnvelope
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
  }

  export type DayCreateNestedManyWithoutConferenceInput = {
    create?: XOR<DayCreateWithoutConferenceInput, DayUncheckedCreateWithoutConferenceInput> | DayCreateWithoutConferenceInput[] | DayUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: DayCreateOrConnectWithoutConferenceInput | DayCreateOrConnectWithoutConferenceInput[]
    createMany?: DayCreateManyConferenceInputEnvelope
    connect?: DayWhereUniqueInput | DayWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutConferenceInput = {
    create?: XOR<SectionCreateWithoutConferenceInput, SectionUncheckedCreateWithoutConferenceInput> | SectionCreateWithoutConferenceInput[] | SectionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutConferenceInput | SectionCreateOrConnectWithoutConferenceInput[]
    createMany?: SectionCreateManyConferenceInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutConferenceInput = {
    create?: XOR<CategoryCreateWithoutConferenceInput, CategoryUncheckedCreateWithoutConferenceInput> | CategoryCreateWithoutConferenceInput[] | CategoryUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutConferenceInput | CategoryCreateOrConnectWithoutConferenceInput[]
    createMany?: CategoryCreateManyConferenceInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PresentationTypeCreateNestedManyWithoutConferenceInput = {
    create?: XOR<PresentationTypeCreateWithoutConferenceInput, PresentationTypeUncheckedCreateWithoutConferenceInput> | PresentationTypeCreateWithoutConferenceInput[] | PresentationTypeUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutConferenceInput | PresentationTypeCreateOrConnectWithoutConferenceInput[]
    createMany?: PresentationTypeCreateManyConferenceInputEnvelope
    connect?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
  }

  export type SubmissionSettingsCreateNestedOneWithoutConferenceInput = {
    create?: XOR<SubmissionSettingsCreateWithoutConferenceInput, SubmissionSettingsUncheckedCreateWithoutConferenceInput>
    connectOrCreate?: SubmissionSettingsCreateOrConnectWithoutConferenceInput
    connect?: SubmissionSettingsWhereUniqueInput
  }

  export type AbstractSubmissionCreateNestedManyWithoutConferenceInput = {
    create?: XOR<AbstractSubmissionCreateWithoutConferenceInput, AbstractSubmissionUncheckedCreateWithoutConferenceInput> | AbstractSubmissionCreateWithoutConferenceInput[] | AbstractSubmissionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutConferenceInput | AbstractSubmissionCreateOrConnectWithoutConferenceInput[]
    createMany?: AbstractSubmissionCreateManyConferenceInputEnvelope
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
  }

  export type PresentationCreateNestedManyWithoutConferenceInput = {
    create?: XOR<PresentationCreateWithoutConferenceInput, PresentationUncheckedCreateWithoutConferenceInput> | PresentationCreateWithoutConferenceInput[] | PresentationUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutConferenceInput | PresentationCreateOrConnectWithoutConferenceInput[]
    createMany?: PresentationCreateManyConferenceInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type ConferenceFeedbackCreateNestedManyWithoutConferenceInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutConferenceInput, ConferenceFeedbackUncheckedCreateWithoutConferenceInput> | ConferenceFeedbackCreateWithoutConferenceInput[] | ConferenceFeedbackUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutConferenceInput | ConferenceFeedbackCreateOrConnectWithoutConferenceInput[]
    createMany?: ConferenceFeedbackCreateManyConferenceInputEnvelope
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
  }

  export type ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<ConferenceMemberCreateWithoutConferenceInput, ConferenceMemberUncheckedCreateWithoutConferenceInput> | ConferenceMemberCreateWithoutConferenceInput[] | ConferenceMemberUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutConferenceInput | ConferenceMemberCreateOrConnectWithoutConferenceInput[]
    createMany?: ConferenceMemberCreateManyConferenceInputEnvelope
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
  }

  export type DayUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<DayCreateWithoutConferenceInput, DayUncheckedCreateWithoutConferenceInput> | DayCreateWithoutConferenceInput[] | DayUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: DayCreateOrConnectWithoutConferenceInput | DayCreateOrConnectWithoutConferenceInput[]
    createMany?: DayCreateManyConferenceInputEnvelope
    connect?: DayWhereUniqueInput | DayWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<SectionCreateWithoutConferenceInput, SectionUncheckedCreateWithoutConferenceInput> | SectionCreateWithoutConferenceInput[] | SectionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutConferenceInput | SectionCreateOrConnectWithoutConferenceInput[]
    createMany?: SectionCreateManyConferenceInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<CategoryCreateWithoutConferenceInput, CategoryUncheckedCreateWithoutConferenceInput> | CategoryCreateWithoutConferenceInput[] | CategoryUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutConferenceInput | CategoryCreateOrConnectWithoutConferenceInput[]
    createMany?: CategoryCreateManyConferenceInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<PresentationTypeCreateWithoutConferenceInput, PresentationTypeUncheckedCreateWithoutConferenceInput> | PresentationTypeCreateWithoutConferenceInput[] | PresentationTypeUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutConferenceInput | PresentationTypeCreateOrConnectWithoutConferenceInput[]
    createMany?: PresentationTypeCreateManyConferenceInputEnvelope
    connect?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
  }

  export type SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput = {
    create?: XOR<SubmissionSettingsCreateWithoutConferenceInput, SubmissionSettingsUncheckedCreateWithoutConferenceInput>
    connectOrCreate?: SubmissionSettingsCreateOrConnectWithoutConferenceInput
    connect?: SubmissionSettingsWhereUniqueInput
  }

  export type AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<AbstractSubmissionCreateWithoutConferenceInput, AbstractSubmissionUncheckedCreateWithoutConferenceInput> | AbstractSubmissionCreateWithoutConferenceInput[] | AbstractSubmissionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutConferenceInput | AbstractSubmissionCreateOrConnectWithoutConferenceInput[]
    createMany?: AbstractSubmissionCreateManyConferenceInputEnvelope
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
  }

  export type PresentationUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<PresentationCreateWithoutConferenceInput, PresentationUncheckedCreateWithoutConferenceInput> | PresentationCreateWithoutConferenceInput[] | PresentationUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutConferenceInput | PresentationCreateOrConnectWithoutConferenceInput[]
    createMany?: PresentationCreateManyConferenceInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutConferenceInput, ConferenceFeedbackUncheckedCreateWithoutConferenceInput> | ConferenceFeedbackCreateWithoutConferenceInput[] | ConferenceFeedbackUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutConferenceInput | ConferenceFeedbackCreateOrConnectWithoutConferenceInput[]
    createMany?: ConferenceFeedbackCreateManyConferenceInputEnvelope
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
  }

  export type EnumConferenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConferenceStatus
  }

  export type ConferenceUpdatetopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutConferencesNestedInput = {
    create?: XOR<UserCreateWithoutConferencesInput, UserUncheckedCreateWithoutConferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferencesInput
    upsert?: UserUpsertWithoutConferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConferencesInput, UserUpdateWithoutConferencesInput>, UserUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceMemberUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<ConferenceMemberCreateWithoutConferenceInput, ConferenceMemberUncheckedCreateWithoutConferenceInput> | ConferenceMemberCreateWithoutConferenceInput[] | ConferenceMemberUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutConferenceInput | ConferenceMemberCreateOrConnectWithoutConferenceInput[]
    upsert?: ConferenceMemberUpsertWithWhereUniqueWithoutConferenceInput | ConferenceMemberUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: ConferenceMemberCreateManyConferenceInputEnvelope
    set?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    disconnect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    delete?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    update?: ConferenceMemberUpdateWithWhereUniqueWithoutConferenceInput | ConferenceMemberUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: ConferenceMemberUpdateManyWithWhereWithoutConferenceInput | ConferenceMemberUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: ConferenceMemberScalarWhereInput | ConferenceMemberScalarWhereInput[]
  }

  export type DayUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<DayCreateWithoutConferenceInput, DayUncheckedCreateWithoutConferenceInput> | DayCreateWithoutConferenceInput[] | DayUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: DayCreateOrConnectWithoutConferenceInput | DayCreateOrConnectWithoutConferenceInput[]
    upsert?: DayUpsertWithWhereUniqueWithoutConferenceInput | DayUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: DayCreateManyConferenceInputEnvelope
    set?: DayWhereUniqueInput | DayWhereUniqueInput[]
    disconnect?: DayWhereUniqueInput | DayWhereUniqueInput[]
    delete?: DayWhereUniqueInput | DayWhereUniqueInput[]
    connect?: DayWhereUniqueInput | DayWhereUniqueInput[]
    update?: DayUpdateWithWhereUniqueWithoutConferenceInput | DayUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: DayUpdateManyWithWhereWithoutConferenceInput | DayUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: DayScalarWhereInput | DayScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<SectionCreateWithoutConferenceInput, SectionUncheckedCreateWithoutConferenceInput> | SectionCreateWithoutConferenceInput[] | SectionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutConferenceInput | SectionCreateOrConnectWithoutConferenceInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutConferenceInput | SectionUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: SectionCreateManyConferenceInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutConferenceInput | SectionUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutConferenceInput | SectionUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<CategoryCreateWithoutConferenceInput, CategoryUncheckedCreateWithoutConferenceInput> | CategoryCreateWithoutConferenceInput[] | CategoryUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutConferenceInput | CategoryCreateOrConnectWithoutConferenceInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutConferenceInput | CategoryUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: CategoryCreateManyConferenceInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutConferenceInput | CategoryUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutConferenceInput | CategoryUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PresentationTypeUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<PresentationTypeCreateWithoutConferenceInput, PresentationTypeUncheckedCreateWithoutConferenceInput> | PresentationTypeCreateWithoutConferenceInput[] | PresentationTypeUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutConferenceInput | PresentationTypeCreateOrConnectWithoutConferenceInput[]
    upsert?: PresentationTypeUpsertWithWhereUniqueWithoutConferenceInput | PresentationTypeUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: PresentationTypeCreateManyConferenceInputEnvelope
    set?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    disconnect?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    delete?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    connect?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    update?: PresentationTypeUpdateWithWhereUniqueWithoutConferenceInput | PresentationTypeUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: PresentationTypeUpdateManyWithWhereWithoutConferenceInput | PresentationTypeUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: PresentationTypeScalarWhereInput | PresentationTypeScalarWhereInput[]
  }

  export type SubmissionSettingsUpdateOneWithoutConferenceNestedInput = {
    create?: XOR<SubmissionSettingsCreateWithoutConferenceInput, SubmissionSettingsUncheckedCreateWithoutConferenceInput>
    connectOrCreate?: SubmissionSettingsCreateOrConnectWithoutConferenceInput
    upsert?: SubmissionSettingsUpsertWithoutConferenceInput
    disconnect?: SubmissionSettingsWhereInput | boolean
    delete?: SubmissionSettingsWhereInput | boolean
    connect?: SubmissionSettingsWhereUniqueInput
    update?: XOR<XOR<SubmissionSettingsUpdateToOneWithWhereWithoutConferenceInput, SubmissionSettingsUpdateWithoutConferenceInput>, SubmissionSettingsUncheckedUpdateWithoutConferenceInput>
  }

  export type AbstractSubmissionUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutConferenceInput, AbstractSubmissionUncheckedCreateWithoutConferenceInput> | AbstractSubmissionCreateWithoutConferenceInput[] | AbstractSubmissionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutConferenceInput | AbstractSubmissionCreateOrConnectWithoutConferenceInput[]
    upsert?: AbstractSubmissionUpsertWithWhereUniqueWithoutConferenceInput | AbstractSubmissionUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: AbstractSubmissionCreateManyConferenceInputEnvelope
    set?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    disconnect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    delete?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    update?: AbstractSubmissionUpdateWithWhereUniqueWithoutConferenceInput | AbstractSubmissionUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: AbstractSubmissionUpdateManyWithWhereWithoutConferenceInput | AbstractSubmissionUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
  }

  export type PresentationUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<PresentationCreateWithoutConferenceInput, PresentationUncheckedCreateWithoutConferenceInput> | PresentationCreateWithoutConferenceInput[] | PresentationUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutConferenceInput | PresentationCreateOrConnectWithoutConferenceInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutConferenceInput | PresentationUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: PresentationCreateManyConferenceInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutConferenceInput | PresentationUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutConferenceInput | PresentationUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type ConferenceFeedbackUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutConferenceInput, ConferenceFeedbackUncheckedCreateWithoutConferenceInput> | ConferenceFeedbackCreateWithoutConferenceInput[] | ConferenceFeedbackUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutConferenceInput | ConferenceFeedbackCreateOrConnectWithoutConferenceInput[]
    upsert?: ConferenceFeedbackUpsertWithWhereUniqueWithoutConferenceInput | ConferenceFeedbackUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: ConferenceFeedbackCreateManyConferenceInputEnvelope
    set?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    disconnect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    delete?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    update?: ConferenceFeedbackUpdateWithWhereUniqueWithoutConferenceInput | ConferenceFeedbackUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: ConferenceFeedbackUpdateManyWithWhereWithoutConferenceInput | ConferenceFeedbackUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: ConferenceFeedbackScalarWhereInput | ConferenceFeedbackScalarWhereInput[]
  }

  export type ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<ConferenceMemberCreateWithoutConferenceInput, ConferenceMemberUncheckedCreateWithoutConferenceInput> | ConferenceMemberCreateWithoutConferenceInput[] | ConferenceMemberUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceMemberCreateOrConnectWithoutConferenceInput | ConferenceMemberCreateOrConnectWithoutConferenceInput[]
    upsert?: ConferenceMemberUpsertWithWhereUniqueWithoutConferenceInput | ConferenceMemberUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: ConferenceMemberCreateManyConferenceInputEnvelope
    set?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    disconnect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    delete?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    connect?: ConferenceMemberWhereUniqueInput | ConferenceMemberWhereUniqueInput[]
    update?: ConferenceMemberUpdateWithWhereUniqueWithoutConferenceInput | ConferenceMemberUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: ConferenceMemberUpdateManyWithWhereWithoutConferenceInput | ConferenceMemberUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: ConferenceMemberScalarWhereInput | ConferenceMemberScalarWhereInput[]
  }

  export type DayUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<DayCreateWithoutConferenceInput, DayUncheckedCreateWithoutConferenceInput> | DayCreateWithoutConferenceInput[] | DayUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: DayCreateOrConnectWithoutConferenceInput | DayCreateOrConnectWithoutConferenceInput[]
    upsert?: DayUpsertWithWhereUniqueWithoutConferenceInput | DayUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: DayCreateManyConferenceInputEnvelope
    set?: DayWhereUniqueInput | DayWhereUniqueInput[]
    disconnect?: DayWhereUniqueInput | DayWhereUniqueInput[]
    delete?: DayWhereUniqueInput | DayWhereUniqueInput[]
    connect?: DayWhereUniqueInput | DayWhereUniqueInput[]
    update?: DayUpdateWithWhereUniqueWithoutConferenceInput | DayUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: DayUpdateManyWithWhereWithoutConferenceInput | DayUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: DayScalarWhereInput | DayScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<SectionCreateWithoutConferenceInput, SectionUncheckedCreateWithoutConferenceInput> | SectionCreateWithoutConferenceInput[] | SectionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutConferenceInput | SectionCreateOrConnectWithoutConferenceInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutConferenceInput | SectionUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: SectionCreateManyConferenceInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutConferenceInput | SectionUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutConferenceInput | SectionUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<CategoryCreateWithoutConferenceInput, CategoryUncheckedCreateWithoutConferenceInput> | CategoryCreateWithoutConferenceInput[] | CategoryUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutConferenceInput | CategoryCreateOrConnectWithoutConferenceInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutConferenceInput | CategoryUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: CategoryCreateManyConferenceInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutConferenceInput | CategoryUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutConferenceInput | CategoryUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<PresentationTypeCreateWithoutConferenceInput, PresentationTypeUncheckedCreateWithoutConferenceInput> | PresentationTypeCreateWithoutConferenceInput[] | PresentationTypeUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutConferenceInput | PresentationTypeCreateOrConnectWithoutConferenceInput[]
    upsert?: PresentationTypeUpsertWithWhereUniqueWithoutConferenceInput | PresentationTypeUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: PresentationTypeCreateManyConferenceInputEnvelope
    set?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    disconnect?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    delete?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    connect?: PresentationTypeWhereUniqueInput | PresentationTypeWhereUniqueInput[]
    update?: PresentationTypeUpdateWithWhereUniqueWithoutConferenceInput | PresentationTypeUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: PresentationTypeUpdateManyWithWhereWithoutConferenceInput | PresentationTypeUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: PresentationTypeScalarWhereInput | PresentationTypeScalarWhereInput[]
  }

  export type SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput = {
    create?: XOR<SubmissionSettingsCreateWithoutConferenceInput, SubmissionSettingsUncheckedCreateWithoutConferenceInput>
    connectOrCreate?: SubmissionSettingsCreateOrConnectWithoutConferenceInput
    upsert?: SubmissionSettingsUpsertWithoutConferenceInput
    disconnect?: SubmissionSettingsWhereInput | boolean
    delete?: SubmissionSettingsWhereInput | boolean
    connect?: SubmissionSettingsWhereUniqueInput
    update?: XOR<XOR<SubmissionSettingsUpdateToOneWithWhereWithoutConferenceInput, SubmissionSettingsUpdateWithoutConferenceInput>, SubmissionSettingsUncheckedUpdateWithoutConferenceInput>
  }

  export type AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutConferenceInput, AbstractSubmissionUncheckedCreateWithoutConferenceInput> | AbstractSubmissionCreateWithoutConferenceInput[] | AbstractSubmissionUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutConferenceInput | AbstractSubmissionCreateOrConnectWithoutConferenceInput[]
    upsert?: AbstractSubmissionUpsertWithWhereUniqueWithoutConferenceInput | AbstractSubmissionUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: AbstractSubmissionCreateManyConferenceInputEnvelope
    set?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    disconnect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    delete?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    update?: AbstractSubmissionUpdateWithWhereUniqueWithoutConferenceInput | AbstractSubmissionUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: AbstractSubmissionUpdateManyWithWhereWithoutConferenceInput | AbstractSubmissionUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
  }

  export type PresentationUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<PresentationCreateWithoutConferenceInput, PresentationUncheckedCreateWithoutConferenceInput> | PresentationCreateWithoutConferenceInput[] | PresentationUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutConferenceInput | PresentationCreateOrConnectWithoutConferenceInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutConferenceInput | PresentationUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: PresentationCreateManyConferenceInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutConferenceInput | PresentationUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutConferenceInput | PresentationUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput = {
    create?: XOR<ConferenceFeedbackCreateWithoutConferenceInput, ConferenceFeedbackUncheckedCreateWithoutConferenceInput> | ConferenceFeedbackCreateWithoutConferenceInput[] | ConferenceFeedbackUncheckedCreateWithoutConferenceInput[]
    connectOrCreate?: ConferenceFeedbackCreateOrConnectWithoutConferenceInput | ConferenceFeedbackCreateOrConnectWithoutConferenceInput[]
    upsert?: ConferenceFeedbackUpsertWithWhereUniqueWithoutConferenceInput | ConferenceFeedbackUpsertWithWhereUniqueWithoutConferenceInput[]
    createMany?: ConferenceFeedbackCreateManyConferenceInputEnvelope
    set?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    disconnect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    delete?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    connect?: ConferenceFeedbackWhereUniqueInput | ConferenceFeedbackWhereUniqueInput[]
    update?: ConferenceFeedbackUpdateWithWhereUniqueWithoutConferenceInput | ConferenceFeedbackUpdateWithWhereUniqueWithoutConferenceInput[]
    updateMany?: ConferenceFeedbackUpdateManyWithWhereWithoutConferenceInput | ConferenceFeedbackUpdateManyWithWhereWithoutConferenceInput[]
    deleteMany?: ConferenceFeedbackScalarWhereInput | ConferenceFeedbackScalarWhereInput[]
  }

  export type ConferenceCreateNestedOneWithoutMembersInput = {
    create?: XOR<ConferenceCreateWithoutMembersInput, ConferenceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutMembersInput
    connect?: ConferenceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConferenceMembershipInput = {
    create?: XOR<UserCreateWithoutConferenceMembershipInput, UserUncheckedCreateWithoutConferenceMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferenceMembershipInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ConferenceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ConferenceCreateWithoutMembersInput, ConferenceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutMembersInput
    upsert?: ConferenceUpsertWithoutMembersInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutMembersInput, ConferenceUpdateWithoutMembersInput>, ConferenceUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutConferenceMembershipNestedInput = {
    create?: XOR<UserCreateWithoutConferenceMembershipInput, UserUncheckedCreateWithoutConferenceMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferenceMembershipInput
    upsert?: UserUpsertWithoutConferenceMembershipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConferenceMembershipInput, UserUpdateWithoutConferenceMembershipInput>, UserUncheckedUpdateWithoutConferenceMembershipInput>
  }

  export type ConferenceCreateNestedOneWithoutDaysInput = {
    create?: XOR<ConferenceCreateWithoutDaysInput, ConferenceUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutDaysInput
    connect?: ConferenceWhereUniqueInput
  }

  export type SectionCreateNestedManyWithoutDayInput = {
    create?: XOR<SectionCreateWithoutDayInput, SectionUncheckedCreateWithoutDayInput> | SectionCreateWithoutDayInput[] | SectionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutDayInput | SectionCreateOrConnectWithoutDayInput[]
    createMany?: SectionCreateManyDayInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutDayInput = {
    create?: XOR<SectionCreateWithoutDayInput, SectionUncheckedCreateWithoutDayInput> | SectionCreateWithoutDayInput[] | SectionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutDayInput | SectionCreateOrConnectWithoutDayInput[]
    createMany?: SectionCreateManyDayInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type ConferenceUpdateOneRequiredWithoutDaysNestedInput = {
    create?: XOR<ConferenceCreateWithoutDaysInput, ConferenceUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutDaysInput
    upsert?: ConferenceUpsertWithoutDaysInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutDaysInput, ConferenceUpdateWithoutDaysInput>, ConferenceUncheckedUpdateWithoutDaysInput>
  }

  export type SectionUpdateManyWithoutDayNestedInput = {
    create?: XOR<SectionCreateWithoutDayInput, SectionUncheckedCreateWithoutDayInput> | SectionCreateWithoutDayInput[] | SectionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutDayInput | SectionCreateOrConnectWithoutDayInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutDayInput | SectionUpsertWithWhereUniqueWithoutDayInput[]
    createMany?: SectionCreateManyDayInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutDayInput | SectionUpdateWithWhereUniqueWithoutDayInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutDayInput | SectionUpdateManyWithWhereWithoutDayInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutDayNestedInput = {
    create?: XOR<SectionCreateWithoutDayInput, SectionUncheckedCreateWithoutDayInput> | SectionCreateWithoutDayInput[] | SectionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutDayInput | SectionCreateOrConnectWithoutDayInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutDayInput | SectionUpsertWithWhereUniqueWithoutDayInput[]
    createMany?: SectionCreateManyDayInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutDayInput | SectionUpdateWithWhereUniqueWithoutDayInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutDayInput | SectionUpdateManyWithWhereWithoutDayInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type ConferenceCreateNestedOneWithoutSectionsInput = {
    create?: XOR<ConferenceCreateWithoutSectionsInput, ConferenceUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutSectionsInput
    connect?: ConferenceWhereUniqueInput
  }

  export type DayCreateNestedOneWithoutSectionsInput = {
    create?: XOR<DayCreateWithoutSectionsInput, DayUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: DayCreateOrConnectWithoutSectionsInput
    connect?: DayWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutSectionsInput = {
    create?: XOR<CategoryCreateWithoutSectionsInput, CategoryUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSectionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TimeSlotCreateNestedManyWithoutSectionInput = {
    create?: XOR<TimeSlotCreateWithoutSectionInput, TimeSlotUncheckedCreateWithoutSectionInput> | TimeSlotCreateWithoutSectionInput[] | TimeSlotUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSectionInput | TimeSlotCreateOrConnectWithoutSectionInput[]
    createMany?: TimeSlotCreateManySectionInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type PresentationCreateNestedManyWithoutSectionInput = {
    create?: XOR<PresentationCreateWithoutSectionInput, PresentationUncheckedCreateWithoutSectionInput> | PresentationCreateWithoutSectionInput[] | PresentationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutSectionInput | PresentationCreateOrConnectWithoutSectionInput[]
    createMany?: PresentationCreateManySectionInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type TimeSlotUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<TimeSlotCreateWithoutSectionInput, TimeSlotUncheckedCreateWithoutSectionInput> | TimeSlotCreateWithoutSectionInput[] | TimeSlotUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSectionInput | TimeSlotCreateOrConnectWithoutSectionInput[]
    createMany?: TimeSlotCreateManySectionInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type PresentationUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<PresentationCreateWithoutSectionInput, PresentationUncheckedCreateWithoutSectionInput> | PresentationCreateWithoutSectionInput[] | PresentationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutSectionInput | PresentationCreateOrConnectWithoutSectionInput[]
    createMany?: PresentationCreateManySectionInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SectionType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConferenceUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<ConferenceCreateWithoutSectionsInput, ConferenceUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutSectionsInput
    upsert?: ConferenceUpsertWithoutSectionsInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutSectionsInput, ConferenceUpdateWithoutSectionsInput>, ConferenceUncheckedUpdateWithoutSectionsInput>
  }

  export type DayUpdateOneWithoutSectionsNestedInput = {
    create?: XOR<DayCreateWithoutSectionsInput, DayUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: DayCreateOrConnectWithoutSectionsInput
    upsert?: DayUpsertWithoutSectionsInput
    disconnect?: DayWhereInput | boolean
    delete?: DayWhereInput | boolean
    connect?: DayWhereUniqueInput
    update?: XOR<XOR<DayUpdateToOneWithWhereWithoutSectionsInput, DayUpdateWithoutSectionsInput>, DayUncheckedUpdateWithoutSectionsInput>
  }

  export type CategoryUpdateOneWithoutSectionsNestedInput = {
    create?: XOR<CategoryCreateWithoutSectionsInput, CategoryUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSectionsInput
    upsert?: CategoryUpsertWithoutSectionsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSectionsInput, CategoryUpdateWithoutSectionsInput>, CategoryUncheckedUpdateWithoutSectionsInput>
  }

  export type TimeSlotUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TimeSlotCreateWithoutSectionInput, TimeSlotUncheckedCreateWithoutSectionInput> | TimeSlotCreateWithoutSectionInput[] | TimeSlotUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSectionInput | TimeSlotCreateOrConnectWithoutSectionInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutSectionInput | TimeSlotUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TimeSlotCreateManySectionInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutSectionInput | TimeSlotUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutSectionInput | TimeSlotUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type PresentationUpdateManyWithoutSectionNestedInput = {
    create?: XOR<PresentationCreateWithoutSectionInput, PresentationUncheckedCreateWithoutSectionInput> | PresentationCreateWithoutSectionInput[] | PresentationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutSectionInput | PresentationCreateOrConnectWithoutSectionInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutSectionInput | PresentationUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: PresentationCreateManySectionInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutSectionInput | PresentationUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutSectionInput | PresentationUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type TimeSlotUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TimeSlotCreateWithoutSectionInput, TimeSlotUncheckedCreateWithoutSectionInput> | TimeSlotCreateWithoutSectionInput[] | TimeSlotUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSectionInput | TimeSlotCreateOrConnectWithoutSectionInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutSectionInput | TimeSlotUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TimeSlotCreateManySectionInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutSectionInput | TimeSlotUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutSectionInput | TimeSlotUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type PresentationUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<PresentationCreateWithoutSectionInput, PresentationUncheckedCreateWithoutSectionInput> | PresentationCreateWithoutSectionInput[] | PresentationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutSectionInput | PresentationCreateOrConnectWithoutSectionInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutSectionInput | PresentationUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: PresentationCreateManySectionInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutSectionInput | PresentationUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutSectionInput | PresentationUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type SectionCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<SectionCreateWithoutTimeSlotsInput, SectionUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTimeSlotsInput
    connect?: SectionWhereUniqueInput
  }

  export type PresentationCreateNestedOneWithoutTimeSlotInput = {
    create?: XOR<PresentationCreateWithoutTimeSlotInput, PresentationUncheckedCreateWithoutTimeSlotInput>
    connectOrCreate?: PresentationCreateOrConnectWithoutTimeSlotInput
    connect?: PresentationWhereUniqueInput
  }

  export type EnumSlotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SlotType
  }

  export type NullableEnumBreakTypeFieldUpdateOperationsInput = {
    set?: $Enums.BreakType | null
  }

  export type SectionUpdateOneRequiredWithoutTimeSlotsNestedInput = {
    create?: XOR<SectionCreateWithoutTimeSlotsInput, SectionUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTimeSlotsInput
    upsert?: SectionUpsertWithoutTimeSlotsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTimeSlotsInput, SectionUpdateWithoutTimeSlotsInput>, SectionUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type PresentationUpdateOneWithoutTimeSlotNestedInput = {
    create?: XOR<PresentationCreateWithoutTimeSlotInput, PresentationUncheckedCreateWithoutTimeSlotInput>
    connectOrCreate?: PresentationCreateOrConnectWithoutTimeSlotInput
    upsert?: PresentationUpsertWithoutTimeSlotInput
    disconnect?: PresentationWhereInput | boolean
    delete?: PresentationWhereInput | boolean
    connect?: PresentationWhereUniqueInput
    update?: XOR<XOR<PresentationUpdateToOneWithWhereWithoutTimeSlotInput, PresentationUpdateWithoutTimeSlotInput>, PresentationUncheckedUpdateWithoutTimeSlotInput>
  }

  export type AbstractSubmissionCreatekeywordsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAbstractSubmissionsInput = {
    create?: XOR<UserCreateWithoutAbstractSubmissionsInput, UserUncheckedCreateWithoutAbstractSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbstractSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type ConferenceCreateNestedOneWithoutAbstractSubmissionsInput = {
    create?: XOR<ConferenceCreateWithoutAbstractSubmissionsInput, ConferenceUncheckedCreateWithoutAbstractSubmissionsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutAbstractSubmissionsInput
    connect?: ConferenceWhereUniqueInput
  }

  export type AbstractReviewCreateNestedManyWithoutAbstractInput = {
    create?: XOR<AbstractReviewCreateWithoutAbstractInput, AbstractReviewUncheckedCreateWithoutAbstractInput> | AbstractReviewCreateWithoutAbstractInput[] | AbstractReviewUncheckedCreateWithoutAbstractInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutAbstractInput | AbstractReviewCreateOrConnectWithoutAbstractInput[]
    createMany?: AbstractReviewCreateManyAbstractInputEnvelope
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
  }

  export type PresentationTypeCreateNestedOneWithoutAbstractSubmissionsInput = {
    create?: XOR<PresentationTypeCreateWithoutAbstractSubmissionsInput, PresentationTypeUncheckedCreateWithoutAbstractSubmissionsInput>
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutAbstractSubmissionsInput
    connect?: PresentationTypeWhereUniqueInput
  }

  export type AbstractReviewUncheckedCreateNestedManyWithoutAbstractInput = {
    create?: XOR<AbstractReviewCreateWithoutAbstractInput, AbstractReviewUncheckedCreateWithoutAbstractInput> | AbstractReviewCreateWithoutAbstractInput[] | AbstractReviewUncheckedCreateWithoutAbstractInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutAbstractInput | AbstractReviewCreateOrConnectWithoutAbstractInput[]
    createMany?: AbstractReviewCreateManyAbstractInputEnvelope
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
  }

  export type EnumAbstractSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AbstractSubmissionStatus
  }

  export type AbstractSubmissionUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAbstractSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutAbstractSubmissionsInput, UserUncheckedCreateWithoutAbstractSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbstractSubmissionsInput
    upsert?: UserUpsertWithoutAbstractSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAbstractSubmissionsInput, UserUpdateWithoutAbstractSubmissionsInput>, UserUncheckedUpdateWithoutAbstractSubmissionsInput>
  }

  export type ConferenceUpdateOneRequiredWithoutAbstractSubmissionsNestedInput = {
    create?: XOR<ConferenceCreateWithoutAbstractSubmissionsInput, ConferenceUncheckedCreateWithoutAbstractSubmissionsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutAbstractSubmissionsInput
    upsert?: ConferenceUpsertWithoutAbstractSubmissionsInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutAbstractSubmissionsInput, ConferenceUpdateWithoutAbstractSubmissionsInput>, ConferenceUncheckedUpdateWithoutAbstractSubmissionsInput>
  }

  export type AbstractReviewUpdateManyWithoutAbstractNestedInput = {
    create?: XOR<AbstractReviewCreateWithoutAbstractInput, AbstractReviewUncheckedCreateWithoutAbstractInput> | AbstractReviewCreateWithoutAbstractInput[] | AbstractReviewUncheckedCreateWithoutAbstractInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutAbstractInput | AbstractReviewCreateOrConnectWithoutAbstractInput[]
    upsert?: AbstractReviewUpsertWithWhereUniqueWithoutAbstractInput | AbstractReviewUpsertWithWhereUniqueWithoutAbstractInput[]
    createMany?: AbstractReviewCreateManyAbstractInputEnvelope
    set?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    disconnect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    delete?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    update?: AbstractReviewUpdateWithWhereUniqueWithoutAbstractInput | AbstractReviewUpdateWithWhereUniqueWithoutAbstractInput[]
    updateMany?: AbstractReviewUpdateManyWithWhereWithoutAbstractInput | AbstractReviewUpdateManyWithWhereWithoutAbstractInput[]
    deleteMany?: AbstractReviewScalarWhereInput | AbstractReviewScalarWhereInput[]
  }

  export type PresentationTypeUpdateOneWithoutAbstractSubmissionsNestedInput = {
    create?: XOR<PresentationTypeCreateWithoutAbstractSubmissionsInput, PresentationTypeUncheckedCreateWithoutAbstractSubmissionsInput>
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutAbstractSubmissionsInput
    upsert?: PresentationTypeUpsertWithoutAbstractSubmissionsInput
    disconnect?: PresentationTypeWhereInput | boolean
    delete?: PresentationTypeWhereInput | boolean
    connect?: PresentationTypeWhereUniqueInput
    update?: XOR<XOR<PresentationTypeUpdateToOneWithWhereWithoutAbstractSubmissionsInput, PresentationTypeUpdateWithoutAbstractSubmissionsInput>, PresentationTypeUncheckedUpdateWithoutAbstractSubmissionsInput>
  }

  export type AbstractReviewUncheckedUpdateManyWithoutAbstractNestedInput = {
    create?: XOR<AbstractReviewCreateWithoutAbstractInput, AbstractReviewUncheckedCreateWithoutAbstractInput> | AbstractReviewCreateWithoutAbstractInput[] | AbstractReviewUncheckedCreateWithoutAbstractInput[]
    connectOrCreate?: AbstractReviewCreateOrConnectWithoutAbstractInput | AbstractReviewCreateOrConnectWithoutAbstractInput[]
    upsert?: AbstractReviewUpsertWithWhereUniqueWithoutAbstractInput | AbstractReviewUpsertWithWhereUniqueWithoutAbstractInput[]
    createMany?: AbstractReviewCreateManyAbstractInputEnvelope
    set?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    disconnect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    delete?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    connect?: AbstractReviewWhereUniqueInput | AbstractReviewWhereUniqueInput[]
    update?: AbstractReviewUpdateWithWhereUniqueWithoutAbstractInput | AbstractReviewUpdateWithWhereUniqueWithoutAbstractInput[]
    updateMany?: AbstractReviewUpdateManyWithWhereWithoutAbstractInput | AbstractReviewUpdateManyWithWhereWithoutAbstractInput[]
    deleteMany?: AbstractReviewScalarWhereInput | AbstractReviewScalarWhereInput[]
  }

  export type AbstractSubmissionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<AbstractSubmissionCreateWithoutReviewsInput, AbstractSubmissionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutReviewsInput
    connect?: AbstractSubmissionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAbstractReviewsInput = {
    create?: XOR<UserCreateWithoutAbstractReviewsInput, UserUncheckedCreateWithoutAbstractReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbstractReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type AbstractSubmissionUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutReviewsInput, AbstractSubmissionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutReviewsInput
    upsert?: AbstractSubmissionUpsertWithoutReviewsInput
    connect?: AbstractSubmissionWhereUniqueInput
    update?: XOR<XOR<AbstractSubmissionUpdateToOneWithWhereWithoutReviewsInput, AbstractSubmissionUpdateWithoutReviewsInput>, AbstractSubmissionUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutAbstractReviewsNestedInput = {
    create?: XOR<UserCreateWithoutAbstractReviewsInput, UserUncheckedCreateWithoutAbstractReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbstractReviewsInput
    upsert?: UserUpsertWithoutAbstractReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAbstractReviewsInput, UserUpdateWithoutAbstractReviewsInput>, UserUncheckedUpdateWithoutAbstractReviewsInput>
  }

  export type ConferenceCreateNestedOneWithoutPresentationsInput = {
    create?: XOR<ConferenceCreateWithoutPresentationsInput, ConferenceUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutPresentationsInput
    connect?: ConferenceWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutPresentationsInput = {
    create?: XOR<SectionCreateWithoutPresentationsInput, SectionUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutPresentationsInput
    connect?: SectionWhereUniqueInput
  }

  export type PresentationAuthorCreateNestedManyWithoutPresentationInput = {
    create?: XOR<PresentationAuthorCreateWithoutPresentationInput, PresentationAuthorUncheckedCreateWithoutPresentationInput> | PresentationAuthorCreateWithoutPresentationInput[] | PresentationAuthorUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutPresentationInput | PresentationAuthorCreateOrConnectWithoutPresentationInput[]
    createMany?: PresentationAuthorCreateManyPresentationInputEnvelope
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutPresentationsInput = {
    create?: XOR<CategoryCreateWithoutPresentationsInput, CategoryUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPresentationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type PresentationTypeCreateNestedOneWithoutPresentationsInput = {
    create?: XOR<PresentationTypeCreateWithoutPresentationsInput, PresentationTypeUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutPresentationsInput
    connect?: PresentationTypeWhereUniqueInput
  }

  export type TimeSlotCreateNestedOneWithoutPresentationInput = {
    create?: XOR<TimeSlotCreateWithoutPresentationInput, TimeSlotUncheckedCreateWithoutPresentationInput>
    connectOrCreate?: TimeSlotCreateOrConnectWithoutPresentationInput
    connect?: TimeSlotWhereUniqueInput
  }

  export type PresentationFeedbackCreateNestedManyWithoutPresentationInput = {
    create?: XOR<PresentationFeedbackCreateWithoutPresentationInput, PresentationFeedbackUncheckedCreateWithoutPresentationInput> | PresentationFeedbackCreateWithoutPresentationInput[] | PresentationFeedbackUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutPresentationInput | PresentationFeedbackCreateOrConnectWithoutPresentationInput[]
    createMany?: PresentationFeedbackCreateManyPresentationInputEnvelope
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
  }

  export type PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput = {
    create?: XOR<PresentationAuthorCreateWithoutPresentationInput, PresentationAuthorUncheckedCreateWithoutPresentationInput> | PresentationAuthorCreateWithoutPresentationInput[] | PresentationAuthorUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutPresentationInput | PresentationAuthorCreateOrConnectWithoutPresentationInput[]
    createMany?: PresentationAuthorCreateManyPresentationInputEnvelope
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
  }

  export type TimeSlotUncheckedCreateNestedOneWithoutPresentationInput = {
    create?: XOR<TimeSlotCreateWithoutPresentationInput, TimeSlotUncheckedCreateWithoutPresentationInput>
    connectOrCreate?: TimeSlotCreateOrConnectWithoutPresentationInput
    connect?: TimeSlotWhereUniqueInput
  }

  export type PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput = {
    create?: XOR<PresentationFeedbackCreateWithoutPresentationInput, PresentationFeedbackUncheckedCreateWithoutPresentationInput> | PresentationFeedbackCreateWithoutPresentationInput[] | PresentationFeedbackUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutPresentationInput | PresentationFeedbackCreateOrConnectWithoutPresentationInput[]
    createMany?: PresentationFeedbackCreateManyPresentationInputEnvelope
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
  }

  export type ConferenceUpdateOneRequiredWithoutPresentationsNestedInput = {
    create?: XOR<ConferenceCreateWithoutPresentationsInput, ConferenceUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutPresentationsInput
    upsert?: ConferenceUpsertWithoutPresentationsInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutPresentationsInput, ConferenceUpdateWithoutPresentationsInput>, ConferenceUncheckedUpdateWithoutPresentationsInput>
  }

  export type SectionUpdateOneWithoutPresentationsNestedInput = {
    create?: XOR<SectionCreateWithoutPresentationsInput, SectionUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutPresentationsInput
    upsert?: SectionUpsertWithoutPresentationsInput
    disconnect?: SectionWhereInput | boolean
    delete?: SectionWhereInput | boolean
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutPresentationsInput, SectionUpdateWithoutPresentationsInput>, SectionUncheckedUpdateWithoutPresentationsInput>
  }

  export type PresentationAuthorUpdateManyWithoutPresentationNestedInput = {
    create?: XOR<PresentationAuthorCreateWithoutPresentationInput, PresentationAuthorUncheckedCreateWithoutPresentationInput> | PresentationAuthorCreateWithoutPresentationInput[] | PresentationAuthorUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutPresentationInput | PresentationAuthorCreateOrConnectWithoutPresentationInput[]
    upsert?: PresentationAuthorUpsertWithWhereUniqueWithoutPresentationInput | PresentationAuthorUpsertWithWhereUniqueWithoutPresentationInput[]
    createMany?: PresentationAuthorCreateManyPresentationInputEnvelope
    set?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    disconnect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    delete?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    update?: PresentationAuthorUpdateWithWhereUniqueWithoutPresentationInput | PresentationAuthorUpdateWithWhereUniqueWithoutPresentationInput[]
    updateMany?: PresentationAuthorUpdateManyWithWhereWithoutPresentationInput | PresentationAuthorUpdateManyWithWhereWithoutPresentationInput[]
    deleteMany?: PresentationAuthorScalarWhereInput | PresentationAuthorScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutPresentationsNestedInput = {
    create?: XOR<CategoryCreateWithoutPresentationsInput, CategoryUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPresentationsInput
    upsert?: CategoryUpsertWithoutPresentationsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPresentationsInput, CategoryUpdateWithoutPresentationsInput>, CategoryUncheckedUpdateWithoutPresentationsInput>
  }

  export type PresentationTypeUpdateOneWithoutPresentationsNestedInput = {
    create?: XOR<PresentationTypeCreateWithoutPresentationsInput, PresentationTypeUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: PresentationTypeCreateOrConnectWithoutPresentationsInput
    upsert?: PresentationTypeUpsertWithoutPresentationsInput
    disconnect?: PresentationTypeWhereInput | boolean
    delete?: PresentationTypeWhereInput | boolean
    connect?: PresentationTypeWhereUniqueInput
    update?: XOR<XOR<PresentationTypeUpdateToOneWithWhereWithoutPresentationsInput, PresentationTypeUpdateWithoutPresentationsInput>, PresentationTypeUncheckedUpdateWithoutPresentationsInput>
  }

  export type TimeSlotUpdateOneWithoutPresentationNestedInput = {
    create?: XOR<TimeSlotCreateWithoutPresentationInput, TimeSlotUncheckedCreateWithoutPresentationInput>
    connectOrCreate?: TimeSlotCreateOrConnectWithoutPresentationInput
    upsert?: TimeSlotUpsertWithoutPresentationInput
    disconnect?: TimeSlotWhereInput | boolean
    delete?: TimeSlotWhereInput | boolean
    connect?: TimeSlotWhereUniqueInput
    update?: XOR<XOR<TimeSlotUpdateToOneWithWhereWithoutPresentationInput, TimeSlotUpdateWithoutPresentationInput>, TimeSlotUncheckedUpdateWithoutPresentationInput>
  }

  export type PresentationFeedbackUpdateManyWithoutPresentationNestedInput = {
    create?: XOR<PresentationFeedbackCreateWithoutPresentationInput, PresentationFeedbackUncheckedCreateWithoutPresentationInput> | PresentationFeedbackCreateWithoutPresentationInput[] | PresentationFeedbackUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutPresentationInput | PresentationFeedbackCreateOrConnectWithoutPresentationInput[]
    upsert?: PresentationFeedbackUpsertWithWhereUniqueWithoutPresentationInput | PresentationFeedbackUpsertWithWhereUniqueWithoutPresentationInput[]
    createMany?: PresentationFeedbackCreateManyPresentationInputEnvelope
    set?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    disconnect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    delete?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    update?: PresentationFeedbackUpdateWithWhereUniqueWithoutPresentationInput | PresentationFeedbackUpdateWithWhereUniqueWithoutPresentationInput[]
    updateMany?: PresentationFeedbackUpdateManyWithWhereWithoutPresentationInput | PresentationFeedbackUpdateManyWithWhereWithoutPresentationInput[]
    deleteMany?: PresentationFeedbackScalarWhereInput | PresentationFeedbackScalarWhereInput[]
  }

  export type PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput = {
    create?: XOR<PresentationAuthorCreateWithoutPresentationInput, PresentationAuthorUncheckedCreateWithoutPresentationInput> | PresentationAuthorCreateWithoutPresentationInput[] | PresentationAuthorUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationAuthorCreateOrConnectWithoutPresentationInput | PresentationAuthorCreateOrConnectWithoutPresentationInput[]
    upsert?: PresentationAuthorUpsertWithWhereUniqueWithoutPresentationInput | PresentationAuthorUpsertWithWhereUniqueWithoutPresentationInput[]
    createMany?: PresentationAuthorCreateManyPresentationInputEnvelope
    set?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    disconnect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    delete?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    connect?: PresentationAuthorWhereUniqueInput | PresentationAuthorWhereUniqueInput[]
    update?: PresentationAuthorUpdateWithWhereUniqueWithoutPresentationInput | PresentationAuthorUpdateWithWhereUniqueWithoutPresentationInput[]
    updateMany?: PresentationAuthorUpdateManyWithWhereWithoutPresentationInput | PresentationAuthorUpdateManyWithWhereWithoutPresentationInput[]
    deleteMany?: PresentationAuthorScalarWhereInput | PresentationAuthorScalarWhereInput[]
  }

  export type TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput = {
    create?: XOR<TimeSlotCreateWithoutPresentationInput, TimeSlotUncheckedCreateWithoutPresentationInput>
    connectOrCreate?: TimeSlotCreateOrConnectWithoutPresentationInput
    upsert?: TimeSlotUpsertWithoutPresentationInput
    disconnect?: TimeSlotWhereInput | boolean
    delete?: TimeSlotWhereInput | boolean
    connect?: TimeSlotWhereUniqueInput
    update?: XOR<XOR<TimeSlotUpdateToOneWithWhereWithoutPresentationInput, TimeSlotUpdateWithoutPresentationInput>, TimeSlotUncheckedUpdateWithoutPresentationInput>
  }

  export type PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput = {
    create?: XOR<PresentationFeedbackCreateWithoutPresentationInput, PresentationFeedbackUncheckedCreateWithoutPresentationInput> | PresentationFeedbackCreateWithoutPresentationInput[] | PresentationFeedbackUncheckedCreateWithoutPresentationInput[]
    connectOrCreate?: PresentationFeedbackCreateOrConnectWithoutPresentationInput | PresentationFeedbackCreateOrConnectWithoutPresentationInput[]
    upsert?: PresentationFeedbackUpsertWithWhereUniqueWithoutPresentationInput | PresentationFeedbackUpsertWithWhereUniqueWithoutPresentationInput[]
    createMany?: PresentationFeedbackCreateManyPresentationInputEnvelope
    set?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    disconnect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    delete?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    connect?: PresentationFeedbackWhereUniqueInput | PresentationFeedbackWhereUniqueInput[]
    update?: PresentationFeedbackUpdateWithWhereUniqueWithoutPresentationInput | PresentationFeedbackUpdateWithWhereUniqueWithoutPresentationInput[]
    updateMany?: PresentationFeedbackUpdateManyWithWhereWithoutPresentationInput | PresentationFeedbackUpdateManyWithWhereWithoutPresentationInput[]
    deleteMany?: PresentationFeedbackScalarWhereInput | PresentationFeedbackScalarWhereInput[]
  }

  export type PresentationCreateNestedOneWithoutAuthorsInput = {
    create?: XOR<PresentationCreateWithoutAuthorsInput, PresentationUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: PresentationCreateOrConnectWithoutAuthorsInput
    connect?: PresentationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPresentationsInput = {
    create?: XOR<UserCreateWithoutPresentationsInput, UserUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPresentationsInput
    connect?: UserWhereUniqueInput
  }

  export type PresentationUpdateOneRequiredWithoutAuthorsNestedInput = {
    create?: XOR<PresentationCreateWithoutAuthorsInput, PresentationUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: PresentationCreateOrConnectWithoutAuthorsInput
    upsert?: PresentationUpsertWithoutAuthorsInput
    connect?: PresentationWhereUniqueInput
    update?: XOR<XOR<PresentationUpdateToOneWithWhereWithoutAuthorsInput, PresentationUpdateWithoutAuthorsInput>, PresentationUncheckedUpdateWithoutAuthorsInput>
  }

  export type UserUpdateOneWithoutPresentationsNestedInput = {
    create?: XOR<UserCreateWithoutPresentationsInput, UserUncheckedCreateWithoutPresentationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPresentationsInput
    upsert?: UserUpsertWithoutPresentationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPresentationsInput, UserUpdateWithoutPresentationsInput>, UserUncheckedUpdateWithoutPresentationsInput>
  }

  export type ConferenceCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ConferenceCreateWithoutCategoriesInput, ConferenceUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutCategoriesInput
    connect?: ConferenceWhereUniqueInput
  }

  export type PresentationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PresentationCreateWithoutCategoryInput, PresentationUncheckedCreateWithoutCategoryInput> | PresentationCreateWithoutCategoryInput[] | PresentationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutCategoryInput | PresentationCreateOrConnectWithoutCategoryInput[]
    createMany?: PresentationCreateManyCategoryInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SectionCreateWithoutCategoryInput, SectionUncheckedCreateWithoutCategoryInput> | SectionCreateWithoutCategoryInput[] | SectionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCategoryInput | SectionCreateOrConnectWithoutCategoryInput[]
    createMany?: SectionCreateManyCategoryInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type PresentationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PresentationCreateWithoutCategoryInput, PresentationUncheckedCreateWithoutCategoryInput> | PresentationCreateWithoutCategoryInput[] | PresentationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutCategoryInput | PresentationCreateOrConnectWithoutCategoryInput[]
    createMany?: PresentationCreateManyCategoryInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SectionCreateWithoutCategoryInput, SectionUncheckedCreateWithoutCategoryInput> | SectionCreateWithoutCategoryInput[] | SectionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCategoryInput | SectionCreateOrConnectWithoutCategoryInput[]
    createMany?: SectionCreateManyCategoryInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type ConferenceUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ConferenceCreateWithoutCategoriesInput, ConferenceUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutCategoriesInput
    upsert?: ConferenceUpsertWithoutCategoriesInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutCategoriesInput, ConferenceUpdateWithoutCategoriesInput>, ConferenceUncheckedUpdateWithoutCategoriesInput>
  }

  export type PresentationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PresentationCreateWithoutCategoryInput, PresentationUncheckedCreateWithoutCategoryInput> | PresentationCreateWithoutCategoryInput[] | PresentationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutCategoryInput | PresentationCreateOrConnectWithoutCategoryInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutCategoryInput | PresentationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PresentationCreateManyCategoryInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutCategoryInput | PresentationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutCategoryInput | PresentationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SectionCreateWithoutCategoryInput, SectionUncheckedCreateWithoutCategoryInput> | SectionCreateWithoutCategoryInput[] | SectionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCategoryInput | SectionCreateOrConnectWithoutCategoryInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutCategoryInput | SectionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SectionCreateManyCategoryInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutCategoryInput | SectionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutCategoryInput | SectionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type PresentationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PresentationCreateWithoutCategoryInput, PresentationUncheckedCreateWithoutCategoryInput> | PresentationCreateWithoutCategoryInput[] | PresentationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutCategoryInput | PresentationCreateOrConnectWithoutCategoryInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutCategoryInput | PresentationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PresentationCreateManyCategoryInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutCategoryInput | PresentationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutCategoryInput | PresentationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SectionCreateWithoutCategoryInput, SectionUncheckedCreateWithoutCategoryInput> | SectionCreateWithoutCategoryInput[] | SectionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCategoryInput | SectionCreateOrConnectWithoutCategoryInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutCategoryInput | SectionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SectionCreateManyCategoryInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutCategoryInput | SectionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutCategoryInput | SectionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type ConferenceCreateNestedOneWithoutPresentationTypesInput = {
    create?: XOR<ConferenceCreateWithoutPresentationTypesInput, ConferenceUncheckedCreateWithoutPresentationTypesInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutPresentationTypesInput
    connect?: ConferenceWhereUniqueInput
  }

  export type PresentationCreateNestedManyWithoutPresentationTypeInput = {
    create?: XOR<PresentationCreateWithoutPresentationTypeInput, PresentationUncheckedCreateWithoutPresentationTypeInput> | PresentationCreateWithoutPresentationTypeInput[] | PresentationUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutPresentationTypeInput | PresentationCreateOrConnectWithoutPresentationTypeInput[]
    createMany?: PresentationCreateManyPresentationTypeInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type AbstractSubmissionCreateNestedManyWithoutPresentationTypeInput = {
    create?: XOR<AbstractSubmissionCreateWithoutPresentationTypeInput, AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput> | AbstractSubmissionCreateWithoutPresentationTypeInput[] | AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput | AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput[]
    createMany?: AbstractSubmissionCreateManyPresentationTypeInputEnvelope
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
  }

  export type PresentationUncheckedCreateNestedManyWithoutPresentationTypeInput = {
    create?: XOR<PresentationCreateWithoutPresentationTypeInput, PresentationUncheckedCreateWithoutPresentationTypeInput> | PresentationCreateWithoutPresentationTypeInput[] | PresentationUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutPresentationTypeInput | PresentationCreateOrConnectWithoutPresentationTypeInput[]
    createMany?: PresentationCreateManyPresentationTypeInputEnvelope
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
  }

  export type AbstractSubmissionUncheckedCreateNestedManyWithoutPresentationTypeInput = {
    create?: XOR<AbstractSubmissionCreateWithoutPresentationTypeInput, AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput> | AbstractSubmissionCreateWithoutPresentationTypeInput[] | AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput | AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput[]
    createMany?: AbstractSubmissionCreateManyPresentationTypeInputEnvelope
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
  }

  export type ConferenceUpdateOneRequiredWithoutPresentationTypesNestedInput = {
    create?: XOR<ConferenceCreateWithoutPresentationTypesInput, ConferenceUncheckedCreateWithoutPresentationTypesInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutPresentationTypesInput
    upsert?: ConferenceUpsertWithoutPresentationTypesInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutPresentationTypesInput, ConferenceUpdateWithoutPresentationTypesInput>, ConferenceUncheckedUpdateWithoutPresentationTypesInput>
  }

  export type PresentationUpdateManyWithoutPresentationTypeNestedInput = {
    create?: XOR<PresentationCreateWithoutPresentationTypeInput, PresentationUncheckedCreateWithoutPresentationTypeInput> | PresentationCreateWithoutPresentationTypeInput[] | PresentationUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutPresentationTypeInput | PresentationCreateOrConnectWithoutPresentationTypeInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutPresentationTypeInput | PresentationUpsertWithWhereUniqueWithoutPresentationTypeInput[]
    createMany?: PresentationCreateManyPresentationTypeInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutPresentationTypeInput | PresentationUpdateWithWhereUniqueWithoutPresentationTypeInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutPresentationTypeInput | PresentationUpdateManyWithWhereWithoutPresentationTypeInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type AbstractSubmissionUpdateManyWithoutPresentationTypeNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutPresentationTypeInput, AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput> | AbstractSubmissionCreateWithoutPresentationTypeInput[] | AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput | AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput[]
    upsert?: AbstractSubmissionUpsertWithWhereUniqueWithoutPresentationTypeInput | AbstractSubmissionUpsertWithWhereUniqueWithoutPresentationTypeInput[]
    createMany?: AbstractSubmissionCreateManyPresentationTypeInputEnvelope
    set?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    disconnect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    delete?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    update?: AbstractSubmissionUpdateWithWhereUniqueWithoutPresentationTypeInput | AbstractSubmissionUpdateWithWhereUniqueWithoutPresentationTypeInput[]
    updateMany?: AbstractSubmissionUpdateManyWithWhereWithoutPresentationTypeInput | AbstractSubmissionUpdateManyWithWhereWithoutPresentationTypeInput[]
    deleteMany?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
  }

  export type PresentationUncheckedUpdateManyWithoutPresentationTypeNestedInput = {
    create?: XOR<PresentationCreateWithoutPresentationTypeInput, PresentationUncheckedCreateWithoutPresentationTypeInput> | PresentationCreateWithoutPresentationTypeInput[] | PresentationUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: PresentationCreateOrConnectWithoutPresentationTypeInput | PresentationCreateOrConnectWithoutPresentationTypeInput[]
    upsert?: PresentationUpsertWithWhereUniqueWithoutPresentationTypeInput | PresentationUpsertWithWhereUniqueWithoutPresentationTypeInput[]
    createMany?: PresentationCreateManyPresentationTypeInputEnvelope
    set?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    disconnect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    delete?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    connect?: PresentationWhereUniqueInput | PresentationWhereUniqueInput[]
    update?: PresentationUpdateWithWhereUniqueWithoutPresentationTypeInput | PresentationUpdateWithWhereUniqueWithoutPresentationTypeInput[]
    updateMany?: PresentationUpdateManyWithWhereWithoutPresentationTypeInput | PresentationUpdateManyWithWhereWithoutPresentationTypeInput[]
    deleteMany?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
  }

  export type AbstractSubmissionUncheckedUpdateManyWithoutPresentationTypeNestedInput = {
    create?: XOR<AbstractSubmissionCreateWithoutPresentationTypeInput, AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput> | AbstractSubmissionCreateWithoutPresentationTypeInput[] | AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput[]
    connectOrCreate?: AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput | AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput[]
    upsert?: AbstractSubmissionUpsertWithWhereUniqueWithoutPresentationTypeInput | AbstractSubmissionUpsertWithWhereUniqueWithoutPresentationTypeInput[]
    createMany?: AbstractSubmissionCreateManyPresentationTypeInputEnvelope
    set?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    disconnect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    delete?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    connect?: AbstractSubmissionWhereUniqueInput | AbstractSubmissionWhereUniqueInput[]
    update?: AbstractSubmissionUpdateWithWhereUniqueWithoutPresentationTypeInput | AbstractSubmissionUpdateWithWhereUniqueWithoutPresentationTypeInput[]
    updateMany?: AbstractSubmissionUpdateManyWithWhereWithoutPresentationTypeInput | AbstractSubmissionUpdateManyWithWhereWithoutPresentationTypeInput[]
    deleteMany?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
  }

  export type SubmissionSettingsCreateallowedFileTypesInput = {
    set: string[]
  }

  export type ConferenceCreateNestedOneWithoutSubmissionSettingsInput = {
    create?: XOR<ConferenceCreateWithoutSubmissionSettingsInput, ConferenceUncheckedCreateWithoutSubmissionSettingsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutSubmissionSettingsInput
    connect?: ConferenceWhereUniqueInput
  }

  export type SubmissionSettingsUpdateallowedFileTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConferenceUpdateOneRequiredWithoutSubmissionSettingsNestedInput = {
    create?: XOR<ConferenceCreateWithoutSubmissionSettingsInput, ConferenceUncheckedCreateWithoutSubmissionSettingsInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutSubmissionSettingsInput
    upsert?: ConferenceUpsertWithoutSubmissionSettingsInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutSubmissionSettingsInput, ConferenceUpdateWithoutSubmissionSettingsInput>, ConferenceUncheckedUpdateWithoutSubmissionSettingsInput>
  }

  export type ConferenceCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<ConferenceCreateWithoutFeedbackInput, ConferenceUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutFeedbackInput
    connect?: ConferenceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConferenceFeedbackInput = {
    create?: XOR<UserCreateWithoutConferenceFeedbackInput, UserUncheckedCreateWithoutConferenceFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferenceFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type ConferenceUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<ConferenceCreateWithoutFeedbackInput, ConferenceUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ConferenceCreateOrConnectWithoutFeedbackInput
    upsert?: ConferenceUpsertWithoutFeedbackInput
    connect?: ConferenceWhereUniqueInput
    update?: XOR<XOR<ConferenceUpdateToOneWithWhereWithoutFeedbackInput, ConferenceUpdateWithoutFeedbackInput>, ConferenceUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneRequiredWithoutConferenceFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutConferenceFeedbackInput, UserUncheckedCreateWithoutConferenceFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferenceFeedbackInput
    upsert?: UserUpsertWithoutConferenceFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConferenceFeedbackInput, UserUpdateWithoutConferenceFeedbackInput>, UserUncheckedUpdateWithoutConferenceFeedbackInput>
  }

  export type PresentationCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<PresentationCreateWithoutFeedbackInput, PresentationUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: PresentationCreateOrConnectWithoutFeedbackInput
    connect?: PresentationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPresentationFeedbackInput = {
    create?: XOR<UserCreateWithoutPresentationFeedbackInput, UserUncheckedCreateWithoutPresentationFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutPresentationFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type PresentationUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<PresentationCreateWithoutFeedbackInput, PresentationUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: PresentationCreateOrConnectWithoutFeedbackInput
    upsert?: PresentationUpsertWithoutFeedbackInput
    connect?: PresentationWhereUniqueInput
    update?: XOR<XOR<PresentationUpdateToOneWithWhereWithoutFeedbackInput, PresentationUpdateWithoutFeedbackInput>, PresentationUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneRequiredWithoutPresentationFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutPresentationFeedbackInput, UserUncheckedCreateWithoutPresentationFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutPresentationFeedbackInput
    upsert?: UserUpsertWithoutPresentationFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPresentationFeedbackInput, UserUpdateWithoutPresentationFeedbackInput>, UserUncheckedUpdateWithoutPresentationFeedbackInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumConferenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceStatus | EnumConferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceStatusFilter<$PrismaModel> | $Enums.ConferenceStatus
  }

  export type NestedEnumConferenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConferenceStatus | EnumConferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConferenceStatus[] | ListEnumConferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConferenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConferenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConferenceStatusFilter<$PrismaModel>
    _max?: NestedEnumConferenceStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSectionTypeFilter<$PrismaModel> | $Enums.SectionType
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectionType[] | ListEnumSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectionTypeFilter<$PrismaModel>
    _max?: NestedEnumSectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type NestedEnumBreakTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BreakType | EnumBreakTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBreakTypeNullableFilter<$PrismaModel> | $Enums.BreakType | null
  }

  export type NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type NestedEnumBreakTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BreakType | EnumBreakTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BreakType[] | ListEnumBreakTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBreakTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.BreakType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBreakTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumBreakTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAbstractSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AbstractSubmissionStatus | EnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAbstractSubmissionStatusFilter<$PrismaModel> | $Enums.AbstractSubmissionStatus
  }

  export type NestedEnumAbstractSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbstractSubmissionStatus | EnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbstractSubmissionStatus[] | ListEnumAbstractSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAbstractSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AbstractSubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbstractSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumAbstractSubmissionStatusFilter<$PrismaModel>
  }

  export type ConferenceCreateWithoutCreatedByInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutCreatedByInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutCreatedByInput, ConferenceUncheckedCreateWithoutCreatedByInput>
  }

  export type ConferenceCreateManyCreatedByInputEnvelope = {
    data: ConferenceCreateManyCreatedByInput | ConferenceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceMemberCreateWithoutUserInput = {
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutMembersInput
  }

  export type ConferenceMemberUncheckedCreateWithoutUserInput = {
    id?: number
    conferenceId: number
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
  }

  export type ConferenceMemberCreateOrConnectWithoutUserInput = {
    where: ConferenceMemberWhereUniqueInput
    create: XOR<ConferenceMemberCreateWithoutUserInput, ConferenceMemberUncheckedCreateWithoutUserInput>
  }

  export type ConferenceMemberCreateManyUserInputEnvelope = {
    data: ConferenceMemberCreateManyUserInput | ConferenceMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AbstractSubmissionCreateWithoutSubmitterInput = {
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutAbstractSubmissionsInput
    reviews?: AbstractReviewCreateNestedManyWithoutAbstractInput
    presentationType?: PresentationTypeCreateNestedOneWithoutAbstractSubmissionsInput
  }

  export type AbstractSubmissionUncheckedCreateWithoutSubmitterInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
    reviews?: AbstractReviewUncheckedCreateNestedManyWithoutAbstractInput
  }

  export type AbstractSubmissionCreateOrConnectWithoutSubmitterInput = {
    where: AbstractSubmissionWhereUniqueInput
    create: XOR<AbstractSubmissionCreateWithoutSubmitterInput, AbstractSubmissionUncheckedCreateWithoutSubmitterInput>
  }

  export type AbstractSubmissionCreateManySubmitterInputEnvelope = {
    data: AbstractSubmissionCreateManySubmitterInput | AbstractSubmissionCreateManySubmitterInput[]
    skipDuplicates?: boolean
  }

  export type AbstractReviewCreateWithoutReviewerInput = {
    score: number
    comments?: string | null
    recommendation: string
    abstract: AbstractSubmissionCreateNestedOneWithoutReviewsInput
  }

  export type AbstractReviewUncheckedCreateWithoutReviewerInput = {
    id?: number
    abstractId: number
    score: number
    comments?: string | null
    recommendation: string
  }

  export type AbstractReviewCreateOrConnectWithoutReviewerInput = {
    where: AbstractReviewWhereUniqueInput
    create: XOR<AbstractReviewCreateWithoutReviewerInput, AbstractReviewUncheckedCreateWithoutReviewerInput>
  }

  export type AbstractReviewCreateManyReviewerInputEnvelope = {
    data: AbstractReviewCreateManyReviewerInput | AbstractReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type PresentationAuthorCreateWithoutUserInput = {
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
    presentation: PresentationCreateNestedOneWithoutAuthorsInput
  }

  export type PresentationAuthorUncheckedCreateWithoutUserInput = {
    id?: number
    presentationId: number
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type PresentationAuthorCreateOrConnectWithoutUserInput = {
    where: PresentationAuthorWhereUniqueInput
    create: XOR<PresentationAuthorCreateWithoutUserInput, PresentationAuthorUncheckedCreateWithoutUserInput>
  }

  export type PresentationAuthorCreateManyUserInputEnvelope = {
    data: PresentationAuthorCreateManyUserInput | PresentationAuthorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFeedbackCreateWithoutUserInput = {
    rating: number
    comments?: string | null
    submittedAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutFeedbackInput
  }

  export type ConferenceFeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    conferenceId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type ConferenceFeedbackCreateOrConnectWithoutUserInput = {
    where: ConferenceFeedbackWhereUniqueInput
    create: XOR<ConferenceFeedbackCreateWithoutUserInput, ConferenceFeedbackUncheckedCreateWithoutUserInput>
  }

  export type ConferenceFeedbackCreateManyUserInputEnvelope = {
    data: ConferenceFeedbackCreateManyUserInput | ConferenceFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PresentationFeedbackCreateWithoutUserInput = {
    rating: number
    comments?: string | null
    submittedAt?: Date | string
    presentation: PresentationCreateNestedOneWithoutFeedbackInput
  }

  export type PresentationFeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    presentationId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PresentationFeedbackCreateOrConnectWithoutUserInput = {
    where: PresentationFeedbackWhereUniqueInput
    create: XOR<PresentationFeedbackCreateWithoutUserInput, PresentationFeedbackUncheckedCreateWithoutUserInput>
  }

  export type PresentationFeedbackCreateManyUserInputEnvelope = {
    data: PresentationFeedbackCreateManyUserInput | PresentationFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    tokenHash: string
    createdAt?: Date | string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: number
    tokenHash: string
    createdAt?: Date | string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ConferenceWhereUniqueInput
    update: XOR<ConferenceUpdateWithoutCreatedByInput, ConferenceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ConferenceCreateWithoutCreatedByInput, ConferenceUncheckedCreateWithoutCreatedByInput>
  }

  export type ConferenceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ConferenceWhereUniqueInput
    data: XOR<ConferenceUpdateWithoutCreatedByInput, ConferenceUncheckedUpdateWithoutCreatedByInput>
  }

  export type ConferenceUpdateManyWithWhereWithoutCreatedByInput = {
    where: ConferenceScalarWhereInput
    data: XOR<ConferenceUpdateManyMutationInput, ConferenceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ConferenceScalarWhereInput = {
    AND?: ConferenceScalarWhereInput | ConferenceScalarWhereInput[]
    OR?: ConferenceScalarWhereInput[]
    NOT?: ConferenceScalarWhereInput | ConferenceScalarWhereInput[]
    id?: IntFilter<"Conference"> | number
    name?: StringFilter<"Conference"> | string
    description?: StringNullableFilter<"Conference"> | string | null
    startDate?: DateTimeFilter<"Conference"> | Date | string
    endDate?: DateTimeFilter<"Conference"> | Date | string
    location?: StringNullableFilter<"Conference"> | string | null
    status?: EnumConferenceStatusFilter<"Conference"> | $Enums.ConferenceStatus
    topics?: StringNullableListFilter<"Conference">
    createdById?: IntFilter<"Conference"> | number
    createdAt?: DateTimeFilter<"Conference"> | Date | string
    updatedAt?: DateTimeFilter<"Conference"> | Date | string
  }

  export type ConferenceMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ConferenceMemberWhereUniqueInput
    update: XOR<ConferenceMemberUpdateWithoutUserInput, ConferenceMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ConferenceMemberCreateWithoutUserInput, ConferenceMemberUncheckedCreateWithoutUserInput>
  }

  export type ConferenceMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ConferenceMemberWhereUniqueInput
    data: XOR<ConferenceMemberUpdateWithoutUserInput, ConferenceMemberUncheckedUpdateWithoutUserInput>
  }

  export type ConferenceMemberUpdateManyWithWhereWithoutUserInput = {
    where: ConferenceMemberScalarWhereInput
    data: XOR<ConferenceMemberUpdateManyMutationInput, ConferenceMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ConferenceMemberScalarWhereInput = {
    AND?: ConferenceMemberScalarWhereInput | ConferenceMemberScalarWhereInput[]
    OR?: ConferenceMemberScalarWhereInput[]
    NOT?: ConferenceMemberScalarWhereInput | ConferenceMemberScalarWhereInput[]
    id?: IntFilter<"ConferenceMember"> | number
    conferenceId?: IntFilter<"ConferenceMember"> | number
    userId?: IntFilter<"ConferenceMember"> | number
    isAttendee?: BoolFilter<"ConferenceMember"> | boolean
    isSpeaker?: BoolFilter<"ConferenceMember"> | boolean
    registeredAt?: DateTimeFilter<"ConferenceMember"> | Date | string
  }

  export type AbstractSubmissionUpsertWithWhereUniqueWithoutSubmitterInput = {
    where: AbstractSubmissionWhereUniqueInput
    update: XOR<AbstractSubmissionUpdateWithoutSubmitterInput, AbstractSubmissionUncheckedUpdateWithoutSubmitterInput>
    create: XOR<AbstractSubmissionCreateWithoutSubmitterInput, AbstractSubmissionUncheckedCreateWithoutSubmitterInput>
  }

  export type AbstractSubmissionUpdateWithWhereUniqueWithoutSubmitterInput = {
    where: AbstractSubmissionWhereUniqueInput
    data: XOR<AbstractSubmissionUpdateWithoutSubmitterInput, AbstractSubmissionUncheckedUpdateWithoutSubmitterInput>
  }

  export type AbstractSubmissionUpdateManyWithWhereWithoutSubmitterInput = {
    where: AbstractSubmissionScalarWhereInput
    data: XOR<AbstractSubmissionUpdateManyMutationInput, AbstractSubmissionUncheckedUpdateManyWithoutSubmitterInput>
  }

  export type AbstractSubmissionScalarWhereInput = {
    AND?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
    OR?: AbstractSubmissionScalarWhereInput[]
    NOT?: AbstractSubmissionScalarWhereInput | AbstractSubmissionScalarWhereInput[]
    id?: IntFilter<"AbstractSubmission"> | number
    title?: StringFilter<"AbstractSubmission"> | string
    abstractText?: StringNullableFilter<"AbstractSubmission"> | string | null
    fileUrl?: StringNullableFilter<"AbstractSubmission"> | string | null
    submitterId?: IntFilter<"AbstractSubmission"> | number
    conferenceId?: IntFilter<"AbstractSubmission"> | number
    status?: EnumAbstractSubmissionStatusFilter<"AbstractSubmission"> | $Enums.AbstractSubmissionStatus
    keywords?: StringNullableListFilter<"AbstractSubmission">
    createdAt?: DateTimeFilter<"AbstractSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AbstractSubmission"> | Date | string
    presentationTypeId?: IntNullableFilter<"AbstractSubmission"> | number | null
  }

  export type AbstractReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: AbstractReviewWhereUniqueInput
    update: XOR<AbstractReviewUpdateWithoutReviewerInput, AbstractReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<AbstractReviewCreateWithoutReviewerInput, AbstractReviewUncheckedCreateWithoutReviewerInput>
  }

  export type AbstractReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: AbstractReviewWhereUniqueInput
    data: XOR<AbstractReviewUpdateWithoutReviewerInput, AbstractReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type AbstractReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: AbstractReviewScalarWhereInput
    data: XOR<AbstractReviewUpdateManyMutationInput, AbstractReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type AbstractReviewScalarWhereInput = {
    AND?: AbstractReviewScalarWhereInput | AbstractReviewScalarWhereInput[]
    OR?: AbstractReviewScalarWhereInput[]
    NOT?: AbstractReviewScalarWhereInput | AbstractReviewScalarWhereInput[]
    id?: IntFilter<"AbstractReview"> | number
    abstractId?: IntFilter<"AbstractReview"> | number
    reviewerId?: IntFilter<"AbstractReview"> | number
    score?: IntFilter<"AbstractReview"> | number
    comments?: StringNullableFilter<"AbstractReview"> | string | null
    recommendation?: StringFilter<"AbstractReview"> | string
  }

  export type PresentationAuthorUpsertWithWhereUniqueWithoutUserInput = {
    where: PresentationAuthorWhereUniqueInput
    update: XOR<PresentationAuthorUpdateWithoutUserInput, PresentationAuthorUncheckedUpdateWithoutUserInput>
    create: XOR<PresentationAuthorCreateWithoutUserInput, PresentationAuthorUncheckedCreateWithoutUserInput>
  }

  export type PresentationAuthorUpdateWithWhereUniqueWithoutUserInput = {
    where: PresentationAuthorWhereUniqueInput
    data: XOR<PresentationAuthorUpdateWithoutUserInput, PresentationAuthorUncheckedUpdateWithoutUserInput>
  }

  export type PresentationAuthorUpdateManyWithWhereWithoutUserInput = {
    where: PresentationAuthorScalarWhereInput
    data: XOR<PresentationAuthorUpdateManyMutationInput, PresentationAuthorUncheckedUpdateManyWithoutUserInput>
  }

  export type PresentationAuthorScalarWhereInput = {
    AND?: PresentationAuthorScalarWhereInput | PresentationAuthorScalarWhereInput[]
    OR?: PresentationAuthorScalarWhereInput[]
    NOT?: PresentationAuthorScalarWhereInput | PresentationAuthorScalarWhereInput[]
    id?: IntFilter<"PresentationAuthor"> | number
    presentationId?: IntFilter<"PresentationAuthor"> | number
    userId?: IntNullableFilter<"PresentationAuthor"> | number | null
    authorName?: StringFilter<"PresentationAuthor"> | string
    authorEmail?: StringNullableFilter<"PresentationAuthor"> | string | null
    affiliation?: StringNullableFilter<"PresentationAuthor"> | string | null
    isPresenter?: BoolFilter<"PresentationAuthor"> | boolean
    isExternal?: BoolFilter<"PresentationAuthor"> | boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ConferenceFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: ConferenceFeedbackWhereUniqueInput
    update: XOR<ConferenceFeedbackUpdateWithoutUserInput, ConferenceFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<ConferenceFeedbackCreateWithoutUserInput, ConferenceFeedbackUncheckedCreateWithoutUserInput>
  }

  export type ConferenceFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: ConferenceFeedbackWhereUniqueInput
    data: XOR<ConferenceFeedbackUpdateWithoutUserInput, ConferenceFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type ConferenceFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: ConferenceFeedbackScalarWhereInput
    data: XOR<ConferenceFeedbackUpdateManyMutationInput, ConferenceFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type ConferenceFeedbackScalarWhereInput = {
    AND?: ConferenceFeedbackScalarWhereInput | ConferenceFeedbackScalarWhereInput[]
    OR?: ConferenceFeedbackScalarWhereInput[]
    NOT?: ConferenceFeedbackScalarWhereInput | ConferenceFeedbackScalarWhereInput[]
    id?: IntFilter<"ConferenceFeedback"> | number
    conferenceId?: IntFilter<"ConferenceFeedback"> | number
    userId?: IntFilter<"ConferenceFeedback"> | number
    rating?: IntFilter<"ConferenceFeedback"> | number
    comments?: StringNullableFilter<"ConferenceFeedback"> | string | null
    submittedAt?: DateTimeFilter<"ConferenceFeedback"> | Date | string
  }

  export type PresentationFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: PresentationFeedbackWhereUniqueInput
    update: XOR<PresentationFeedbackUpdateWithoutUserInput, PresentationFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<PresentationFeedbackCreateWithoutUserInput, PresentationFeedbackUncheckedCreateWithoutUserInput>
  }

  export type PresentationFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: PresentationFeedbackWhereUniqueInput
    data: XOR<PresentationFeedbackUpdateWithoutUserInput, PresentationFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type PresentationFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: PresentationFeedbackScalarWhereInput
    data: XOR<PresentationFeedbackUpdateManyMutationInput, PresentationFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type PresentationFeedbackScalarWhereInput = {
    AND?: PresentationFeedbackScalarWhereInput | PresentationFeedbackScalarWhereInput[]
    OR?: PresentationFeedbackScalarWhereInput[]
    NOT?: PresentationFeedbackScalarWhereInput | PresentationFeedbackScalarWhereInput[]
    id?: IntFilter<"PresentationFeedback"> | number
    presentationId?: IntFilter<"PresentationFeedback"> | number
    userId?: IntFilter<"PresentationFeedback"> | number
    rating?: IntFilter<"PresentationFeedback"> | number
    comments?: StringNullableFilter<"PresentationFeedback"> | string | null
    submittedAt?: DateTimeFilter<"PresentationFeedback"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    tokenHash?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type UserCreateWithoutConferencesInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConferencesInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConferencesInput, UserUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceMemberCreateWithoutConferenceInput = {
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
    user: UserCreateNestedOneWithoutConferenceMembershipInput
  }

  export type ConferenceMemberUncheckedCreateWithoutConferenceInput = {
    id?: number
    userId: number
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
  }

  export type ConferenceMemberCreateOrConnectWithoutConferenceInput = {
    where: ConferenceMemberWhereUniqueInput
    create: XOR<ConferenceMemberCreateWithoutConferenceInput, ConferenceMemberUncheckedCreateWithoutConferenceInput>
  }

  export type ConferenceMemberCreateManyConferenceInputEnvelope = {
    data: ConferenceMemberCreateManyConferenceInput | ConferenceMemberCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type DayCreateWithoutConferenceInput = {
    date: Date | string
    name: string
    order?: number
    sections?: SectionCreateNestedManyWithoutDayInput
  }

  export type DayUncheckedCreateWithoutConferenceInput = {
    id?: number
    date: Date | string
    name: string
    order?: number
    sections?: SectionUncheckedCreateNestedManyWithoutDayInput
  }

  export type DayCreateOrConnectWithoutConferenceInput = {
    where: DayWhereUniqueInput
    create: XOR<DayCreateWithoutConferenceInput, DayUncheckedCreateWithoutConferenceInput>
  }

  export type DayCreateManyConferenceInputEnvelope = {
    data: DayCreateManyConferenceInput | DayCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutConferenceInput = {
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    day?: DayCreateNestedOneWithoutSectionsInput
    category?: CategoryCreateNestedOneWithoutSectionsInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSectionInput
    presentations?: PresentationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutConferenceInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayId?: number | null
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSectionInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutConferenceInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutConferenceInput, SectionUncheckedCreateWithoutConferenceInput>
  }

  export type SectionCreateManyConferenceInputEnvelope = {
    data: SectionCreateManyConferenceInput | SectionCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutConferenceInput = {
    name: string
    order?: number
    presentations?: PresentationCreateNestedManyWithoutCategoryInput
    sections?: SectionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutConferenceInput = {
    id?: number
    name: string
    order?: number
    presentations?: PresentationUncheckedCreateNestedManyWithoutCategoryInput
    sections?: SectionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutConferenceInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutConferenceInput, CategoryUncheckedCreateWithoutConferenceInput>
  }

  export type CategoryCreateManyConferenceInputEnvelope = {
    data: CategoryCreateManyConferenceInput | CategoryCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type PresentationTypeCreateWithoutConferenceInput = {
    name: string
    description?: string | null
    defaultDuration?: number
    order?: number
    presentations?: PresentationCreateNestedManyWithoutPresentationTypeInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeUncheckedCreateWithoutConferenceInput = {
    id?: number
    name: string
    description?: string | null
    defaultDuration?: number
    order?: number
    presentations?: PresentationUncheckedCreateNestedManyWithoutPresentationTypeInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeCreateOrConnectWithoutConferenceInput = {
    where: PresentationTypeWhereUniqueInput
    create: XOR<PresentationTypeCreateWithoutConferenceInput, PresentationTypeUncheckedCreateWithoutConferenceInput>
  }

  export type PresentationTypeCreateManyConferenceInputEnvelope = {
    data: PresentationTypeCreateManyConferenceInput | PresentationTypeCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionSettingsCreateWithoutConferenceInput = {
    submissionDeadline: Date | string
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: SubmissionSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: number
    maxCoAuthors?: number
    minKeywords?: number
    maxKeywords?: number
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
  }

  export type SubmissionSettingsUncheckedCreateWithoutConferenceInput = {
    id?: number
    submissionDeadline: Date | string
    requireAbstract?: boolean
    requireFullPaper?: boolean
    allowedFileTypes?: SubmissionSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: number
    maxCoAuthors?: number
    minKeywords?: number
    maxKeywords?: number
    enableSubmissions?: boolean
    sendConfirmationEmail?: boolean
  }

  export type SubmissionSettingsCreateOrConnectWithoutConferenceInput = {
    where: SubmissionSettingsWhereUniqueInput
    create: XOR<SubmissionSettingsCreateWithoutConferenceInput, SubmissionSettingsUncheckedCreateWithoutConferenceInput>
  }

  export type AbstractSubmissionCreateWithoutConferenceInput = {
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    submitter: UserCreateNestedOneWithoutAbstractSubmissionsInput
    reviews?: AbstractReviewCreateNestedManyWithoutAbstractInput
    presentationType?: PresentationTypeCreateNestedOneWithoutAbstractSubmissionsInput
  }

  export type AbstractSubmissionUncheckedCreateWithoutConferenceInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
    reviews?: AbstractReviewUncheckedCreateNestedManyWithoutAbstractInput
  }

  export type AbstractSubmissionCreateOrConnectWithoutConferenceInput = {
    where: AbstractSubmissionWhereUniqueInput
    create: XOR<AbstractSubmissionCreateWithoutConferenceInput, AbstractSubmissionUncheckedCreateWithoutConferenceInput>
  }

  export type AbstractSubmissionCreateManyConferenceInputEnvelope = {
    data: AbstractSubmissionCreateManyConferenceInput | AbstractSubmissionCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type PresentationCreateWithoutConferenceInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    section?: SectionCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutConferenceInput = {
    id?: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutConferenceInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutConferenceInput, PresentationUncheckedCreateWithoutConferenceInput>
  }

  export type PresentationCreateManyConferenceInputEnvelope = {
    data: PresentationCreateManyConferenceInput | PresentationCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFeedbackCreateWithoutConferenceInput = {
    rating: number
    comments?: string | null
    submittedAt?: Date | string
    user: UserCreateNestedOneWithoutConferenceFeedbackInput
  }

  export type ConferenceFeedbackUncheckedCreateWithoutConferenceInput = {
    id?: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type ConferenceFeedbackCreateOrConnectWithoutConferenceInput = {
    where: ConferenceFeedbackWhereUniqueInput
    create: XOR<ConferenceFeedbackCreateWithoutConferenceInput, ConferenceFeedbackUncheckedCreateWithoutConferenceInput>
  }

  export type ConferenceFeedbackCreateManyConferenceInputEnvelope = {
    data: ConferenceFeedbackCreateManyConferenceInput | ConferenceFeedbackCreateManyConferenceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConferencesInput = {
    update: XOR<UserUpdateWithoutConferencesInput, UserUncheckedUpdateWithoutConferencesInput>
    create: XOR<UserCreateWithoutConferencesInput, UserUncheckedCreateWithoutConferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConferencesInput, UserUncheckedUpdateWithoutConferencesInput>
  }

  export type UserUpdateWithoutConferencesInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConferenceMemberUpsertWithWhereUniqueWithoutConferenceInput = {
    where: ConferenceMemberWhereUniqueInput
    update: XOR<ConferenceMemberUpdateWithoutConferenceInput, ConferenceMemberUncheckedUpdateWithoutConferenceInput>
    create: XOR<ConferenceMemberCreateWithoutConferenceInput, ConferenceMemberUncheckedCreateWithoutConferenceInput>
  }

  export type ConferenceMemberUpdateWithWhereUniqueWithoutConferenceInput = {
    where: ConferenceMemberWhereUniqueInput
    data: XOR<ConferenceMemberUpdateWithoutConferenceInput, ConferenceMemberUncheckedUpdateWithoutConferenceInput>
  }

  export type ConferenceMemberUpdateManyWithWhereWithoutConferenceInput = {
    where: ConferenceMemberScalarWhereInput
    data: XOR<ConferenceMemberUpdateManyMutationInput, ConferenceMemberUncheckedUpdateManyWithoutConferenceInput>
  }

  export type DayUpsertWithWhereUniqueWithoutConferenceInput = {
    where: DayWhereUniqueInput
    update: XOR<DayUpdateWithoutConferenceInput, DayUncheckedUpdateWithoutConferenceInput>
    create: XOR<DayCreateWithoutConferenceInput, DayUncheckedCreateWithoutConferenceInput>
  }

  export type DayUpdateWithWhereUniqueWithoutConferenceInput = {
    where: DayWhereUniqueInput
    data: XOR<DayUpdateWithoutConferenceInput, DayUncheckedUpdateWithoutConferenceInput>
  }

  export type DayUpdateManyWithWhereWithoutConferenceInput = {
    where: DayScalarWhereInput
    data: XOR<DayUpdateManyMutationInput, DayUncheckedUpdateManyWithoutConferenceInput>
  }

  export type DayScalarWhereInput = {
    AND?: DayScalarWhereInput | DayScalarWhereInput[]
    OR?: DayScalarWhereInput[]
    NOT?: DayScalarWhereInput | DayScalarWhereInput[]
    id?: IntFilter<"Day"> | number
    conferenceId?: IntFilter<"Day"> | number
    date?: DateTimeFilter<"Day"> | Date | string
    name?: StringFilter<"Day"> | string
    order?: IntFilter<"Day"> | number
  }

  export type SectionUpsertWithWhereUniqueWithoutConferenceInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutConferenceInput, SectionUncheckedUpdateWithoutConferenceInput>
    create: XOR<SectionCreateWithoutConferenceInput, SectionUncheckedCreateWithoutConferenceInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutConferenceInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutConferenceInput, SectionUncheckedUpdateWithoutConferenceInput>
  }

  export type SectionUpdateManyWithWhereWithoutConferenceInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutConferenceInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: IntFilter<"Section"> | number
    name?: StringFilter<"Section"> | string
    startTime?: DateTimeNullableFilter<"Section"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Section"> | Date | string | null
    conferenceId?: IntFilter<"Section"> | number
    dayId?: IntNullableFilter<"Section"> | number | null
    type?: EnumSectionTypeFilter<"Section"> | $Enums.SectionType
    categoryId?: IntNullableFilter<"Section"> | number | null
    room?: StringNullableFilter<"Section"> | string | null
    capacity?: IntNullableFilter<"Section"> | number | null
    description?: StringNullableFilter<"Section"> | string | null
  }

  export type CategoryUpsertWithWhereUniqueWithoutConferenceInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutConferenceInput, CategoryUncheckedUpdateWithoutConferenceInput>
    create: XOR<CategoryCreateWithoutConferenceInput, CategoryUncheckedCreateWithoutConferenceInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutConferenceInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutConferenceInput, CategoryUncheckedUpdateWithoutConferenceInput>
  }

  export type CategoryUpdateManyWithWhereWithoutConferenceInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutConferenceInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    conferenceId?: IntFilter<"Category"> | number
    order?: IntFilter<"Category"> | number
  }

  export type PresentationTypeUpsertWithWhereUniqueWithoutConferenceInput = {
    where: PresentationTypeWhereUniqueInput
    update: XOR<PresentationTypeUpdateWithoutConferenceInput, PresentationTypeUncheckedUpdateWithoutConferenceInput>
    create: XOR<PresentationTypeCreateWithoutConferenceInput, PresentationTypeUncheckedCreateWithoutConferenceInput>
  }

  export type PresentationTypeUpdateWithWhereUniqueWithoutConferenceInput = {
    where: PresentationTypeWhereUniqueInput
    data: XOR<PresentationTypeUpdateWithoutConferenceInput, PresentationTypeUncheckedUpdateWithoutConferenceInput>
  }

  export type PresentationTypeUpdateManyWithWhereWithoutConferenceInput = {
    where: PresentationTypeScalarWhereInput
    data: XOR<PresentationTypeUpdateManyMutationInput, PresentationTypeUncheckedUpdateManyWithoutConferenceInput>
  }

  export type PresentationTypeScalarWhereInput = {
    AND?: PresentationTypeScalarWhereInput | PresentationTypeScalarWhereInput[]
    OR?: PresentationTypeScalarWhereInput[]
    NOT?: PresentationTypeScalarWhereInput | PresentationTypeScalarWhereInput[]
    id?: IntFilter<"PresentationType"> | number
    name?: StringFilter<"PresentationType"> | string
    description?: StringNullableFilter<"PresentationType"> | string | null
    defaultDuration?: IntFilter<"PresentationType"> | number
    conferenceId?: IntFilter<"PresentationType"> | number
    order?: IntFilter<"PresentationType"> | number
  }

  export type SubmissionSettingsUpsertWithoutConferenceInput = {
    update: XOR<SubmissionSettingsUpdateWithoutConferenceInput, SubmissionSettingsUncheckedUpdateWithoutConferenceInput>
    create: XOR<SubmissionSettingsCreateWithoutConferenceInput, SubmissionSettingsUncheckedCreateWithoutConferenceInput>
    where?: SubmissionSettingsWhereInput
  }

  export type SubmissionSettingsUpdateToOneWithWhereWithoutConferenceInput = {
    where?: SubmissionSettingsWhereInput
    data: XOR<SubmissionSettingsUpdateWithoutConferenceInput, SubmissionSettingsUncheckedUpdateWithoutConferenceInput>
  }

  export type SubmissionSettingsUpdateWithoutConferenceInput = {
    submissionDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    requireAbstract?: BoolFieldUpdateOperationsInput | boolean
    requireFullPaper?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: SubmissionSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: IntFieldUpdateOperationsInput | number
    maxCoAuthors?: IntFieldUpdateOperationsInput | number
    minKeywords?: IntFieldUpdateOperationsInput | number
    maxKeywords?: IntFieldUpdateOperationsInput | number
    enableSubmissions?: BoolFieldUpdateOperationsInput | boolean
    sendConfirmationEmail?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubmissionSettingsUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    requireAbstract?: BoolFieldUpdateOperationsInput | boolean
    requireFullPaper?: BoolFieldUpdateOperationsInput | boolean
    allowedFileTypes?: SubmissionSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: IntFieldUpdateOperationsInput | number
    maxCoAuthors?: IntFieldUpdateOperationsInput | number
    minKeywords?: IntFieldUpdateOperationsInput | number
    maxKeywords?: IntFieldUpdateOperationsInput | number
    enableSubmissions?: BoolFieldUpdateOperationsInput | boolean
    sendConfirmationEmail?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AbstractSubmissionUpsertWithWhereUniqueWithoutConferenceInput = {
    where: AbstractSubmissionWhereUniqueInput
    update: XOR<AbstractSubmissionUpdateWithoutConferenceInput, AbstractSubmissionUncheckedUpdateWithoutConferenceInput>
    create: XOR<AbstractSubmissionCreateWithoutConferenceInput, AbstractSubmissionUncheckedCreateWithoutConferenceInput>
  }

  export type AbstractSubmissionUpdateWithWhereUniqueWithoutConferenceInput = {
    where: AbstractSubmissionWhereUniqueInput
    data: XOR<AbstractSubmissionUpdateWithoutConferenceInput, AbstractSubmissionUncheckedUpdateWithoutConferenceInput>
  }

  export type AbstractSubmissionUpdateManyWithWhereWithoutConferenceInput = {
    where: AbstractSubmissionScalarWhereInput
    data: XOR<AbstractSubmissionUpdateManyMutationInput, AbstractSubmissionUncheckedUpdateManyWithoutConferenceInput>
  }

  export type PresentationUpsertWithWhereUniqueWithoutConferenceInput = {
    where: PresentationWhereUniqueInput
    update: XOR<PresentationUpdateWithoutConferenceInput, PresentationUncheckedUpdateWithoutConferenceInput>
    create: XOR<PresentationCreateWithoutConferenceInput, PresentationUncheckedCreateWithoutConferenceInput>
  }

  export type PresentationUpdateWithWhereUniqueWithoutConferenceInput = {
    where: PresentationWhereUniqueInput
    data: XOR<PresentationUpdateWithoutConferenceInput, PresentationUncheckedUpdateWithoutConferenceInput>
  }

  export type PresentationUpdateManyWithWhereWithoutConferenceInput = {
    where: PresentationScalarWhereInput
    data: XOR<PresentationUpdateManyMutationInput, PresentationUncheckedUpdateManyWithoutConferenceInput>
  }

  export type PresentationScalarWhereInput = {
    AND?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
    OR?: PresentationScalarWhereInput[]
    NOT?: PresentationScalarWhereInput | PresentationScalarWhereInput[]
    id?: IntFilter<"Presentation"> | number
    conferenceId?: IntFilter<"Presentation"> | number
    title?: StringFilter<"Presentation"> | string
    abstract?: StringNullableFilter<"Presentation"> | string | null
    duration?: IntNullableFilter<"Presentation"> | number | null
    status?: StringFilter<"Presentation"> | string
    createdAt?: DateTimeFilter<"Presentation"> | Date | string
    sectionId?: IntNullableFilter<"Presentation"> | number | null
    categoryId?: IntNullableFilter<"Presentation"> | number | null
    presentationTypeId?: IntNullableFilter<"Presentation"> | number | null
  }

  export type ConferenceFeedbackUpsertWithWhereUniqueWithoutConferenceInput = {
    where: ConferenceFeedbackWhereUniqueInput
    update: XOR<ConferenceFeedbackUpdateWithoutConferenceInput, ConferenceFeedbackUncheckedUpdateWithoutConferenceInput>
    create: XOR<ConferenceFeedbackCreateWithoutConferenceInput, ConferenceFeedbackUncheckedCreateWithoutConferenceInput>
  }

  export type ConferenceFeedbackUpdateWithWhereUniqueWithoutConferenceInput = {
    where: ConferenceFeedbackWhereUniqueInput
    data: XOR<ConferenceFeedbackUpdateWithoutConferenceInput, ConferenceFeedbackUncheckedUpdateWithoutConferenceInput>
  }

  export type ConferenceFeedbackUpdateManyWithWhereWithoutConferenceInput = {
    where: ConferenceFeedbackScalarWhereInput
    data: XOR<ConferenceFeedbackUpdateManyMutationInput, ConferenceFeedbackUncheckedUpdateManyWithoutConferenceInput>
  }

  export type ConferenceCreateWithoutMembersInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutMembersInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutMembersInput, ConferenceUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutConferenceMembershipInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConferenceMembershipInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConferenceMembershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConferenceMembershipInput, UserUncheckedCreateWithoutConferenceMembershipInput>
  }

  export type ConferenceUpsertWithoutMembersInput = {
    update: XOR<ConferenceUpdateWithoutMembersInput, ConferenceUncheckedUpdateWithoutMembersInput>
    create: XOR<ConferenceCreateWithoutMembersInput, ConferenceUncheckedCreateWithoutMembersInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutMembersInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutMembersInput, ConferenceUncheckedUpdateWithoutMembersInput>
  }

  export type ConferenceUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type UserUpsertWithoutConferenceMembershipInput = {
    update: XOR<UserUpdateWithoutConferenceMembershipInput, UserUncheckedUpdateWithoutConferenceMembershipInput>
    create: XOR<UserCreateWithoutConferenceMembershipInput, UserUncheckedCreateWithoutConferenceMembershipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConferenceMembershipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConferenceMembershipInput, UserUncheckedUpdateWithoutConferenceMembershipInput>
  }

  export type UserUpdateWithoutConferenceMembershipInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConferenceMembershipInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConferenceCreateWithoutDaysInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutDaysInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutDaysInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutDaysInput, ConferenceUncheckedCreateWithoutDaysInput>
  }

  export type SectionCreateWithoutDayInput = {
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    conference: ConferenceCreateNestedOneWithoutSectionsInput
    category?: CategoryCreateNestedOneWithoutSectionsInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSectionInput
    presentations?: PresentationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutDayInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSectionInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutDayInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutDayInput, SectionUncheckedCreateWithoutDayInput>
  }

  export type SectionCreateManyDayInputEnvelope = {
    data: SectionCreateManyDayInput | SectionCreateManyDayInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceUpsertWithoutDaysInput = {
    update: XOR<ConferenceUpdateWithoutDaysInput, ConferenceUncheckedUpdateWithoutDaysInput>
    create: XOR<ConferenceCreateWithoutDaysInput, ConferenceUncheckedCreateWithoutDaysInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutDaysInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutDaysInput, ConferenceUncheckedUpdateWithoutDaysInput>
  }

  export type ConferenceUpdateWithoutDaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutDaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type SectionUpsertWithWhereUniqueWithoutDayInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutDayInput, SectionUncheckedUpdateWithoutDayInput>
    create: XOR<SectionCreateWithoutDayInput, SectionUncheckedCreateWithoutDayInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutDayInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutDayInput, SectionUncheckedUpdateWithoutDayInput>
  }

  export type SectionUpdateManyWithWhereWithoutDayInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutDayInput>
  }

  export type ConferenceCreateWithoutSectionsInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutSectionsInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutSectionsInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutSectionsInput, ConferenceUncheckedCreateWithoutSectionsInput>
  }

  export type DayCreateWithoutSectionsInput = {
    date: Date | string
    name: string
    order?: number
    conference: ConferenceCreateNestedOneWithoutDaysInput
  }

  export type DayUncheckedCreateWithoutSectionsInput = {
    id?: number
    conferenceId: number
    date: Date | string
    name: string
    order?: number
  }

  export type DayCreateOrConnectWithoutSectionsInput = {
    where: DayWhereUniqueInput
    create: XOR<DayCreateWithoutSectionsInput, DayUncheckedCreateWithoutSectionsInput>
  }

  export type CategoryCreateWithoutSectionsInput = {
    name: string
    order?: number
    conference: ConferenceCreateNestedOneWithoutCategoriesInput
    presentations?: PresentationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSectionsInput = {
    id?: number
    name: string
    conferenceId: number
    order?: number
    presentations?: PresentationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSectionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSectionsInput, CategoryUncheckedCreateWithoutSectionsInput>
  }

  export type TimeSlotCreateWithoutSectionInput = {
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
    presentation?: PresentationCreateNestedOneWithoutTimeSlotInput
  }

  export type TimeSlotUncheckedCreateWithoutSectionInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    presentationId?: number | null
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
  }

  export type TimeSlotCreateOrConnectWithoutSectionInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutSectionInput, TimeSlotUncheckedCreateWithoutSectionInput>
  }

  export type TimeSlotCreateManySectionInputEnvelope = {
    data: TimeSlotCreateManySectionInput | TimeSlotCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type PresentationCreateWithoutSectionInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutSectionInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    categoryId?: number | null
    presentationTypeId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutSectionInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutSectionInput, PresentationUncheckedCreateWithoutSectionInput>
  }

  export type PresentationCreateManySectionInputEnvelope = {
    data: PresentationCreateManySectionInput | PresentationCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceUpsertWithoutSectionsInput = {
    update: XOR<ConferenceUpdateWithoutSectionsInput, ConferenceUncheckedUpdateWithoutSectionsInput>
    create: XOR<ConferenceCreateWithoutSectionsInput, ConferenceUncheckedCreateWithoutSectionsInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutSectionsInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutSectionsInput, ConferenceUncheckedUpdateWithoutSectionsInput>
  }

  export type ConferenceUpdateWithoutSectionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutSectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type DayUpsertWithoutSectionsInput = {
    update: XOR<DayUpdateWithoutSectionsInput, DayUncheckedUpdateWithoutSectionsInput>
    create: XOR<DayCreateWithoutSectionsInput, DayUncheckedCreateWithoutSectionsInput>
    where?: DayWhereInput
  }

  export type DayUpdateToOneWithWhereWithoutSectionsInput = {
    where?: DayWhereInput
    data: XOR<DayUpdateWithoutSectionsInput, DayUncheckedUpdateWithoutSectionsInput>
  }

  export type DayUpdateWithoutSectionsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutDaysNestedInput
  }

  export type DayUncheckedUpdateWithoutSectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryUpsertWithoutSectionsInput = {
    update: XOR<CategoryUpdateWithoutSectionsInput, CategoryUncheckedUpdateWithoutSectionsInput>
    create: XOR<CategoryCreateWithoutSectionsInput, CategoryUncheckedCreateWithoutSectionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSectionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSectionsInput, CategoryUncheckedUpdateWithoutSectionsInput>
  }

  export type CategoryUpdateWithoutSectionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutCategoriesNestedInput
    presentations?: PresentationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TimeSlotUpsertWithWhereUniqueWithoutSectionInput = {
    where: TimeSlotWhereUniqueInput
    update: XOR<TimeSlotUpdateWithoutSectionInput, TimeSlotUncheckedUpdateWithoutSectionInput>
    create: XOR<TimeSlotCreateWithoutSectionInput, TimeSlotUncheckedCreateWithoutSectionInput>
  }

  export type TimeSlotUpdateWithWhereUniqueWithoutSectionInput = {
    where: TimeSlotWhereUniqueInput
    data: XOR<TimeSlotUpdateWithoutSectionInput, TimeSlotUncheckedUpdateWithoutSectionInput>
  }

  export type TimeSlotUpdateManyWithWhereWithoutSectionInput = {
    where: TimeSlotScalarWhereInput
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyWithoutSectionInput>
  }

  export type TimeSlotScalarWhereInput = {
    AND?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    OR?: TimeSlotScalarWhereInput[]
    NOT?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    id?: IntFilter<"TimeSlot"> | number
    sectionId?: IntFilter<"TimeSlot"> | number
    startTime?: DateTimeFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeFilter<"TimeSlot"> | Date | string
    slotType?: EnumSlotTypeFilter<"TimeSlot"> | $Enums.SlotType
    isOccupied?: BoolFilter<"TimeSlot"> | boolean
    presentationId?: IntNullableFilter<"TimeSlot"> | number | null
    title?: StringNullableFilter<"TimeSlot"> | string | null
    breakType?: EnumBreakTypeNullableFilter<"TimeSlot"> | $Enums.BreakType | null
    description?: StringNullableFilter<"TimeSlot"> | string | null
  }

  export type PresentationUpsertWithWhereUniqueWithoutSectionInput = {
    where: PresentationWhereUniqueInput
    update: XOR<PresentationUpdateWithoutSectionInput, PresentationUncheckedUpdateWithoutSectionInput>
    create: XOR<PresentationCreateWithoutSectionInput, PresentationUncheckedCreateWithoutSectionInput>
  }

  export type PresentationUpdateWithWhereUniqueWithoutSectionInput = {
    where: PresentationWhereUniqueInput
    data: XOR<PresentationUpdateWithoutSectionInput, PresentationUncheckedUpdateWithoutSectionInput>
  }

  export type PresentationUpdateManyWithWhereWithoutSectionInput = {
    where: PresentationScalarWhereInput
    data: XOR<PresentationUpdateManyMutationInput, PresentationUncheckedUpdateManyWithoutSectionInput>
  }

  export type SectionCreateWithoutTimeSlotsInput = {
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    conference: ConferenceCreateNestedOneWithoutSectionsInput
    day?: DayCreateNestedOneWithoutSectionsInput
    category?: CategoryCreateNestedOneWithoutSectionsInput
    presentations?: PresentationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutTimeSlotsInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    dayId?: number | null
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
    presentations?: PresentationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutTimeSlotsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTimeSlotsInput, SectionUncheckedCreateWithoutTimeSlotsInput>
  }

  export type PresentationCreateWithoutTimeSlotInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    section?: SectionCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutTimeSlotInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutTimeSlotInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutTimeSlotInput, PresentationUncheckedCreateWithoutTimeSlotInput>
  }

  export type SectionUpsertWithoutTimeSlotsInput = {
    update: XOR<SectionUpdateWithoutTimeSlotsInput, SectionUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<SectionCreateWithoutTimeSlotsInput, SectionUncheckedCreateWithoutTimeSlotsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTimeSlotsInput, SectionUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type SectionUpdateWithoutTimeSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conference?: ConferenceUpdateOneRequiredWithoutSectionsNestedInput
    day?: DayUpdateOneWithoutSectionsNestedInput
    category?: CategoryUpdateOneWithoutSectionsNestedInput
    presentations?: PresentationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutTimeSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    presentations?: PresentationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type PresentationUpsertWithoutTimeSlotInput = {
    update: XOR<PresentationUpdateWithoutTimeSlotInput, PresentationUncheckedUpdateWithoutTimeSlotInput>
    create: XOR<PresentationCreateWithoutTimeSlotInput, PresentationUncheckedCreateWithoutTimeSlotInput>
    where?: PresentationWhereInput
  }

  export type PresentationUpdateToOneWithWhereWithoutTimeSlotInput = {
    where?: PresentationWhereInput
    data: XOR<PresentationUpdateWithoutTimeSlotInput, PresentationUncheckedUpdateWithoutTimeSlotInput>
  }

  export type PresentationUpdateWithoutTimeSlotInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutTimeSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type UserCreateWithoutAbstractSubmissionsInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAbstractSubmissionsInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAbstractSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAbstractSubmissionsInput, UserUncheckedCreateWithoutAbstractSubmissionsInput>
  }

  export type ConferenceCreateWithoutAbstractSubmissionsInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutAbstractSubmissionsInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutAbstractSubmissionsInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutAbstractSubmissionsInput, ConferenceUncheckedCreateWithoutAbstractSubmissionsInput>
  }

  export type AbstractReviewCreateWithoutAbstractInput = {
    score: number
    comments?: string | null
    recommendation: string
    reviewer: UserCreateNestedOneWithoutAbstractReviewsInput
  }

  export type AbstractReviewUncheckedCreateWithoutAbstractInput = {
    id?: number
    reviewerId: number
    score: number
    comments?: string | null
    recommendation: string
  }

  export type AbstractReviewCreateOrConnectWithoutAbstractInput = {
    where: AbstractReviewWhereUniqueInput
    create: XOR<AbstractReviewCreateWithoutAbstractInput, AbstractReviewUncheckedCreateWithoutAbstractInput>
  }

  export type AbstractReviewCreateManyAbstractInputEnvelope = {
    data: AbstractReviewCreateManyAbstractInput | AbstractReviewCreateManyAbstractInput[]
    skipDuplicates?: boolean
  }

  export type PresentationTypeCreateWithoutAbstractSubmissionsInput = {
    name: string
    description?: string | null
    defaultDuration?: number
    order?: number
    conference: ConferenceCreateNestedOneWithoutPresentationTypesInput
    presentations?: PresentationCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeUncheckedCreateWithoutAbstractSubmissionsInput = {
    id?: number
    name: string
    description?: string | null
    defaultDuration?: number
    conferenceId: number
    order?: number
    presentations?: PresentationUncheckedCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeCreateOrConnectWithoutAbstractSubmissionsInput = {
    where: PresentationTypeWhereUniqueInput
    create: XOR<PresentationTypeCreateWithoutAbstractSubmissionsInput, PresentationTypeUncheckedCreateWithoutAbstractSubmissionsInput>
  }

  export type UserUpsertWithoutAbstractSubmissionsInput = {
    update: XOR<UserUpdateWithoutAbstractSubmissionsInput, UserUncheckedUpdateWithoutAbstractSubmissionsInput>
    create: XOR<UserCreateWithoutAbstractSubmissionsInput, UserUncheckedCreateWithoutAbstractSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAbstractSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAbstractSubmissionsInput, UserUncheckedUpdateWithoutAbstractSubmissionsInput>
  }

  export type UserUpdateWithoutAbstractSubmissionsInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAbstractSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConferenceUpsertWithoutAbstractSubmissionsInput = {
    update: XOR<ConferenceUpdateWithoutAbstractSubmissionsInput, ConferenceUncheckedUpdateWithoutAbstractSubmissionsInput>
    create: XOR<ConferenceCreateWithoutAbstractSubmissionsInput, ConferenceUncheckedCreateWithoutAbstractSubmissionsInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutAbstractSubmissionsInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutAbstractSubmissionsInput, ConferenceUncheckedUpdateWithoutAbstractSubmissionsInput>
  }

  export type ConferenceUpdateWithoutAbstractSubmissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutAbstractSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type AbstractReviewUpsertWithWhereUniqueWithoutAbstractInput = {
    where: AbstractReviewWhereUniqueInput
    update: XOR<AbstractReviewUpdateWithoutAbstractInput, AbstractReviewUncheckedUpdateWithoutAbstractInput>
    create: XOR<AbstractReviewCreateWithoutAbstractInput, AbstractReviewUncheckedCreateWithoutAbstractInput>
  }

  export type AbstractReviewUpdateWithWhereUniqueWithoutAbstractInput = {
    where: AbstractReviewWhereUniqueInput
    data: XOR<AbstractReviewUpdateWithoutAbstractInput, AbstractReviewUncheckedUpdateWithoutAbstractInput>
  }

  export type AbstractReviewUpdateManyWithWhereWithoutAbstractInput = {
    where: AbstractReviewScalarWhereInput
    data: XOR<AbstractReviewUpdateManyMutationInput, AbstractReviewUncheckedUpdateManyWithoutAbstractInput>
  }

  export type PresentationTypeUpsertWithoutAbstractSubmissionsInput = {
    update: XOR<PresentationTypeUpdateWithoutAbstractSubmissionsInput, PresentationTypeUncheckedUpdateWithoutAbstractSubmissionsInput>
    create: XOR<PresentationTypeCreateWithoutAbstractSubmissionsInput, PresentationTypeUncheckedCreateWithoutAbstractSubmissionsInput>
    where?: PresentationTypeWhereInput
  }

  export type PresentationTypeUpdateToOneWithWhereWithoutAbstractSubmissionsInput = {
    where?: PresentationTypeWhereInput
    data: XOR<PresentationTypeUpdateWithoutAbstractSubmissionsInput, PresentationTypeUncheckedUpdateWithoutAbstractSubmissionsInput>
  }

  export type PresentationTypeUpdateWithoutAbstractSubmissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutPresentationTypesNestedInput
    presentations?: PresentationUpdateManyWithoutPresentationTypeNestedInput
  }

  export type PresentationTypeUncheckedUpdateWithoutAbstractSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUncheckedUpdateManyWithoutPresentationTypeNestedInput
  }

  export type AbstractSubmissionCreateWithoutReviewsInput = {
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    submitter: UserCreateNestedOneWithoutAbstractSubmissionsInput
    conference: ConferenceCreateNestedOneWithoutAbstractSubmissionsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutAbstractSubmissionsInput
  }

  export type AbstractSubmissionUncheckedCreateWithoutReviewsInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
  }

  export type AbstractSubmissionCreateOrConnectWithoutReviewsInput = {
    where: AbstractSubmissionWhereUniqueInput
    create: XOR<AbstractSubmissionCreateWithoutReviewsInput, AbstractSubmissionUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutAbstractReviewsInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAbstractReviewsInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAbstractReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAbstractReviewsInput, UserUncheckedCreateWithoutAbstractReviewsInput>
  }

  export type AbstractSubmissionUpsertWithoutReviewsInput = {
    update: XOR<AbstractSubmissionUpdateWithoutReviewsInput, AbstractSubmissionUncheckedUpdateWithoutReviewsInput>
    create: XOR<AbstractSubmissionCreateWithoutReviewsInput, AbstractSubmissionUncheckedCreateWithoutReviewsInput>
    where?: AbstractSubmissionWhereInput
  }

  export type AbstractSubmissionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: AbstractSubmissionWhereInput
    data: XOR<AbstractSubmissionUpdateWithoutReviewsInput, AbstractSubmissionUncheckedUpdateWithoutReviewsInput>
  }

  export type AbstractSubmissionUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitter?: UserUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    conference?: ConferenceUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutAbstractSubmissionsNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutAbstractReviewsInput = {
    update: XOR<UserUpdateWithoutAbstractReviewsInput, UserUncheckedUpdateWithoutAbstractReviewsInput>
    create: XOR<UserCreateWithoutAbstractReviewsInput, UserUncheckedCreateWithoutAbstractReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAbstractReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAbstractReviewsInput, UserUncheckedUpdateWithoutAbstractReviewsInput>
  }

  export type UserUpdateWithoutAbstractReviewsInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAbstractReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConferenceCreateWithoutPresentationsInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutPresentationsInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutPresentationsInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutPresentationsInput, ConferenceUncheckedCreateWithoutPresentationsInput>
  }

  export type SectionCreateWithoutPresentationsInput = {
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    conference: ConferenceCreateNestedOneWithoutSectionsInput
    day?: DayCreateNestedOneWithoutSectionsInput
    category?: CategoryCreateNestedOneWithoutSectionsInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutPresentationsInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    dayId?: number | null
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutPresentationsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutPresentationsInput, SectionUncheckedCreateWithoutPresentationsInput>
  }

  export type PresentationAuthorCreateWithoutPresentationInput = {
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
    user?: UserCreateNestedOneWithoutPresentationsInput
  }

  export type PresentationAuthorUncheckedCreateWithoutPresentationInput = {
    id?: number
    userId?: number | null
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type PresentationAuthorCreateOrConnectWithoutPresentationInput = {
    where: PresentationAuthorWhereUniqueInput
    create: XOR<PresentationAuthorCreateWithoutPresentationInput, PresentationAuthorUncheckedCreateWithoutPresentationInput>
  }

  export type PresentationAuthorCreateManyPresentationInputEnvelope = {
    data: PresentationAuthorCreateManyPresentationInput | PresentationAuthorCreateManyPresentationInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutPresentationsInput = {
    name: string
    order?: number
    conference: ConferenceCreateNestedOneWithoutCategoriesInput
    sections?: SectionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPresentationsInput = {
    id?: number
    name: string
    conferenceId: number
    order?: number
    sections?: SectionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPresentationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPresentationsInput, CategoryUncheckedCreateWithoutPresentationsInput>
  }

  export type PresentationTypeCreateWithoutPresentationsInput = {
    name: string
    description?: string | null
    defaultDuration?: number
    order?: number
    conference: ConferenceCreateNestedOneWithoutPresentationTypesInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeUncheckedCreateWithoutPresentationsInput = {
    id?: number
    name: string
    description?: string | null
    defaultDuration?: number
    conferenceId: number
    order?: number
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutPresentationTypeInput
  }

  export type PresentationTypeCreateOrConnectWithoutPresentationsInput = {
    where: PresentationTypeWhereUniqueInput
    create: XOR<PresentationTypeCreateWithoutPresentationsInput, PresentationTypeUncheckedCreateWithoutPresentationsInput>
  }

  export type TimeSlotCreateWithoutPresentationInput = {
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
    section: SectionCreateNestedOneWithoutTimeSlotsInput
  }

  export type TimeSlotUncheckedCreateWithoutPresentationInput = {
    id?: number
    sectionId: number
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
  }

  export type TimeSlotCreateOrConnectWithoutPresentationInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutPresentationInput, TimeSlotUncheckedCreateWithoutPresentationInput>
  }

  export type PresentationFeedbackCreateWithoutPresentationInput = {
    rating: number
    comments?: string | null
    submittedAt?: Date | string
    user: UserCreateNestedOneWithoutPresentationFeedbackInput
  }

  export type PresentationFeedbackUncheckedCreateWithoutPresentationInput = {
    id?: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PresentationFeedbackCreateOrConnectWithoutPresentationInput = {
    where: PresentationFeedbackWhereUniqueInput
    create: XOR<PresentationFeedbackCreateWithoutPresentationInput, PresentationFeedbackUncheckedCreateWithoutPresentationInput>
  }

  export type PresentationFeedbackCreateManyPresentationInputEnvelope = {
    data: PresentationFeedbackCreateManyPresentationInput | PresentationFeedbackCreateManyPresentationInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceUpsertWithoutPresentationsInput = {
    update: XOR<ConferenceUpdateWithoutPresentationsInput, ConferenceUncheckedUpdateWithoutPresentationsInput>
    create: XOR<ConferenceCreateWithoutPresentationsInput, ConferenceUncheckedCreateWithoutPresentationsInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutPresentationsInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutPresentationsInput, ConferenceUncheckedUpdateWithoutPresentationsInput>
  }

  export type ConferenceUpdateWithoutPresentationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutPresentationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type SectionUpsertWithoutPresentationsInput = {
    update: XOR<SectionUpdateWithoutPresentationsInput, SectionUncheckedUpdateWithoutPresentationsInput>
    create: XOR<SectionCreateWithoutPresentationsInput, SectionUncheckedCreateWithoutPresentationsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutPresentationsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutPresentationsInput, SectionUncheckedUpdateWithoutPresentationsInput>
  }

  export type SectionUpdateWithoutPresentationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conference?: ConferenceUpdateOneRequiredWithoutSectionsNestedInput
    day?: DayUpdateOneWithoutSectionsNestedInput
    category?: CategoryUpdateOneWithoutSectionsNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutPresentationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type PresentationAuthorUpsertWithWhereUniqueWithoutPresentationInput = {
    where: PresentationAuthorWhereUniqueInput
    update: XOR<PresentationAuthorUpdateWithoutPresentationInput, PresentationAuthorUncheckedUpdateWithoutPresentationInput>
    create: XOR<PresentationAuthorCreateWithoutPresentationInput, PresentationAuthorUncheckedCreateWithoutPresentationInput>
  }

  export type PresentationAuthorUpdateWithWhereUniqueWithoutPresentationInput = {
    where: PresentationAuthorWhereUniqueInput
    data: XOR<PresentationAuthorUpdateWithoutPresentationInput, PresentationAuthorUncheckedUpdateWithoutPresentationInput>
  }

  export type PresentationAuthorUpdateManyWithWhereWithoutPresentationInput = {
    where: PresentationAuthorScalarWhereInput
    data: XOR<PresentationAuthorUpdateManyMutationInput, PresentationAuthorUncheckedUpdateManyWithoutPresentationInput>
  }

  export type CategoryUpsertWithoutPresentationsInput = {
    update: XOR<CategoryUpdateWithoutPresentationsInput, CategoryUncheckedUpdateWithoutPresentationsInput>
    create: XOR<CategoryCreateWithoutPresentationsInput, CategoryUncheckedCreateWithoutPresentationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPresentationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPresentationsInput, CategoryUncheckedUpdateWithoutPresentationsInput>
  }

  export type CategoryUpdateWithoutPresentationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutCategoriesNestedInput
    sections?: SectionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPresentationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    sections?: SectionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PresentationTypeUpsertWithoutPresentationsInput = {
    update: XOR<PresentationTypeUpdateWithoutPresentationsInput, PresentationTypeUncheckedUpdateWithoutPresentationsInput>
    create: XOR<PresentationTypeCreateWithoutPresentationsInput, PresentationTypeUncheckedCreateWithoutPresentationsInput>
    where?: PresentationTypeWhereInput
  }

  export type PresentationTypeUpdateToOneWithWhereWithoutPresentationsInput = {
    where?: PresentationTypeWhereInput
    data: XOR<PresentationTypeUpdateWithoutPresentationsInput, PresentationTypeUncheckedUpdateWithoutPresentationsInput>
  }

  export type PresentationTypeUpdateWithoutPresentationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    conference?: ConferenceUpdateOneRequiredWithoutPresentationTypesNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutPresentationTypeNestedInput
  }

  export type PresentationTypeUncheckedUpdateWithoutPresentationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutPresentationTypeNestedInput
  }

  export type TimeSlotUpsertWithoutPresentationInput = {
    update: XOR<TimeSlotUpdateWithoutPresentationInput, TimeSlotUncheckedUpdateWithoutPresentationInput>
    create: XOR<TimeSlotCreateWithoutPresentationInput, TimeSlotUncheckedCreateWithoutPresentationInput>
    where?: TimeSlotWhereInput
  }

  export type TimeSlotUpdateToOneWithWhereWithoutPresentationInput = {
    where?: TimeSlotWhereInput
    data: XOR<TimeSlotUpdateWithoutPresentationInput, TimeSlotUncheckedUpdateWithoutPresentationInput>
  }

  export type TimeSlotUpdateWithoutPresentationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    section?: SectionUpdateOneRequiredWithoutTimeSlotsNestedInput
  }

  export type TimeSlotUncheckedUpdateWithoutPresentationInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PresentationFeedbackUpsertWithWhereUniqueWithoutPresentationInput = {
    where: PresentationFeedbackWhereUniqueInput
    update: XOR<PresentationFeedbackUpdateWithoutPresentationInput, PresentationFeedbackUncheckedUpdateWithoutPresentationInput>
    create: XOR<PresentationFeedbackCreateWithoutPresentationInput, PresentationFeedbackUncheckedCreateWithoutPresentationInput>
  }

  export type PresentationFeedbackUpdateWithWhereUniqueWithoutPresentationInput = {
    where: PresentationFeedbackWhereUniqueInput
    data: XOR<PresentationFeedbackUpdateWithoutPresentationInput, PresentationFeedbackUncheckedUpdateWithoutPresentationInput>
  }

  export type PresentationFeedbackUpdateManyWithWhereWithoutPresentationInput = {
    where: PresentationFeedbackScalarWhereInput
    data: XOR<PresentationFeedbackUpdateManyMutationInput, PresentationFeedbackUncheckedUpdateManyWithoutPresentationInput>
  }

  export type PresentationCreateWithoutAuthorsInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    section?: SectionCreateNestedOneWithoutPresentationsInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutAuthorsInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutAuthorsInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutAuthorsInput, PresentationUncheckedCreateWithoutAuthorsInput>
  }

  export type UserCreateWithoutPresentationsInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPresentationsInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPresentationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPresentationsInput, UserUncheckedCreateWithoutPresentationsInput>
  }

  export type PresentationUpsertWithoutAuthorsInput = {
    update: XOR<PresentationUpdateWithoutAuthorsInput, PresentationUncheckedUpdateWithoutAuthorsInput>
    create: XOR<PresentationCreateWithoutAuthorsInput, PresentationUncheckedCreateWithoutAuthorsInput>
    where?: PresentationWhereInput
  }

  export type PresentationUpdateToOneWithWhereWithoutAuthorsInput = {
    where?: PresentationWhereInput
    data: XOR<PresentationUpdateWithoutAuthorsInput, PresentationUncheckedUpdateWithoutAuthorsInput>
  }

  export type PresentationUpdateWithoutAuthorsInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type UserUpsertWithoutPresentationsInput = {
    update: XOR<UserUpdateWithoutPresentationsInput, UserUncheckedUpdateWithoutPresentationsInput>
    create: XOR<UserCreateWithoutPresentationsInput, UserUncheckedCreateWithoutPresentationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPresentationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPresentationsInput, UserUncheckedUpdateWithoutPresentationsInput>
  }

  export type UserUpdateWithoutPresentationsInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPresentationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConferenceCreateWithoutCategoriesInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutCategoriesInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutCategoriesInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutCategoriesInput, ConferenceUncheckedCreateWithoutCategoriesInput>
  }

  export type PresentationCreateWithoutCategoryInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    section?: SectionCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutCategoryInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    presentationTypeId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutCategoryInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutCategoryInput, PresentationUncheckedCreateWithoutCategoryInput>
  }

  export type PresentationCreateManyCategoryInputEnvelope = {
    data: PresentationCreateManyCategoryInput | PresentationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutCategoryInput = {
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    conference: ConferenceCreateNestedOneWithoutSectionsInput
    day?: DayCreateNestedOneWithoutSectionsInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSectionInput
    presentations?: PresentationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    dayId?: number | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSectionInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutCategoryInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutCategoryInput, SectionUncheckedCreateWithoutCategoryInput>
  }

  export type SectionCreateManyCategoryInputEnvelope = {
    data: SectionCreateManyCategoryInput | SectionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceUpsertWithoutCategoriesInput = {
    update: XOR<ConferenceUpdateWithoutCategoriesInput, ConferenceUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ConferenceCreateWithoutCategoriesInput, ConferenceUncheckedCreateWithoutCategoriesInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutCategoriesInput, ConferenceUncheckedUpdateWithoutCategoriesInput>
  }

  export type ConferenceUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type PresentationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PresentationWhereUniqueInput
    update: XOR<PresentationUpdateWithoutCategoryInput, PresentationUncheckedUpdateWithoutCategoryInput>
    create: XOR<PresentationCreateWithoutCategoryInput, PresentationUncheckedCreateWithoutCategoryInput>
  }

  export type PresentationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PresentationWhereUniqueInput
    data: XOR<PresentationUpdateWithoutCategoryInput, PresentationUncheckedUpdateWithoutCategoryInput>
  }

  export type PresentationUpdateManyWithWhereWithoutCategoryInput = {
    where: PresentationScalarWhereInput
    data: XOR<PresentationUpdateManyMutationInput, PresentationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SectionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutCategoryInput, SectionUncheckedUpdateWithoutCategoryInput>
    create: XOR<SectionCreateWithoutCategoryInput, SectionUncheckedCreateWithoutCategoryInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutCategoryInput, SectionUncheckedUpdateWithoutCategoryInput>
  }

  export type SectionUpdateManyWithWhereWithoutCategoryInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ConferenceCreateWithoutPresentationTypesInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutPresentationTypesInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutPresentationTypesInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutPresentationTypesInput, ConferenceUncheckedCreateWithoutPresentationTypesInput>
  }

  export type PresentationCreateWithoutPresentationTypeInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    section?: SectionCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackCreateNestedManyWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutPresentationTypeInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
    feedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutPresentationTypeInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutPresentationTypeInput, PresentationUncheckedCreateWithoutPresentationTypeInput>
  }

  export type PresentationCreateManyPresentationTypeInputEnvelope = {
    data: PresentationCreateManyPresentationTypeInput | PresentationCreateManyPresentationTypeInput[]
    skipDuplicates?: boolean
  }

  export type AbstractSubmissionCreateWithoutPresentationTypeInput = {
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    submitter: UserCreateNestedOneWithoutAbstractSubmissionsInput
    conference: ConferenceCreateNestedOneWithoutAbstractSubmissionsInput
    reviews?: AbstractReviewCreateNestedManyWithoutAbstractInput
  }

  export type AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AbstractReviewUncheckedCreateNestedManyWithoutAbstractInput
  }

  export type AbstractSubmissionCreateOrConnectWithoutPresentationTypeInput = {
    where: AbstractSubmissionWhereUniqueInput
    create: XOR<AbstractSubmissionCreateWithoutPresentationTypeInput, AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput>
  }

  export type AbstractSubmissionCreateManyPresentationTypeInputEnvelope = {
    data: AbstractSubmissionCreateManyPresentationTypeInput | AbstractSubmissionCreateManyPresentationTypeInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceUpsertWithoutPresentationTypesInput = {
    update: XOR<ConferenceUpdateWithoutPresentationTypesInput, ConferenceUncheckedUpdateWithoutPresentationTypesInput>
    create: XOR<ConferenceCreateWithoutPresentationTypesInput, ConferenceUncheckedCreateWithoutPresentationTypesInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutPresentationTypesInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutPresentationTypesInput, ConferenceUncheckedUpdateWithoutPresentationTypesInput>
  }

  export type ConferenceUpdateWithoutPresentationTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutPresentationTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type PresentationUpsertWithWhereUniqueWithoutPresentationTypeInput = {
    where: PresentationWhereUniqueInput
    update: XOR<PresentationUpdateWithoutPresentationTypeInput, PresentationUncheckedUpdateWithoutPresentationTypeInput>
    create: XOR<PresentationCreateWithoutPresentationTypeInput, PresentationUncheckedCreateWithoutPresentationTypeInput>
  }

  export type PresentationUpdateWithWhereUniqueWithoutPresentationTypeInput = {
    where: PresentationWhereUniqueInput
    data: XOR<PresentationUpdateWithoutPresentationTypeInput, PresentationUncheckedUpdateWithoutPresentationTypeInput>
  }

  export type PresentationUpdateManyWithWhereWithoutPresentationTypeInput = {
    where: PresentationScalarWhereInput
    data: XOR<PresentationUpdateManyMutationInput, PresentationUncheckedUpdateManyWithoutPresentationTypeInput>
  }

  export type AbstractSubmissionUpsertWithWhereUniqueWithoutPresentationTypeInput = {
    where: AbstractSubmissionWhereUniqueInput
    update: XOR<AbstractSubmissionUpdateWithoutPresentationTypeInput, AbstractSubmissionUncheckedUpdateWithoutPresentationTypeInput>
    create: XOR<AbstractSubmissionCreateWithoutPresentationTypeInput, AbstractSubmissionUncheckedCreateWithoutPresentationTypeInput>
  }

  export type AbstractSubmissionUpdateWithWhereUniqueWithoutPresentationTypeInput = {
    where: AbstractSubmissionWhereUniqueInput
    data: XOR<AbstractSubmissionUpdateWithoutPresentationTypeInput, AbstractSubmissionUncheckedUpdateWithoutPresentationTypeInput>
  }

  export type AbstractSubmissionUpdateManyWithWhereWithoutPresentationTypeInput = {
    where: AbstractSubmissionScalarWhereInput
    data: XOR<AbstractSubmissionUpdateManyMutationInput, AbstractSubmissionUncheckedUpdateManyWithoutPresentationTypeInput>
  }

  export type ConferenceCreateWithoutSubmissionSettingsInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutSubmissionSettingsInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
    feedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutSubmissionSettingsInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutSubmissionSettingsInput, ConferenceUncheckedCreateWithoutSubmissionSettingsInput>
  }

  export type ConferenceUpsertWithoutSubmissionSettingsInput = {
    update: XOR<ConferenceUpdateWithoutSubmissionSettingsInput, ConferenceUncheckedUpdateWithoutSubmissionSettingsInput>
    create: XOR<ConferenceCreateWithoutSubmissionSettingsInput, ConferenceUncheckedCreateWithoutSubmissionSettingsInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutSubmissionSettingsInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutSubmissionSettingsInput, ConferenceUncheckedUpdateWithoutSubmissionSettingsInput>
  }

  export type ConferenceUpdateWithoutSubmissionSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutSubmissionSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceCreateWithoutFeedbackInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutConferencesInput
    members?: ConferenceMemberCreateNestedManyWithoutConferenceInput
    days?: DayCreateNestedManyWithoutConferenceInput
    sections?: SectionCreateNestedManyWithoutConferenceInput
    categories?: CategoryCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutConferenceInput
    presentations?: PresentationCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceUncheckedCreateWithoutFeedbackInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConferenceMemberUncheckedCreateNestedManyWithoutConferenceInput
    days?: DayUncheckedCreateNestedManyWithoutConferenceInput
    sections?: SectionUncheckedCreateNestedManyWithoutConferenceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutConferenceInput
    presentationTypes?: PresentationTypeUncheckedCreateNestedManyWithoutConferenceInput
    submissionSettings?: SubmissionSettingsUncheckedCreateNestedOneWithoutConferenceInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutConferenceInput
    presentations?: PresentationUncheckedCreateNestedManyWithoutConferenceInput
  }

  export type ConferenceCreateOrConnectWithoutFeedbackInput = {
    where: ConferenceWhereUniqueInput
    create: XOR<ConferenceCreateWithoutFeedbackInput, ConferenceUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutConferenceFeedbackInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConferenceFeedbackInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConferenceFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConferenceFeedbackInput, UserUncheckedCreateWithoutConferenceFeedbackInput>
  }

  export type ConferenceUpsertWithoutFeedbackInput = {
    update: XOR<ConferenceUpdateWithoutFeedbackInput, ConferenceUncheckedUpdateWithoutFeedbackInput>
    create: XOR<ConferenceCreateWithoutFeedbackInput, ConferenceUncheckedCreateWithoutFeedbackInput>
    where?: ConferenceWhereInput
  }

  export type ConferenceUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: ConferenceWhereInput
    data: XOR<ConferenceUpdateWithoutFeedbackInput, ConferenceUncheckedUpdateWithoutFeedbackInput>
  }

  export type ConferenceUpdateWithoutFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutConferencesNestedInput
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type UserUpsertWithoutConferenceFeedbackInput = {
    update: XOR<UserUpdateWithoutConferenceFeedbackInput, UserUncheckedUpdateWithoutConferenceFeedbackInput>
    create: XOR<UserCreateWithoutConferenceFeedbackInput, UserUncheckedCreateWithoutConferenceFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConferenceFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConferenceFeedbackInput, UserUncheckedUpdateWithoutConferenceFeedbackInput>
  }

  export type UserUpdateWithoutConferenceFeedbackInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConferenceFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PresentationCreateWithoutFeedbackInput = {
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    conference: ConferenceCreateNestedOneWithoutPresentationsInput
    section?: SectionCreateNestedOneWithoutPresentationsInput
    authors?: PresentationAuthorCreateNestedManyWithoutPresentationInput
    category?: CategoryCreateNestedOneWithoutPresentationsInput
    presentationType?: PresentationTypeCreateNestedOneWithoutPresentationsInput
    timeSlot?: TimeSlotCreateNestedOneWithoutPresentationInput
  }

  export type PresentationUncheckedCreateWithoutFeedbackInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
    authors?: PresentationAuthorUncheckedCreateNestedManyWithoutPresentationInput
    timeSlot?: TimeSlotUncheckedCreateNestedOneWithoutPresentationInput
  }

  export type PresentationCreateOrConnectWithoutFeedbackInput = {
    where: PresentationWhereUniqueInput
    create: XOR<PresentationCreateWithoutFeedbackInput, PresentationUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutPresentationFeedbackInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPresentationFeedbackInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPresentationFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPresentationFeedbackInput, UserUncheckedCreateWithoutPresentationFeedbackInput>
  }

  export type PresentationUpsertWithoutFeedbackInput = {
    update: XOR<PresentationUpdateWithoutFeedbackInput, PresentationUncheckedUpdateWithoutFeedbackInput>
    create: XOR<PresentationCreateWithoutFeedbackInput, PresentationUncheckedCreateWithoutFeedbackInput>
    where?: PresentationWhereInput
  }

  export type PresentationUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: PresentationWhereInput
    data: XOR<PresentationUpdateWithoutFeedbackInput, PresentationUncheckedUpdateWithoutFeedbackInput>
  }

  export type PresentationUpdateWithoutFeedbackInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
  }

  export type UserUpsertWithoutPresentationFeedbackInput = {
    update: XOR<UserUpdateWithoutPresentationFeedbackInput, UserUncheckedUpdateWithoutPresentationFeedbackInput>
    create: XOR<UserCreateWithoutPresentationFeedbackInput, UserUncheckedCreateWithoutPresentationFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPresentationFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPresentationFeedbackInput, UserUncheckedUpdateWithoutPresentationFeedbackInput>
  }

  export type UserUpdateWithoutPresentationFeedbackInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPresentationFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: number
    cognitoId?: string | null
    name: string
    email: string
    password?: string | null
    roles?: UserCreaterolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    conferences?: ConferenceUncheckedCreateNestedManyWithoutCreatedByInput
    conferenceMembership?: ConferenceMemberUncheckedCreateNestedManyWithoutUserInput
    abstractSubmissions?: AbstractSubmissionUncheckedCreateNestedManyWithoutSubmitterInput
    abstractReviews?: AbstractReviewUncheckedCreateNestedManyWithoutReviewerInput
    presentations?: PresentationAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conferenceFeedback?: ConferenceFeedbackUncheckedCreateNestedManyWithoutUserInput
    presentationFeedback?: PresentationFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    cognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserUpdaterolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferences?: ConferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    conferenceMembership?: ConferenceMemberUncheckedUpdateManyWithoutUserNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutSubmitterNestedInput
    abstractReviews?: AbstractReviewUncheckedUpdateManyWithoutReviewerNestedInput
    presentations?: PresentationAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conferenceFeedback?: ConferenceFeedbackUncheckedUpdateManyWithoutUserNestedInput
    presentationFeedback?: PresentationFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConferenceCreateManyCreatedByInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    status?: $Enums.ConferenceStatus
    topics?: ConferenceCreatetopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceMemberCreateManyUserInput = {
    id?: number
    conferenceId: number
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
  }

  export type AbstractSubmissionCreateManySubmitterInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
  }

  export type AbstractReviewCreateManyReviewerInput = {
    id?: number
    abstractId: number
    score: number
    comments?: string | null
    recommendation: string
  }

  export type PresentationAuthorCreateManyUserInput = {
    id?: number
    presentationId: number
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ConferenceFeedbackCreateManyUserInput = {
    id?: number
    conferenceId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PresentationFeedbackCreateManyUserInput = {
    id?: number
    presentationId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: number
    tokenHash: string
    createdAt?: Date | string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type ConferenceUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUpdateManyWithoutConferenceNestedInput
    days?: DayUpdateManyWithoutConferenceNestedInput
    sections?: SectionUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConferenceMemberUncheckedUpdateManyWithoutConferenceNestedInput
    days?: DayUncheckedUpdateManyWithoutConferenceNestedInput
    sections?: SectionUncheckedUpdateManyWithoutConferenceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutConferenceNestedInput
    presentationTypes?: PresentationTypeUncheckedUpdateManyWithoutConferenceNestedInput
    submissionSettings?: SubmissionSettingsUncheckedUpdateOneWithoutConferenceNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutConferenceNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutConferenceNestedInput
    feedback?: ConferenceFeedbackUncheckedUpdateManyWithoutConferenceNestedInput
  }

  export type ConferenceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConferenceStatusFieldUpdateOperationsInput | $Enums.ConferenceStatus
    topics?: ConferenceUpdatetopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberUpdateWithoutUserInput = {
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ConferenceMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbstractSubmissionUpdateWithoutSubmitterInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    reviews?: AbstractReviewUpdateManyWithoutAbstractNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutAbstractSubmissionsNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateWithoutSubmitterInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: AbstractReviewUncheckedUpdateManyWithoutAbstractNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateManyWithoutSubmitterInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AbstractReviewUpdateWithoutReviewerInput = {
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
    abstract?: AbstractSubmissionUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type AbstractReviewUncheckedUpdateWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    abstractId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type AbstractReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    abstractId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type PresentationAuthorUpdateWithoutUserInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    presentation?: PresentationUpdateOneRequiredWithoutAuthorsNestedInput
  }

  export type PresentationAuthorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PresentationAuthorUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbackUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type ConferenceFeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationFeedbackUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentation?: PresentationUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type PresentationFeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    presentationId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberCreateManyConferenceInput = {
    id?: number
    userId: number
    isAttendee?: boolean
    isSpeaker?: boolean
    registeredAt?: Date | string
  }

  export type DayCreateManyConferenceInput = {
    id?: number
    date: Date | string
    name: string
    order?: number
  }

  export type SectionCreateManyConferenceInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayId?: number | null
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
  }

  export type CategoryCreateManyConferenceInput = {
    id?: number
    name: string
    order?: number
  }

  export type PresentationTypeCreateManyConferenceInput = {
    id?: number
    name: string
    description?: string | null
    defaultDuration?: number
    order?: number
  }

  export type AbstractSubmissionCreateManyConferenceInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    presentationTypeId?: number | null
  }

  export type PresentationCreateManyConferenceInput = {
    id?: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
    presentationTypeId?: number | null
  }

  export type ConferenceFeedbackCreateManyConferenceInput = {
    id?: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type ConferenceMemberUpdateWithoutConferenceInput = {
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConferenceMembershipNestedInput
  }

  export type ConferenceMemberUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceMemberUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isAttendee?: BoolFieldUpdateOperationsInput | boolean
    isSpeaker?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayUpdateWithoutConferenceInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sections?: SectionUpdateManyWithoutDayNestedInput
  }

  export type DayUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sections?: SectionUncheckedUpdateManyWithoutDayNestedInput
  }

  export type DayUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SectionUpdateWithoutConferenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    day?: DayUpdateOneWithoutSectionsNestedInput
    category?: CategoryUpdateOneWithoutSectionsNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUpdateWithoutConferenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUpdateManyWithoutCategoryNestedInput
    sections?: SectionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUncheckedUpdateManyWithoutCategoryNestedInput
    sections?: SectionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PresentationTypeUpdateWithoutConferenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUpdateManyWithoutPresentationTypeNestedInput
    abstractSubmissions?: AbstractSubmissionUpdateManyWithoutPresentationTypeNestedInput
  }

  export type PresentationTypeUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    presentations?: PresentationUncheckedUpdateManyWithoutPresentationTypeNestedInput
    abstractSubmissions?: AbstractSubmissionUncheckedUpdateManyWithoutPresentationTypeNestedInput
  }

  export type PresentationTypeUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AbstractSubmissionUpdateWithoutConferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitter?: UserUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    reviews?: AbstractReviewUpdateManyWithoutAbstractNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutAbstractSubmissionsNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: AbstractReviewUncheckedUpdateManyWithoutAbstractNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresentationUpdateWithoutConferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConferenceFeedbackUpdateWithoutConferenceInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConferenceFeedbackNestedInput
  }

  export type ConferenceFeedbackUncheckedUpdateWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbackUncheckedUpdateManyWithoutConferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyDayInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    type?: $Enums.SectionType
    categoryId?: number | null
    room?: string | null
    capacity?: number | null
    description?: string | null
  }

  export type SectionUpdateWithoutDayInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conference?: ConferenceUpdateOneRequiredWithoutSectionsNestedInput
    category?: CategoryUpdateOneWithoutSectionsNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSlotCreateManySectionInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    slotType?: $Enums.SlotType
    isOccupied?: boolean
    presentationId?: number | null
    title?: string | null
    breakType?: $Enums.BreakType | null
    description?: string | null
  }

  export type PresentationCreateManySectionInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    categoryId?: number | null
    presentationTypeId?: number | null
  }

  export type TimeSlotUpdateWithoutSectionInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    presentation?: PresentationUpdateOneWithoutTimeSlotNestedInput
  }

  export type TimeSlotUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    presentationId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSlotUncheckedUpdateManyWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    presentationId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    breakType?: NullableEnumBreakTypeFieldUpdateOperationsInput | $Enums.BreakType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PresentationUpdateWithoutSectionInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateManyWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AbstractReviewCreateManyAbstractInput = {
    id?: number
    reviewerId: number
    score: number
    comments?: string | null
    recommendation: string
  }

  export type AbstractReviewUpdateWithoutAbstractInput = {
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
    reviewer?: UserUpdateOneRequiredWithoutAbstractReviewsNestedInput
  }

  export type AbstractReviewUncheckedUpdateWithoutAbstractInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type AbstractReviewUncheckedUpdateManyWithoutAbstractInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type PresentationAuthorCreateManyPresentationInput = {
    id?: number
    userId?: number | null
    authorName: string
    authorEmail?: string | null
    affiliation?: string | null
    isPresenter?: boolean
    isExternal?: boolean
  }

  export type PresentationFeedbackCreateManyPresentationInput = {
    id?: number
    userId: number
    rating: number
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PresentationAuthorUpdateWithoutPresentationInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutPresentationsNestedInput
  }

  export type PresentationAuthorUncheckedUpdateWithoutPresentationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PresentationAuthorUncheckedUpdateManyWithoutPresentationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    isPresenter?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PresentationFeedbackUpdateWithoutPresentationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPresentationFeedbackNestedInput
  }

  export type PresentationFeedbackUncheckedUpdateWithoutPresentationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationFeedbackUncheckedUpdateManyWithoutPresentationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresentationCreateManyCategoryInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    presentationTypeId?: number | null
  }

  export type SectionCreateManyCategoryInput = {
    id?: number
    name: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    conferenceId: number
    dayId?: number | null
    type?: $Enums.SectionType
    room?: string | null
    capacity?: number | null
    description?: string | null
  }

  export type PresentationUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    presentationType?: PresentationTypeUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    presentationTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SectionUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conference?: ConferenceUpdateOneRequiredWithoutSectionsNestedInput
    day?: DayUpdateOneWithoutSectionsNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSectionNestedInput
    presentations?: PresentationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conferenceId?: IntFieldUpdateOperationsInput | number
    dayId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    room?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PresentationCreateManyPresentationTypeInput = {
    id?: number
    conferenceId: number
    title: string
    abstract?: string | null
    duration?: number | null
    status: string
    createdAt?: Date | string
    sectionId?: number | null
    categoryId?: number | null
  }

  export type AbstractSubmissionCreateManyPresentationTypeInput = {
    id?: number
    title: string
    abstractText?: string | null
    fileUrl?: string | null
    submitterId: number
    conferenceId: number
    status?: $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PresentationUpdateWithoutPresentationTypeInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conference?: ConferenceUpdateOneRequiredWithoutPresentationsNestedInput
    section?: SectionUpdateOneWithoutPresentationsNestedInput
    authors?: PresentationAuthorUpdateManyWithoutPresentationNestedInput
    category?: CategoryUpdateOneWithoutPresentationsNestedInput
    timeSlot?: TimeSlotUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateWithoutPresentationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    authors?: PresentationAuthorUncheckedUpdateManyWithoutPresentationNestedInput
    timeSlot?: TimeSlotUncheckedUpdateOneWithoutPresentationNestedInput
    feedback?: PresentationFeedbackUncheckedUpdateManyWithoutPresentationNestedInput
  }

  export type PresentationUncheckedUpdateManyWithoutPresentationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AbstractSubmissionUpdateWithoutPresentationTypeInput = {
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitter?: UserUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    conference?: ConferenceUpdateOneRequiredWithoutAbstractSubmissionsNestedInput
    reviews?: AbstractReviewUpdateManyWithoutAbstractNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateWithoutPresentationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AbstractReviewUncheckedUpdateManyWithoutAbstractNestedInput
  }

  export type AbstractSubmissionUncheckedUpdateManyWithoutPresentationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    abstractText?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: IntFieldUpdateOperationsInput | number
    conferenceId?: IntFieldUpdateOperationsInput | number
    status?: EnumAbstractSubmissionStatusFieldUpdateOperationsInput | $Enums.AbstractSubmissionStatus
    keywords?: AbstractSubmissionUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}